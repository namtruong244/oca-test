[
  {
    "id": 1,
    "name": "OCA Practice Exam 1",
    "description": "Set 1",
    "questions": [
  {
    "id": 1,
    "type": "single",
    "questionText": "Consider codes below:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//A.java\npackage com.udayan.oca;\n \npublic class A {\n    public void print() {\n        System.out.println(\"A\");\n    }\n}\n//B.java\npackage com.udayan.oca;\n \npublic class B extends A {\n     public void print() {\n        System.out.println(\"B\");\n    }\n}\n//Test.java\npackage com.udayan.oca.test;\n \nimport com.udayan.oca.*;\n \npublic class Test {\n    public static void main(String[] args) {\n        A obj1 = new A();\n        B obj2 = (B)obj1;\n        obj2.print();\n    }\n}",
    "options": [
      { "id": "A", "text": "A" },
      { "id": "B", "text": "B" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "ClassCastException is thrown at runtime" }
    ],
    "correctAnswers": ["D"],
    "explanation": "Class A and B are declared public and inside same package com.udayan.oca.\nMethod print() of class A has correctly been overridden by B.\nprint() method is public so no issues in accessing it anywhere.\nLet's check the code inside main method.\nA obj1 = new A(); => obj1 refers to an instance of class A.\nB obj2 = (B)obj1; => obj1 is of type A and it is assigned to obj2 (B type), hence explicit casting is necessary.\nobj1 refers to an instance of class A, so at runtime obj2 will also refer to an instance of class A. sub type can't refer to an object of super type so at runtime B obj2 = (B)obj1;\nwill throw ClassCastException."
  },
  {
    "id": 2,
    "type": "single",
    "questionText": "Below is the code of Test.java file:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String [] args) {\n        List<Integer> list = new ArrayList<Integer>();\n        list.add(new Integer(2));\n        list.add(new Integer(1));\n        list.add(new Integer(0));\n \n        list.remove(list.indexOf(0));\n \n        System.out.println(list);\n    }\n}",
    "options": [
      { "id": "A", "text": "[1, 0]" },
      { "id": "B", "text": "[2, 1]" },
      { "id": "C", "text": "[2, 0]" },
      { "id": "D", "text": "[1, 2]" }
    ],
    "correctAnswers": ["B"],
    "explanation": "remove method of List interface is overloaded: remove(int) and remove(Object).\nindexOf method accepts argument of Object type, in this case list.indexOf(0) => 0 is auto-boxed to Integer object so no issues with indexOf code.\nlist.indexOf(0) returns 2 (index at which 0 is stored in the list). So list.remove(list.indexOf(0)); is converted to list.remove(2);\nremove(int) version is matched, it's a direct match so compiler doesn't do auto-boxing in this case.\nlist.remove(2) removes the element at index 2, which is 0.\nHence in the output, you get [2, 1]."
  },
  {
    "id": 3,
    "type": "multiple",
    "questionText": "Consider 3 files:\nFor the class Shop, which options, if used to replace /*INSERT*/, will resolve all the compilation errors?\nSelect 2 options.",
    "codeSnippet": "//Order.java\npackage orders;\n \npublic class Order {\n \n}\n//Item.java\npackage orders.items;\n \npublic class Item {\n \n}\n//Shop.java\npackage shopping;\n \n/*INSERT*/\n \npublic class Shop {\n    Order order = null;\n    Item item = null;\n}",
    "options": [
      { "id": "A", "text": "import orders.*;\nimport orders.items.*;" },
      { "id": "B", "text": "import orders.*;" },
      { "id": "C", "text": "import orders.Order;\nimport orders.items.Item;" },
      { "id": "D", "text": "import orders.items.*;" }
    ],
    "correctAnswers": ["A", "C"],
    "explanation": "If you check the directory structure, you will find that directory \"orders\" contains \"items\", but orders and orders.items are different packages.import orders.*;\nwill only import all the classes in orders package but not in orders.items package.\nYou need to import Order and Item classes. To import Order class, use either import orders.Order; OR import orders.*;\nand to import Item class, use either import orders.items.Item; OR import orders.items.*;"
  },
  {
    "id": 4,
    "type": "single",
    "questionText": "Consider below code:\nOn execution, does Test class print \"HELLO\" on to the console?",
    "codeSnippet": "public class Test {\n    static {\n        System.out.println(1/0);\n    }\n \n    public static void main(String[] args) {\n        System.out.println(\"HELLO\");\n    }\n}",
    "options": [
      { "id": "A", "text": "Yes, it prints HELLO" },
      { "id": "B", "text": "No, it throws ArithmeticException" },
      { "id": "C", "text": "No, it throws ExceptionInInitializerError" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["C"],
    "explanation": "To invoke the special main method, JVM loads the class in the memory.\nAt that time, static initializer block is invoked. 1/0 throws a RuntimeException and as a result static initializer block throws an instance of java.lang.ExceptionInInitializerError."
  },
  {
    "id": 5,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\n \nclass Counter {\n    int count;\n    Counter(int count) {\n        this.count = count;\n    }\n \n    public String toString() {\n        return \"Counter-\" + count;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        ArrayList<Counter> original = new ArrayList<>();\n        original.add(new Counter(10));\n \n        ArrayList<Counter> cloned = (ArrayList<Counter>) original.clone();\n        cloned.get(0).count = 5;\n \n        System.out.println(original);\n    }\n}",
    "options": [
      { "id": "A", "text": "[Counter-10]" },
      { "id": "B", "text": "[Counter-5]" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["B"],
    "explanation": "Let's see what is happening during execution:\nmain(String [] args) method goes on to the top of the STACK.\n1.  ArrayList<Counter> original = new ArrayList<>();  => It creates an ArrayList object [suppose at memory location 15EE00] and variable 'original' refers to it.\n2.  original.add(new Counter(10));  => It creates a Counter object [suppose at memory location 25AF06] and adds it as a first element of the ArrayList.\nThis means element at 0th index of the ArrayList instance refers to Counter object at the memory location 25AF06.\n3.  ArrayList<Counter> cloned = (ArrayList<Counter>) original.clone();  => original.clone() creates a new array list object, [suppose at memory location 45BA12] and then it will copy the contents of the ArrayList object stored at [15EE00].\nSo, cloned contains memory address of the same Counter object.\nIn this case, original != cloned, but original.get(0) == cloned.get(0).\nThis means both the array lists are created at different memory location but refer to same Counter object.\n4.  cloned.get(0).count = 5;  => cloned.get(0) returns the Counter object stored at the memory location 25AF06 and .count = 5 means change the value of count variable of the Counter object (stored at memory location 25AF06) to 5.\n5.  System.out.println(original);  Prints the element of ArrayList original, which is: {25AF06} and toString() method prints: [Counter-5] as Counter object referred by [25AF06] is [Counter object (5)]."
  },
  {
    "id": 6,
    "type": "single",
    "questionText": "Consider the code of Test.java file:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nclass Student {\n    String name;\n    int age;\n \n    void Student() {\n        Student(\"James\", 25);\n    }\n \n    void Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Student s = new Student();\n        System.out.println(s.name + \":\" + s.age);\n    }\n}",
    "options": [
      { "id": "A", "text": "James:25" },
      { "id": "B", "text": "null:0" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["B"],
    "explanation": "Methods can have same name as the class. Student() and Student(String, int) are methods and not constructors of the class, note the void return type of these methods.\nAs no constructors are provided in the Student class, java compiler adds default no-arg constructor.\nThat is why the statement Student s = new Student(); doesn't give any compilation error.\nDefault values are assigned to instance variables, hence null is assigned to name and 0 is assigned to age.\nIn the output, null:0 is displayed."
  },
  {
    "id": 7,
    "type": "single",
    "questionText": "Which of the following is a checked Exception?",
    "codeSnippet": "",
    "options": [
      { "id": "A", "text": "ClassCastException" },
      { "id": "B", "text": "FileNotFoundException" },
      { "id": "C", "text": "NullPointerException" },
      { "id": "D", "text": "ArithmeticException" }
    ],
    "correctAnswers": ["B"],
    "explanation": "ClassCastException extends RuntimeException (unchecked exception),\nFileNotFoundException extends IOException, IOException extends Exception (checked exception),\nExceptionInInitializerError is from Error family and is thrown by an static initializer block,\nRuntimeException and all its sub classes are unchecked exceptions."
  },
  {
    "id": 8,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str1 = new String(\"Core\");\n        String str2 = new String(\"CoRe\");\n        System.out.println(str1 = str2);\n    }\n}",
    "options": [
      { "id": "A", "text": "Core" },
      { "id": "B", "text": "CoRe" },
      { "id": "C", "text": "true" },
      { "id": "D", "text": "false" }
    ],
    "correctAnswers": ["B"],
    "explanation": "System.out.println(str1 = str2) has assignment(=) operator and not equality(==) operator.\nAfter the assignment, str1 refers to \"CoRe\" and System.out.println prints \"CoRe\" to the console."
  },
  {
    "id": 9,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \nclass MyLocalDate extends LocalDate {\n    @Override\n    public String toString() {\n        return super.getDayOfMonth() + \"-\" + super.getMonthValue() + \n            \"-\" +  super.getYear();\n    }\n}\n \npublic class Test {\n    public static void main(String [] args) {\n        MyLocalDate date = LocalDate.parse(\"1980-03-16\");\n        System.out.println(date);\n    }\n}",
    "options": [
      { "id": "A", "text": "16-3-1980" },
      { "id": "B", "text": "1980-03-16" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["C"],
    "explanation": "LocalDate is a final class so cannot be extended."
  },
  {
    "id": 10,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    private static void m(int x) {\n        System.out.println(\"int version\");\n    }\n \n    private static void m(char x) {\n        System.out.println(\"char version\");\n    }\n \n    public static void main(String [] args) {\n        int i = '5';\n        m(i);\n        m('5');\n    }\n}",
    "options": [
      { "id": "A", "text": "int version\\nint version" },
      { "id": "B", "text": "char version\\nchar version" },
      { "id": "C", "text": "int version\\nchar version" },
      { "id": "D", "text": "char version\\nint version" }
    ],
    "correctAnswers": ["C"],
    "explanation": "Method m is overloaded. Which overloaded method to invoke is decided at compile time.\nm(i) is tagged to m(int) as i is of int type and m('5') is tagged to m(char) as '5' is char literal."
  },
  {
    "id": 11,
    "type": "single",
    "questionText": "How many objects of Pen class are eligible for Garbage Collection at Line 4?",
    "codeSnippet": "package com.udayan.oca;\n \nclass Pen {\n \n}\n \npublic class TestPen {\n    public static void main(String[] args) {\n        new Pen(); //Line 1\n        Pen p = new Pen(); // Line 2\n        change(p); //Line 3\n        System.out.println(\"About to end.\"); //Line 4\n    }\n \n    public static void change(Pen pen) { //Line 5\n        pen = new Pen(); //Line 6\n    }\n}",
    "options": [
      { "id": "A", "text": "0" },
      { "id": "B", "text": "1" },
      { "id": "C", "text": "2" },
      { "id": "D", "text": "3" }
    ],
    "correctAnswers": ["C"],
    "explanation": "Object created at Line 1 becomes eligible for Garbage collection after Line 1 only, as there are no references to it.\nSo We have one object marked for GC.\nObject created at Line 6 becomes unreachable after change(Pen) method pops out of the STACK, and this happens after Line 3.\nSo at Line 4, we have two Pen objects eligible for Garbage collection: Created at Line 1 and Created at Line 6."
  },
  {
    "id": 12,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.LocalTime;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"1947-08-14\");\n        LocalTime time = LocalTime.MAX;\n        System.out.println(date.atTime(time));\n    }\n}",
    "options": [
      { "id": "A", "text": "1947-08-14T23:59:59.999999999" },
      { "id": "B", "text": "1947-08-14T00:00" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["A"],
    "explanation": "LocalTime.MIN --> {00:00}, LocalTime.MAX --> {23:59:59.999999999}, LocalTime.MIDNIGHT --> {00:00}, LocalTime.NOON --> {12:00}.\ndate.atTime(LocalTime) method creates a LocalDateTime instance by combining date and time parts.\ntoString() method of LocalDateTime class prints the date and time parts separated by T in upper case."
  },
  {
    "id": 13,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2020, 9, 31);\n        System.out.println(date);\n    }\n}",
    "options": [
      { "id": "A", "text": "2020-09-31" },
      { "id": "B", "text": "2020-10-01" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "An exception is thrown at runtime" }
    ],
    "correctAnswers": ["D"],
    "explanation": "LocalDate.of(...) method first validates year, then month and finally day of the month.\nSeptember can't have 31 days so LocalDate.of(...) method throws an instance of java.time.DateTimeException class."
  },
  {
    "id": 14,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        byte var = 100;\n        switch(var) {\n            case 100:\n                System.out.println(\"var is 100\");\n                break;\n            case 200:\n                System.out.println(\"var is 200\");\n                break;\n            default:\n                System.out.println(\"In default\");\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "var is 100" },
      { "id": "B", "text": "var is 200" },
      { "id": "C", "text": "In default" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["D"],
    "explanation": "case values must evaluate to the same type / compatible type as the switch expression can use.\nswitch expression can accept following:\nchar or Character\nbyte or Byte\nshort or Short\nint or Integer\nAn enum only from Java 6\nA String expression only from Java 7\nIn this case, switch expression [switch (var)] is of byte type.\nbyte range is from -128 to 127. But in case expression [case 200], 200 is outside byte range and hence compilation error."
  },
  {
    "id": 15,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nclass Message {\n    String msg = \"Happy New Year!\";\n \n    public void print() {\n        System.out.println(msg);\n    }\n}\n \npublic class Test {\n    public static void change(Message m) { //Line n5\n        m = new Message(); //Line n6\n        m.msg = \"Happy Holidays!\"; //Line n7\n    }\n \n    public static void main(String[] args) {\n        Message obj = new Message(); //Line n1\n        obj.print(); //Line n2\n        change(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}",
    "options": [
      { "id": "A", "text": "Happy New Year!\\nHappy Holidays!" },
      { "id": "B", "text": "Happy New Year!\\nHappy New Year!" },
      { "id": "C", "text": "Happy Holidays!\\nHappy Holidays!" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["B"],
    "explanation": "It is pass-by-reference scheme.\nInitially, msg = \"Happy New Year!\"\nCall to method change(Message) doesn't modify the msg property of passed object rather it creates another Message object and modifies the msg property of new object to \"Happy Holidays!\"\nSo, the instance of Message referred by obj remains unchanged.\nHence in the output, you get:\nHappy New Year!\nHappy New Year!"
  },
  {
    "id": 16,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        String[] names = { \"Smith\", \"Brown\", \"Thomas\", \"Taylor\", \"Jones\" };\n        List<String> list = new ArrayList<>();\n        for (int x = 0; x < names.length; x++) {\n            list.add(names[x]);\n            switch (x) {\n                case 2:\n                    continue;\n            }\n            break;\n        }\n        System.out.println(list.size());\n    }\n}",
    "options": [
      { "id": "A", "text": "1" },
      { "id": "B", "text": "2" },
      { "id": "C", "text": "3" },
      { "id": "D", "text": "5" }
    ],
    "correctAnswers": ["A"],
    "explanation": "break; and continue; are used inside for-loop, hence no compilation error.\nIn 1st iteration, x = 0. \"Smith\" is added to the list.\nThere is no matching case found, hence control just goes after the switch-case block and executes break;\nstatement, which takes the control out of the for loop.\n`System.out.println(list.size());` is executed and this prints 1 on to the console."
  },
  {
    "id": 17,
    "type": "multiple",
    "questionText": "Consider below code fragment:\nAbove code is currently giving compilation error. Which 2 modifications, done independently, enable the code to compile?",
    "codeSnippet": "interface Printable {\n    public void setMargin();\n    public void setOrientation();\n}\n \nabstract class Paper implements Printable { //Line 7\n    public void setMargin() {}\n    //Line 9\n}\n \nclass NewsPaper extends Paper { //Line 12\n    public void setMargin() {}\n    //Line 14\n}",
    "options": [
      { "id": "A", "text": "Replace class NewsPaper with abstract class NewsPaper" },
      { "id": "B", "text": "Add implementation of setOrientation() in NewsPaper" },
      { "id": "C", "text": "Remove setMargin() from NewsPaper" },
      { "id": "D", "text": "Make Paper concrete" }
    ],
    "correctAnswers": ["A", "B"],
    "explanation": "First you should find out the reason for compilation error.\nMethods declared in Printable interface are implicitly abstract, no issues with Printable interface.\nclass Paper is declared abstract and it implements Printable interface, it overrides setMargin() method but setOrientation() method is still abstract.\nNo issues with class Paper as it is an abstract class and can have 0 or more abstract methods.\nclass NewsPaper is concrete class and it extends Paper class (which is abstract).\nSo class NewsPaper must override setOrientation() method OR it must be declared abstract.\nReplacing Line 9 with 'public abstract void setOrientation();' is not necessary and it will not resolve the compilation error in NewsPaper class.\nReplacing Line 7 with 'class Paper implements Printable {' will cause compilation failure of Paper class as it inherits abstract method 'setOrientation'."
  },
  {
    "id": 18,
    "type": "single",
    "questionText": "A bank's swift code is generally of 11 characters and used in international money transfers.\nAn example of swift code: ICICINBBRT4\nICIC: First 4 letters for bank code\nIN: Next 2 letters for Country code\nBB: Next 2 letters for Location code\nRT4: Next 3 letters for Branch code\nWhich of the following code correctly extracts country code from the swift code referred by String reference variable swiftCode?",
    "codeSnippet": "String swiftCode = \"ICICINBBRT4ICIC\";",
    "options": [
      { "id": "A", "text": "swiftCode.substring(4, 5);" },
      { "id": "B", "text": "swiftCode.substring(4, 6);" },
      { "id": "C", "text": "swiftCode.substring(5, 7);" },
      { "id": "D", "text": "swiftCode.substring(4, 7);" }
    ],
    "correctAnswers": ["B"],
    "explanation": "substring(int beginIndex, int endIndex) is used to extract the substring.\nThe substring begins at \"beginIndex\" and extends till \"endIndex - 1\".\nCountry code information is stored at index 4 and 5, so the correct substring method to extract country code is: swiftCode.substring(4, 6);"
  },
  {
    "id": 19,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Month;\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<LocalDate> dates = new ArrayList<>();\n        dates.add(LocalDate.parse(\"2018-07-11\"));\n        dates.add(LocalDate.parse(\"1919-02-25\"));\n        dates.add(LocalDate.of(2020, 4, 8));\n        dates.add(LocalDate.of(1980, Month.DECEMBER, 31));\n \n        dates.removeIf(x -> x.getYear() < 2000);\n \n        System.out.println(dates);\n    }\n}",
    "options": [
      { "id": "A", "text": "[2018-07-11, 2020-04-08]" },
      { "id": "B", "text": "[1919-02-25, 1980-12-31]" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["A"],
    "explanation": "LocalDate objects can be created by using static method parse and of.\nremoveIf(Predicate) method was added as a default method in Collection interface in JDK 8 and it removes all the elements of this collection that satisfy the given predicate.\nPredicate's test method returns true for all the LocalDate objects with year less than 2000. So all the LocalDate objects with year value less than 2000 are removed from the list.\nRemaining LocalDate objects are printed in their insertion order."
  },
  {
    "id": 20,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String s1 = \"OCAJP\";\n        String s2 = \"OCAJP\" + \"\";\n        System.out.println(s1 == s2);\n    }\n}",
    "options": [
      { "id": "A", "text": "true" },
      { "id": "B", "text": "false" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "OCAJP" }
    ],
    "correctAnswers": ["A"],
    "explanation": "Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution.\nCompile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.\nFor the statement,  String s2 = \"OCAJP\" + \"\"; , `\"OCAJP\" + \"\"` is a constant expression as both the operands \"OCAJP\" and \"\" are String literals, which means the expression `\"OCAJP\" + \"\"` is computed at compile-time and results in String literal \"OCAJP\".\nSo, during compilation, Java compiler translates the statement\nString s2 = \"OCAJP\" + \"\";\nto\nString s2 = \"OCAJP\";\nAs \"OCAJP\" is a String literal, hence at runtime it will be referred by String Pool.\nWhen Test class is executed,\ns1 refers to \"OCAJP\" (String Pool object).\ns2 also refers to same String pool object \"OCAJP\".\ns1 and s2 both refer to the same String object and that is why s1 == s2 returns true.\nPlease note that Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.\nFor below code snippet:\nString s1 = \"OCAJP\";\nString s2 = s1 + \"\";\nSystem.out.println(s1 == s2);\nOutput is false, as s1 is a variable and `s1 + \"\"` is not a constant expression, therefore this expression is computed only at runtime and a new non-pool String object is created."
  },
  {
    "id": 21,
    "type": "single",
    "questionText": "Which of the following statement is correct about below code?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        do {\n            System.out.println(100);\n        } while (false);\n        System.out.println(\"Bye\");\n    }\n}",
    "options": [
      { "id": "A", "text": "Prints 100 then Bye" },
      { "id": "B", "text": "Prints 100 and throws RuntimeException" },
      { "id": "C", "text": "Compilation error due to unreachable code" },
      { "id": "D", "text": "Prints Bye only" }
    ],
    "correctAnswers": ["A"],
    "explanation": "As do-while loop executes at least once, hence none of the code is unreachable in this case.\nJava runtime prints 100 to the console, then it checks boolean expression, which is false.\nHence control goes out of do-while block. Java runtime executes 2nd System.out.println statement to print \"Bye\" on to the console."
  },
  {
    "id": 22,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        m1(); //Line 3\n    }\n \n    private static void m1() throws Exception { //Line 6\n        System.out.println(\"NOT THROWING ANY EXCEPTION\"); //Line 7\n    }\n}",
    "options": [
      { "id": "A", "text": "NOT THROWING ANY EXCEPTION" },
      { "id": "B", "text": "Compilation error at Line 3" },
      { "id": "C", "text": "Compilation error at Line 6" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["B"],
    "explanation": "If a method declares to throw Exception or its sub-type other than RuntimeException types, then calling method should follow handle or declare rule.\nIn this case, as method m1() declares to throw Exception, so main method should either declare the same exception or its super type in its throws clause OR m1();\nshould be surrounded by try-catch block.\nLine 3 in this case causes compilation error."
  },
  {
    "id": 23,
    "type": "single",
    "questionText": "Consider below code:\nWhich of the following statement is correct?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDateTime;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDateTime obj = LocalDateTime.now();\n        System.out.println(obj.getSecond());\n    }\n}",
    "options": [
      { "id": "A", "text": "obj.getSecond() returns value between 0 and 60" },
      { "id": "B", "text": "obj.getSecond() returns value between 1 and 60" },
      { "id": "C", "text": "obj.getSecond() returns value between 0 and 59" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["C"],
    "explanation": "LocalDateTime stores both date and time parts. LocalDateTime.now(); retrieves the current date and time from the system clock.\nobj.getSecond() can return any value between 0 and 59."
  },
  {
    "id": 24,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> list1 = new ArrayList<>();\n        list1.add(\"A\");\n        list1.add(\"D\");\n \n        List<String> list2 = new ArrayList<>();\n        list2.add(\"B\");\n        list2.add(\"C\");\n \n        list1.addAll(1, list2);\n \n        System.out.println(list1);\n    }\n}",
    "options": [
      { "id": "A", "text": "[A, B, C, D]" },
      { "id": "B", "text": "[A, D, B, C]" },
      { "id": "C", "text": "[B, C, A, D]" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["A"],
    "explanation": "list1 --> [A, D],\nlist2 --> [B, C],\nlist1.addAll(1, list2); is almost equal to list1.add(1, [B, C]); => Inserts B at index 1, C takes index 2 and D is moved to index 3. list1 --> [A, B, C, D]"
  },
  {
    "id": 25,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \nclass Student {\n    private String name;\n    private int age;\n \n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n \n    public String toString() {\n        return \"Student[\" + name + \", \" + age + \"]\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>();\n        students.add(new Student(\"James\", 25));\n        students.add(new Student(\"James\", 27));\n        students.add(new Student(\"James\", 25));\n        students.add(new Student(\"James\", 25));\n \n        students.remove(new Student(\"James\", 25));\n \n        for(Student stud : students) {\n            System.out.println(stud);\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "Prints 3 students" },
      { "id": "B", "text": "Prints 4 students" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["B"],
    "explanation": "Before you answer this, you must know that there are 5 different Student object created in the memory (4 at the time of adding to the list and 1 at the time of removing from the list).\nThis means these 5 Student objects will be stored at different memory addresses.\nremove(Object) method removes the first occurrence of matching object and equals(Object) method decides whether 2 objects are equal or not.\nequals(Object) method defined in Object class uses == operator to check the equality and in this case as 5 Student objects are stored at different memory location, hence not equal.\nNothing is removed from the students list, all the 4 Student objects are printed in the insertion order."
  },
  {
    "id": 26,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int [] arr = {2, 1, 0};\n        for(int i : arr) {\n            System.out.println(arr[i]);\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "2 1 0" },
      { "id": "B", "text": "0 1 2" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "ArrayIndexOutOfBoundsException" }
    ],
    "correctAnswers": ["B"],
    "explanation": "Inside enhanced for loop, System.out.println(arr[i]); is used instead of System.out.println(i);\nWhen loop executes 1st time, i stores the first array element, which is 2 but System.out.println statement prints arr[2] which is 0. Loop executes in this manner and prints 0 1 2 on to the console."
  },
  {
    "id": 27,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nimport java.time.LocalTime;\n \npublic class Test {\n    public static void main(String[] args) {\n        LocalTime time = LocalTime.of(16, 40);\n        String amPm = time.getHour() >= 12 ? (time.getHour() == 12) ? \"PM\" : \"AM\";\n        System.out.println(amPm);\n    }\n}",
    "options": [
      { "id": "A", "text": "PM" },
      { "id": "B", "text": "AM" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["C"],
    "explanation": "This question is on ternary operator (?:). If an expression has multiple ternary operators then number of ?\nand : should match.\nGiven expression contains 2 ? and 1 : and hence Compilation Error."
  },
  {
    "id": 28,
    "type": "multiple",
    "questionText": "For the given code snippet:\nWhich of the following options, if used to replace /*INSERT*/, compiles successfully?\nSelect 2 options.",
    "codeSnippet": "List<String> list = new /*INSERT*/();",
    "options": [
      { "id": "A", "text": "ArrayList<String>" },
      { "id": "B", "text": "ArrayList<>" },
      { "id": "C", "text": "List<String>" },
      { "id": "D", "text": "List<>" }
    ],
    "correctAnswers": ["A", "B"],
    "explanation": "List is an interface so its instance can't be created using new keyword. List<String> and List<> will cause compilation failure.\nArrayList implements List interface, so it can be it can be used to replace /*INSERT*/. List<String> list = new ArrayList<String>();\ncompiles successfully.\nStarting with JDK 7, Java allows to not specify type while initializing the ArrayList.\nType is inferred from the left side of the statement.\nSo List<String> list = new ArrayList<>(); is a valid syntax starting with JDK 7."
  },
  {
    "id": 29,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Output is: \" + 10 != 5);\n    }\n}",
    "options": [
      { "id": "A", "text": "Output is: true" },
      { "id": "B", "text": "Output is: false" },
      { "id": "C", "text": "Output is: 10 != 5" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["D"],
    "explanation": "Binary plus (+) has got higher precedence than != operator. Let us group the expression.\n\"Output is: \" + 10 != 5\n= (\"Output is: \" + 10) != 5\n[!= is binary operator, so we have to evaluate the left side first. + operator behaves as concatenation operator.]\n= \"Output is: 10\" != 5\nLeft side of above expression is String, and right side is int.\nBut String can't be compared to int, hence compilation error."
  },
  {
    "id": 30,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nclass SpecialString {\n    String str;\n    SpecialString(String str) {\n        this.str = str;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Object [] arr = new Object[4];\n        for(int i = 1; i <=3; i++) {\n            switch(i) {\n                case 1:\n                    arr[i] = new String(\"Java\");\n                    break;\n                case 2:\n                    arr[i] = new StringBuilder(\"Java\");\n                    break;\n                case 3:\n                    arr[i] = new SpecialString(\"Java\");\n                    break;\n            }\n        }\n        for(Object obj : arr) {\n            System.out.println(obj);\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "null\nJava\nJava\nJava" },
      { "id": "B", "text": "null\nJava\nJava\n<Some text containing @ symbol>" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["B"],
    "explanation": "Variable 'arr' refers to an Object array of size 4 and null is assigned to all 4 elements of this array.\nfor-loop starts with i = 1, which means at 1st index String instance is stored, at 2nd index StringBuiler instance is stored and at 3rd index SpecialString instance is stored.\nnull is stored at 0th index.\nSo, first null will be printed on to the console.\nString and StringBuilder classes override toString() method, which prints the text stored in these classes.\nSpecialString class doesn't override toString() method and hence when instance of SpecialString is printed on to the console, you get: <fully qualified name of SpecialString class>@<hexadecimal representation of hashcode>.\nTherefore output will be:\nnull\nJava\nJava\n<Some text containing @ symbol>"
  },
  {
    "id": 31,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate newYear = LocalDate.of(2018, 1, 1);\n        LocalDate christmas = LocalDate.of(2018, 12, 25);\n        boolean flag1 = newYear.isAfter(christmas);\n        boolean flag2 = newYear.isBefore(christmas);\n        System.out.println(flag1 + \":\" + flag2);\n    }\n}",
    "options": [
      { "id": "A", "text": "true:false" },
      { "id": "B", "text": "false:true" },
      { "id": "C", "text": "true:true" },
      { "id": "D", "text": "false:false" }
    ],
    "correctAnswers": ["B"],
    "explanation": "isAfter and isBefore method can be interpreted as:\nDoes 1st Jan 2018 come after 25th Dec 2018? No, false.\nDoes 1st Jan 2018 come before 25th Dec 2018? Yes, true."
  },
  {
    "id": 32,
    "type": "single",
    "questionText": "Given code:\nAnd below options:\n1. int n = 0; n < arr.length; n += 1\n2. int n = 0; n <= arr.length; n += 1\n3. int n = 1; n < arr.length; n += 2\n4. int n = 1; n <= arr.length; n += 2\nHow many above options can be used to replace /*INSERT*/, such that on execution, code will print NET on to the console?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"I\", \"N\", \"S\", \"E\", \"R\", \"T\"};\n        for(/*INSERT*/) {\n            if (n % 2 == 0) {\n                continue;\n            }\n            System.out.print(arr[n]); //Line n1\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "1" },
      { "id": "B", "text": "2" },
      { "id": "C", "text": "3" },
      { "id": "D", "text": "4" }
    ],
    "correctAnswers": ["D"],
    "explanation": "From the given array, if you print the elements at 1st, 3rd and 5th indexes, then you will get expected output.\nAlso note that, for values of n = 0, 2, 4, 6;\nLine n1 would not be executed, which means even if the value of n is 6, above code will not throw ArrayIndexOutOfBoundsException.\nFor 1st option [int n = 0; n < arr.length;\nn += 1], values of n used: 0, 1, 2, 3, 4, 5 and because of continue;\nstatement, Line n1 will not execute for 0, 2 & 4 and it will execute only for 1, 3 & 5 and therefore NET will be printed.\nFor 2nd option [int n = 0; n <= arr.length;\nn += 1], values of n used: 0, 1, 2, 3, 4, 5, 6 and because of continue;\nstatement, Line n1 will not execute for 0, 2, 4 & 6 and it will execute only for 1, 3 & 5 and therefore NET will be printed.\nFor 3rd option [int n = 1; n < arr.length;\nn += 2], values of n used: 1, 3, 5 and therefore NET will be printed.\nFor 4th option [int n = 1; n <= arr.length;\nn += 2], values of n used: 1, 3, 5 and therefore NET will be printed.\nHence, all the 4 options are valid."
  },
  {
    "id": 33,
    "type": "single",
    "questionText": "Which of the following correctly defines class Printer?",
    "codeSnippet": "",
    "options": [
      { "id": "A", "text": "package ...; import ...; class Printer {}" },
      { "id": "B", "text": "import ...; package ...; class Printer {}" },
      { "id": "C", "text": "class Printer {} package ...;" },
      { "id": "D", "text": "import ...; class Printer {}" }
    ],
    "correctAnswers": ["A"],
    "explanation": "If package is used then it should be the first statement, but javadoc and developer comments are not considered as java statements so a class can have developer and javadoc comments before the package statement.\nIf import and package both are available, then correct order is package, import, class declaration."
  },
  {
    "id": 34,
    "type": "single",
    "questionText": "Which of the following is not a valid array declaration?",
    "codeSnippet": "",
    "options": [
      { "id": "A", "text": "int[][] arr = new int[2][2];" },
      { "id": "B", "text": "int[] arr = new int[10];" },
      { "id": "C", "text": "int[][] arr = new int[][8];" },
      { "id": "D", "text": "int[] arr = {1, 2, 3};" }
    ],
    "correctAnswers": ["C"],
    "explanation": "1st array dimension must be specified at the time of declaration. new int[][8];\ngives compilation error as 1st dimension is not specified."
  },
  {
    "id": 35,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int x = 1;\n        while(checkAndIncrement(x)) {\n            System.out.println(x);\n        }\n    }\n \n    private static boolean checkAndIncrement(int x) {\n        if(x < 5) {\n            x++;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "Prints 1 2 3 4" },
      { "id": "B", "text": "Infinite loop printing 1" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["B"],
    "explanation": "x of checkAndIncrement method contains the copy of variable x defined in main method.\nSo, changes done to x in checkAndIncrement method are not reflected in the variable x of main.\nx of main remains 1 as code inside main is not changing its value.\nEvery time checkAndIncrement method is invoked with argument value 1, so true is returned always and hence while loop executes indefinitely."
  },
  {
    "id": 36,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nclass Student {\n    String name;\n    int marks;\n \n    Student(String name, int marks) {\n        this.name = name;\n        this.marks = marks;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Student student = new Student(\"James\", 25);\n        int marks = 25;\n        review(student, marks);\n        System.out.println(marks + \"-\" + student.marks);\n    }\n \n    private static void review(Student stud, int marks) {\n        marks = marks + 10;\n        stud.marks+=marks;\n    }\n}",
    "options": [
      { "id": "A", "text": "25-25" },
      { "id": "B", "text": "25-60" },
      { "id": "C", "text": "35-60" },
      { "id": "D", "text": "35-35" }
    ],
    "correctAnswers": ["B"],
    "explanation": "In below statements: student<main> means student inside main method.\nOn execution of main method: student<main> --> {\"James\", 25}, marks<main> = 25.\nOn execution of review method: stud<review> --> {\"James\", 25} (same object referred by student<main>), marks<review> = 25 (this marks is different from the marks defined in main method).\nmarks<review> = 35 and stud.marks = 60. So at the end of review method: stud<review> --> {\"James\", 60}, marks<review> = 35.\nControl goes back to main method: student<main> --> {\"James\", 60}, marks<main> = 25. Changes done to reference variable are visible in main method but changes done to primitive variable are not reflected in main method."
  },
  {
    "id": 37,
    "type": "single",
    "questionText": "Consider the following class:\nWhich of the following is the correct way to make the variable 'passportNo' read only for any other class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Employee {\n    public int passportNo; //line 2\n}",
    "options": [
      { "id": "A", "text": "Make it private and provide public setter" },
      { "id": "B", "text": "Make it private and provide public getter" },
      { "id": "C", "text": "Make it protected" },
      { "id": "D", "text": "Keep it public" }
    ],
    "correctAnswers": ["B"],
    "explanation": "'passportNo' should be read-only for any other class.\nThis means make 'passportNo' private and provide public getter method.\nDon't provide public setter as then 'passportNo' will be read-write property.\nIf passportNo is declared with default scope, then other classes in the same package will be able to access passportNo for read-write operation."
  },
  {
    "id": 38,
    "type": "single",
    "questionText": "Which of these access modifiers can be used for a top level interface?",
    "codeSnippet": "",
    "options": [
      { "id": "A", "text": "private" },
      { "id": "B", "text": "protected" },
      { "id": "C", "text": "public" },
      { "id": "D", "text": "final" },
      { "id": "E", "text": "default" }
    ],
    "correctAnswers": ["C", "E"],
    "explanation": "A top level interface can be declared with either public or default modifiers.\npublic interface is accessible across all packages but interface declared with default modifier and be accessed in the defining package only."
  },
  {
    "id": 39,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n \nabstract class Super {\n    public abstract void m1() throws IOException;\n}\n \nclass Sub extends Super {\n    @Override\n    public void m1() throws IOException {\n        throw new FileNotFoundException();\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Super s = new Sub();\n        try {\n            s.m1();\n        } catch (FileNotFoundException e) {\n            System.out.print(\"M\");\n        } finally {\n            System.out.print(\"N\");\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "Prints M" },
      { "id": "B", "text": "Prints N" },
      { "id": "C", "text": "Prints MN" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["D"],
    "explanation": "Even though an instance of FileNotFoundException is thrown by method m1() at runtime, but method m1() declares to throw IOException.\nReference variable s is of Super type and hence for compiler, call to s.m1();\nis to method m1() of Super, which throws IOException.\nAnd as IOException is checked exception hence calling code should handle it.\nAs calling code doesn't handle IOException or its super type, so s.m1(); gives compilation error."
  },
  {
    "id": 40,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        double [] arr = new int[2]; //Line 3\n        System.out.println(arr[0]); //Line 4\n    }\n}",
    "options": [
      { "id": "A", "text": "0.0" },
      { "id": "B", "text": "0" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["C"],
    "explanation": "int variable can easily be assigned to double type but double [] and int [] are not compatible.\nIn fact, both are siblings and can't be assigned to each other, so Line 3 causes compilation failure."
  },
  {
    "id": 41,
    "type": "multiple",
    "questionText": "For the class Test, which options, if used to replace /*INSERT*/, will print \"Lucky no. 7\" on to the console?\nSelect 3 options.",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        /*INSERT*/\n        switch(var) {\n            case 7:\n                System.out.println(\"Lucky no. 7\");\n                break;\n            default:\n                System.out.println(\"DEFAULT\");\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "int var = 7;" },
      { "id": "B", "text": "Integer var = 7;" },
      { "id": "C", "text": "char var = '7';" },
      { "id": "D", "text": "byte var = 7;" }
    ],
    "correctAnswers": ["A", "B", "D"],
    "explanation": "switch can accept primitive types: byte, short, int, char;\nwrapper types: Byte, Short, Integer, Character; String and enums.\nIn this case, all are valid values but only 3 executes \"case 7:\". case is comparing integer value 7.\nNOTE: character seven, '7' is different from integer value seven, 7. So \"char var = '7';\"\nand \"Character var = '7';\" will print DEFAULT on to the console."
  },
  {
    "id": 42,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nimport java.util.function.Predicate;\n \npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"A\", \"ab\", \"bab\", \"Aa\", \"bb\", \"baba\", \"aba\", \"Abab\"};\n \n        Predicate<String> p = s -> s.toUpperCase().substring(0,1).equals(\"A\");\n \n        processStringArray(arr, p);\n    }\n \n    private static void processStringArray(String [] arr,\n                                           Predicate<String> predicate) {\n        for(String str : arr) {\n            if(predicate.test(str)) {\n                System.out.println(str);\n            }\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "3" },
      { "id": "B", "text": "4" },
      { "id": "C", "text": "5" },
      { "id": "D", "text": "6" }
    ],
    "correctAnswers": ["C"],
    "explanation": "Let us suppose test string is \"aba\".\nLambda expression s.toUpperCase().substring(0,1).equals(\"A\"); means: \"aba\".toUpperCase().substring(0,1).equals(\"A\"); => \"ABA\".substring(0,1).equals(\"A\"); => \"A\".equals(\"A\"); => true.\nThis lambda expression returns true for any string starting with a (in lower or upper case).\nBased on the lambda expression, 5 array elements passes the Predicate's test and are printed on to the console."
  },
  {
    "id": 43,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String fruit = \"mango\";\n        switch (fruit) {\n            default:\n                System.out.println(\"ANY FRUIT WILL DO\");\n            case \"Apple\":\n                System.out.println(\"APPLE\");\n            case \"Mango\":\n                System.out.println(\"MANGO\");\n            case \"Banana\":\n                System.out.println(\"BANANA\");\n                break;\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "ANY FRUIT" },
      { "id": "B", "text": "ANY FRUIT APPLE MANGO BANANA" },
      { "id": "C", "text": "ANY FRUIT then error" },
      { "id": "D", "text": "Nothing printed" }
    ],
    "correctAnswers": ["B"],
    "explanation": "\"mango\" is different from \"Mango\", so there is no matching case available.\ndefault block is executed, \"ANY FRUIT WILL DO\" is printed on to the screen.\nNo break statement inside default, hence control enters in fall-through and executes remaining blocks until the break;\nis found or switch block ends.\nSo in this case, it prints APPLE, MANGO, BANANA one after another and break;\nstatement takes control out of switch block. main method ends and program terminates successfully."
  },
  {
    "id": 44,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> dryFruits = new ArrayList<>();\n        dryFruits.add(\"Walnut\");\n        dryFruits.add(\"Apricot\");\n        dryFruits.add(\"Almond\");\n        dryFruits.add(\"Date\");\n \n        Iterator<String> iterator = dryFruits.iterator();\n        while(iterator.hasNext()) {\n            String dryFruit = iterator.next();\n            if(dryFruit.startsWith(\"A\")) {\n                dryFruits.remove(dryFruit);\n            }\n        }\n \n        System.out.println(dryFruits);\n    }\n}",
    "options": [
      { "id": "A", "text": "Removes Apricot and Almond" },
      { "id": "B", "text": "ConcurrentModificationException" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Removes nothing" }
    ],
    "correctAnswers": ["B"],
    "explanation": "ConcurrentModificationException exception may be thrown for following condition:\n1. Collection is being iterated using Iterator/ListIterator or by using for-each loop.\nAnd\n2. Execution of Iterator.next(), Iterator.remove(), ListIterator.previous(), ListIterator.set(E) & ListIterator.add(E) methods.\nThese methods may throw java.util.ConcurrentModificationException in case Collection had been modified by means other than the iterator itself, such as Collection.add(E) or Collection.remove(Object) or List.remove(int) etc.\nFor the given code, 'dryFruits' list is being iterated using the Iterator<String>.\nhasNext() method of Iterator has following implementation:\npublic boolean hasNext() {\nreturn cursor != size;\n}\nWhere cursor is the index of next element to return and initially it is 0.\n1st Iteration: cursor = 0, size = 4, hasNext() returns true. iterator.next() increments the cursor by 1 and returns \"Walnut\".\n2nd Iteration: cursor = 1, size = 4, hasNext() returns true. iterator.next() increments the cursor by 1 and returns \"Apricot\".\nAs \"Apricot\" starts with \"A\", hence dryFruits.remove(dryFruit) removes \"Apricot\" from the list and hence reducing the list's size by 1, size becomes 3.\n3rd Iteration: cursor = 2, size = 3, hasNext() returns true. iterator.next() method throws java.util.ConcurrentModificationException.\nIf you want to remove the items from ArrayList, while using Iterator or ListIterator, then use Iterator.remove() or ListIterator.remove() method and NOT List.remove(...) method.\nUsing List.remove(...) method while iterating the list (using the Iterator/ListIterator or for-each) may throw java.util.ConcurrentModificationException."
  },
  {
    "id": 45,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(100);\n        list.add(200);\n        list.add(100);\n        list.add(200);\n        list.remove(100);\n \n        System.out.println(list);\n    }\n}",
    "options": [
      { "id": "A", "text": "Removes element 100" },
      { "id": "B", "text": "IndexOutOfBoundsException" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Removes element at index 0" }
    ],
    "correctAnswers": ["B"],
    "explanation": "List cannot accept primitives, it can accept objects only. So, when 100 and 200 are added to the list, then auto-boxing feature converts these to wrapper objects of Integer type.\nSo, 4 items gets added to the list. One can expect the same behavior with remove method as well that 100 will be auto-boxed to Integer object.\nBut remove method is overloaded in List interface: remove(int) => Removes the element from the specified position in this list\nand remove(Object)  => Removes the first occurrence of the specified element from the list.\nAs remove(int) version is available, which perfectly matches with the call remove(100);\nhence compiler does not do auto-boxing in this case.\nBut at runtime remove(100) tries to remove the element at 100th index and this throws IndexOutOfBoundsException."
  },
  {
    "id": 46,
    "type": "multiple",
    "questionText": "For the class Test, which options, if used to replace /*INSERT*/, will print \"Hurrah! I passed...\" on to the console?\nSelect 2 options.",
    "codeSnippet": "public class Test {\n    /*INSERT*/ {\n        System.out.println(\"Hurrah! I passed...\");\n    }\n}",
    "options": [
      { "id": "A", "text": "public static void main(String[] args)" },
      { "id": "B", "text": "static public void main(String[] args)" },
      { "id": "C", "text": "public void main(String[] args)" },
      { "id": "D", "text": "static void main(String args)" }
    ],
    "correctAnswers": ["A", "B"],
    "explanation": "As System.out.println needs to be executed on executing the Test class, this means special main method should replace /*INSERT*/.\nSpecial main method's name should be \"main\" (all characters in lower case), should be static, should have public access specifier and it accepts argument of String [] type.\nString [] argument can use any identifier name, even though in most of the cases you will see \"args\" is used.\nPosition of static and public can be changed but return type must come just before the method name."
  },
  {
    "id": 47,
    "type": "single",
    "questionText": "Consider below code:\nAnd the commands:javac Guest.java\njava Guest Clare Waight Keller\nWhat is the result?",
    "codeSnippet": "//Guest.java\nclass Message {\n    static void main(String [] args) {\n        System.out.println(\"Welcome \" + args[2] + \"!\");\n    }\n}\n \npublic class Guest {\n    public static void main(String [] args) {\n        Message.main(args);\n    }\n}",
    "options": [
      { "id": "A", "text": "Welcome Clare!" },
      { "id": "B", "text": "Welcome Waight!" },
      { "id": "C", "text": "Welcome Keller!" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["C"],
    "explanation": "Class Guest has special main method but main method defined in Message class is not public and hence it can't be called by JVM.\nBut there is no issue with the syntax hence no compilation error.\njava Guest Clare Waight Keller passes new String [] {\"Clare\", \"Waight\", \"Keller\"} to args of Guest.main method.\nGuest.main method invokes Message.main method with the same argument: new String [] {\"Clare\", \"Waight\", \"Keller\"}.\nargs[2] is \"Keller\" hence \"Welcome Keller!\" gets printed on to the console."
  },
  {
    "id": 48,
    "type": "single",
    "questionText": "Given the code of Test.java file:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nclass Point {\n    int x;\n    int y;\n    void assign(int x, int y) {\n        x = this.x;\n        this.y = y;\n    }\n \n    public String toString() {\n        return \"Point(\" + x + \", \" + y + \")\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Point p1 = new Point();\n        p1.x = 10;\n        p1.y = 20;\n        Point p2 = new Point();\n        p2.assign(p1.x, p1.y);\n        System.out.println(p1.toString() + \";\" + p2.toString());\n    }\n}",
    "options": [
      { "id": "A", "text": "Point(10, 20);Point(10, 20)" },
      { "id": "B", "text": "Point(10, 20);Point(0, 20)" },
      { "id": "C", "text": "Point(10, 20);Point(0, 0)" },
      { "id": "D", "text": "Point(0, 0);Point(0, 20)" }
    ],
    "correctAnswers": ["B"],
    "explanation": "HINT: First check if members are accessible or not. All the codes are in same file Test.java, and Point class & variable x, y are declared with default modifier hence these can be accessed within the same package.\nClass Test belongs to same package so no issues in accessing Point class and instance variables of Point class.\nMake use of pen and paper to draw the memory diagrams (heap and stack).\nIt will be pretty quick to reach the result.\nPoint p1 = new Point(); means p1.x = 0 and p1.y = 0 as instance variable are initialized to respective zeros.\np1.x = 10; means replace 0 with 10 in p1.x,\np1.y = 20; means replace 0 with 20 in p1.y,\nPoint p2 = new Point(); means p2.x = 0 and p2.y = 0 as instance variable are initialized to respective zeros.\np2.assign(p1.x, p1.y); invokes the assign method, parameter variable x = 10 and y = 20.\nAs assign is invoked on p2 reference variable hence this and p2 refers to same Point object.\nx = this.x; means assign 0 to parameter variable x, no changes in this.y, which means p2.x is unchanged.\nthis.y = y; means assign 20 to this.y, which means p2.y is now 20\nSo after assign method is invoked and control goes back to main method: p1.x = 10, p1.y = 20, p2.x = 0 and p2.y = 20.\nOutput is: Point(10, 20);Point(0, 20)"
  },
  {
    "id": 49,
    "type": "single",
    "questionText": "Given code:\nAnd below statements:\n1. short arr [] = new short[2];\n2. byte [] arr = new byte[10];\n3. short [] arr; arr = new short[3];\n4. short [2] arr;\n5. short [3] arr;\n6. int [] arr = new int[]{100, 100};\n7. int [] arr = new int[]{0, 0, 0, 0};\n8. short [] arr = {};\n9. short [] arr = new short[2]{5, 10};\nHow many above statements can be used to replace /*INSERT*/, such that on execution, code will print [5, 10] on to the console?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        /*INSERT*/\n        arr[1] = 5;\n        arr[2] = 10;\n        System.out.println(\"[\" + arr[1] + \", \" + arr[2] + \"]\"); //Line n1\n    }\n}",
    "options": [
      { "id": "A", "text": "2" },
      { "id": "B", "text": "3" },
      { "id": "C", "text": "4" },
      { "id": "D", "text": "5" }
    ],
    "correctAnswers": ["B"],
    "explanation": "Let's check all the statements one by one:\n1. short arr [] = new short[2]; =>  \u2717\nYou can declare one-dimensional array by using either \"short arr []\" or \"short [] arr\".\n'arr' refers to a short array object of 2 elements. arr[2] will throw ArrayIndexOutOfBoundsException at runtime.\n2. byte [] arr = new byte[10]; =>  \u2713\n'arr' refers to a byte array object of 10 elements, where 0 is assigned to each array element.\nBut later on element at 1st and 2nd indexes have been re-initialized.\nLine n1 successfully prints [5, 10] on to the console.\n3. short [] arr; arr = new short[3]; =>  \u2713\nYou can create an array object in the same statement or next statement.\n'arr' refers to a short array object of 3 elements, where 0 is assigned to each array element.\nLater on element at 1st and 2nd indexes have been re-initialized.\nLine n1 successfully prints [5, 10] on to the console.\n4. short [2] arr;  \u2717\nArray size cannot be specified at the time of declaration, so short [2] arr; causes compilation error.\n5. short [3] arr;  \u2717\nArray size cannot be specified at the time of declaration, so short [3] arr; causes compilation error.\n6. int [] arr = new int[]{100, 100}; =>  \u2717\n'arr' refers to an int array object of size 2 and both array elements have value 100. arr[2] will throw ArrayIndexOutOfBoundsException at runtime.\n7. int [] arr = new int[]{0, 0, 0, 0}; =>  \u2713\n'arr' refers to an int array object of size 4 and all array elements have value 0. Later on element at 1st and 2nd indexes have been re-initialized.\nLine n1 successfully prints [5, 10] on to the console.\n8. short [] arr = {}; =>  \u2717\n'arr' refers to a short array object of 0 size. so arr[1] will throw ArrayIndexOutOfBoundsException at runtime.\n9. short [] arr = new short[2]{5, 10}; =>  \u2717\nArray's size can't be specified, if you use {} to assign values to array elements.\nHence, out of the given 9 statements, only 3 will print [5, 10] on to the console."
  },
  {
    "id": 50,
    "type": "single",
    "questionText": "Consider code below:\nCurrently above code causes compilation error.\nWhich of the options can successfully print 128:TYPE-C on to the console?",
    "codeSnippet": "package com.udayan.oca;\n \nclass PenDrive {\n    int capacity;\n    PenDrive(int capacity) {\n        this.capacity = capacity;\n    }\n}\n \nclass OTG extends PenDrive {\n    String type;\n    String make;\n    OTG(int capacity, String type) {\n        /*INSERT-1*/\n    }\n    OTG(String make) {\n        /*INSERT-2*/\n        this.make = make;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        OTG obj = new OTG(128, \"TYPE-C\");\n        System.out.println(obj.capacity + \":\" + obj.type);\n    }\n}",
    "options": [
      { "id": "A", "text": "super(capacity); this.type = type;" },
      { "id": "B", "text": "this.capacity = capacity; this.type = type;" },
      { "id": "C", "text": "super(); this.type = type;" },
      { "id": "D", "text": "type = type; super(capacity);" }
    ],
    "correctAnswers": ["A"],
    "explanation": "Java compiler adds super(); as the first statement inside constructor, if call to another constructor using this(...) or super(...) is not available.\nCompiler adds super(); as the first line in OTG's constructor: OTG(int capacity, String type) { super();\n} but PenDrive class doesn't have a no-arg constructor and that is why OTG's constructor causes compilation error.\nFor the same reason, OTG(String make) constructor also causes compilation error.\nTo correct these compilation errors, parent class constructor should be invoked by using super(int); This would resolve compilation error.\nRemember: Constructor call using this(...) or super(...) must be the first statement inside the constructor.\nIn the main(String[]) method, OTG(int, String) constructor is invoked, which means, we OTG(String) constructor will not be executed.\nSo, to solve the complilation error in OTG(String) constructor, super(0); or super(128);\nboth will work and these will not affect the expected output.\nWe have to make changes in OTG(int, String) constructor such that on execution, output is 128:TYPE-C.\nsuper(capacity); will only assign value to capacity property, to assign value to type another statement is needed.\nthis.type = type; must be the 2nd statement.\nSo, /*INSERT-1*/ must be replaced with:\nsuper(capacity);\nthis.type = type;"
  },
  {
    "id": 51,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"Java\");\n        String s1 = sb.toString();\n        String s2 = sb.toString();\n \n        System.out.println(s1 == s2);\n    }\n}",
    "options": [
      { "id": "A", "text": "true" },
      { "id": "B", "text": "false" },
      { "id": "C", "text": "NullPointerException" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["B"],
    "explanation": "toString() method defined in StringBuilder class doesn't use String literal rather uses the constructor of String class to create the instance of String class.\nSo both s1 and s2 refer to different String instances even though their contents are same.\ns1 == s2 returns false."
  },
  {
    "id": 52,
    "type": "single",
    "questionText": "What will be the result of compiling and executing the Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int grade = 60;\n        if(grade = 60)\n            System.out.println(\"You passed...\");\n        else\n            System.out.println(\"You failed...\");\n    }\n}",
    "options": [
      { "id": "A", "text": "You passed..." },
      { "id": "B", "text": "You failed..." },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["C"],
    "explanation": "Following are allowed in boolean expression of if statement:\n1. Any expression whose result is either true or false. e.g. age > 20\n2. A boolean variable. e.g. flag\n3. A boolean literal: true or false\n4. A boolean assignment. e.g. flag = true\nboolean expression in this case is: (grade = 60), which is an int assignment and not boolean assignment.\nHence Compilation error."
  },
  {
    "id": 53,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    char var1;\n    double var2;\n    float var3;\n \n    public static void main(String[] args) {\n        Test obj = new Test();\n        System.out.println(\">\" + obj.var1);\n        System.out.println(\">\" + obj.var2);\n        System.out.println(\">\" + obj.var3);\n    }\n}",
    "options": [
      { "id": "A", "text": "Default values for char, double, float" },
      { "id": "B", "text": "Compilation error" },
      { "id": "C", "text": "NullPointerException" },
      { "id": "D", "text": "Garbage values" }
    ],
    "correctAnswers": ["A"],
    "explanation": "Primitive type instance variables are initialized to respective zeros (byte: 0, short: 0, int: 0, long: 0L, float: 0.0f, double: 0.0, boolean: false, char: \\u0000).\nWhen printed on the console; byte, short, int & long prints 0, float & double print 0.0, boolean prints false and char prints nothing or non-printable character (whitespace).\nReference type instance variables are initialized to null."
  },
  {
    "id": 54,
    "type": "multiple",
    "questionText": "Consider below code:\nWhich of the following lambda expressions, if used to replace /*INSERT*/, prints [Jack, Liya] on to the console?\nSelect 2 options.",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.function.Predicate;\n \nclass Employee {\n    private String name;\n    private int age;\n    private double salary;\n \n    public Employee(String name, int age, double salary) {\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public int getAge() {\n        return age;\n    }\n \n    public double getSalary() {\n        return salary;\n    }\n \n    public String toString() {\n        return name;\n    }\n}\n \npublic class Test {\n    public static void main(String [] args) {\n        List<Employee> list = new ArrayList<>();\n        list.add(new Employee(\"James\", 25, 15000));\n        list.add(new Employee(\"Lucy\", 23, 12000));\n        list.add(new Employee(\"Bill\", 27, 10000));\n        list.add(new Employee(\"Jack\", 19, 5000));\n        list.add(new Employee(\"Liya\", 20, 8000));\n \n        process(list, /*INSERT*/);\n \n        System.out.println(list);\n    }\n \n    private static void process(List<Employee> list, Predicate<Employee> predicate) {\n        Iterator<Employee> iterator = list.iterator();\n        while(iterator.hasNext()) {\n            if(predicate.test(iterator.next()))\n            iterator.remove();\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "e -> e.getSalary() >= 10000" },
      { "id": "B", "text": "(Employee e) -> { return e.getSalary() >= 10000; }" },
      { "id": "C", "text": "e -> { e.getSalary() >= 10000; }" },
      { "id": "D", "text": "(e) -> e.getSalary() >= 10000" }
    ],
    "correctAnswers": ["A", "B"],
    "explanation": "Jack's salary is 5000 and Liya's salary is 8000. If Employee's salary is >= 10000 then that Employee object is removed from the list.\nAllowed lambda expression is:\n(Employee e) -> { return e.getSalary() >= 10000; },\nCan be simplified to:  (e) -> { return e.getSalary() >= 10000;\n} => type can be removed from left side of the expression.\nFurther simplified to: e -> { return e.getSalary() >= 10000;\n} => if there is only one parameter in left part, then round brackets (parenthesis) can be removed.\nFurther simplified to: e -> e.getSalary() >= 10000 => if there is only one statement in the right side then semicolon inside the body, curly brackets and return statement can be removed.\nBut all 3 [return, {}, ;] must be removed together.\nNOTE: there should not be any space between - and > of arrow operator."
  },
  {
    "id": 55,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"java\";\n        StringBuilder sb = new StringBuilder(\"java\");\n \n        System.out.println(str.equals(sb) + \":\" + sb.equals(str));\n    }\n}",
    "options": [
      { "id": "A", "text": "true:true" },
      { "id": "B", "text": "false:false" },
      { "id": "C", "text": "true:false" },
      { "id": "D", "text": "false:true" }
    ],
    "correctAnswers": ["B"],
    "explanation": "equals method declared in Object class has the declaration: public boolean equals(Object).\nGenerally, equals method is used to compare different instances of same class but if you pass any other object, there is no compilation error.\nParameter type is Object so it can accept any Java object.\nstr.equals(sb) => String class overrides equals(Object) method but as \"sb\" is of StringBuilder type so this returns false.\nStringBuilder class doesn't override equals(Object) method. So Object version is invoked which uses == operator, hence sb.equals(str) returns false as well.\nfalse:false is printed on to the console."
  },
  {
    "id": 56,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        System.out.println(sb.append(null).length());\n    }\n}",
    "options": [
      { "id": "A", "text": "4" },
      { "id": "B", "text": "0" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "NullPointerException" }
    ],
    "correctAnswers": ["C"],
    "explanation": "'append' method is overloaded in StringBuilder class: append(String), append(StringBuffer) and append(char[]) etc.\nIn this case compiler gets confused as to which method `append(null)` can be tagged because String, StringBuffer and char[] are not related to each other in multilevel inheritance.\nHence `sb.append(null)` causes compilation error."
  },
  {
    "id": 57,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        short [] args = new short[]{50, 50};\n        args[0] = 5;\n        args[1] = 10;\n        System.out.println(\"[\" + args[0] + \", \" + args[1] + \"]\");\n    }\n}",
    "options": [
      { "id": "A", "text": "[5, 10]" },
      { "id": "B", "text": "[50, 50]" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["C"],
    "explanation": "main method's parameter variable name is \"args\" and it is a local to main method.\nSo, same name \"args\" can't be used directly within the curly brackets of main method.\nshort [] args = new short[]{50, 50}; gives compilation error for using same name for local variable."
  },
  {
    "id": 58,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        double price = 90000;\n        String model;\n        if(price > 100000) {\n            model = \"Tesla Model X\";\n        } else if(price <= 100000) {\n            model = \"Tesla Model S\";\n        }\n        System.out.println(model);\n    }\n}",
    "options": [
      { "id": "A", "text": "Tesla Model S" },
      { "id": "B", "text": "Tesla Model X" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "null" }
    ],
    "correctAnswers": ["C"],
    "explanation": "In this case \"if - else if\" block is used and not \"if - else\" block.\n90000 is assigned to variable 'price' but you can assign parameter value or call some method returning double value, such as:\n'double price = currentTemp();'.\nIn these cases compiler will not know the exact value until runtime, hence Java Compiler is not sure which boolean expression will be evaluated to true and so variable model may not be initialized.\nUsage of LOCAL variable, 'model' without initialization gives compilation error. Hence, System.out.println(model); gives compilation error."
  },
  {
    "id": 59,
    "type": "single",
    "questionText": "Consider code of Test.java file:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Character> list = new ArrayList<>();\n        list.add(0, 'V');\n        list.add('T');\n        list.add(1, 'E');\n        list.add(3, 'O');\n \n        if(list.contains('O')) {\n            list.remove('O');\n        }\n \n        for(char ch : list) {\n            System.out.print(ch);\n        }\n    }\n}",
    "options": [
      { "id": "A", "text": "VETO" },
      { "id": "B", "text": "VET" },
      { "id": "C", "text": "Runtime Exception" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["C"],
    "explanation": "list.add(0, 'V'); => char 'V' is converted to Character object and stored as the first element in the list.\nlist --> [V].\nlist.add('T'); => char 'T' is auto-boxed to Character object and stored at the end of the list. list --> [V,T].\nlist.add(1, 'E'); => char 'E' is auto-boxed to Character object and inserted at index 1 of the list, this shifts T to the right.\nlist --> [V,E,T].\nlist.add(3, 'O'); => char 'O' is auto-boxed to Character object and added at index 3 of the list.\nlist --> [V,E,T,O].\nlist.contains('O') => char 'O' is auto-boxed to Character object and as Character class overrides equals(String) method this expression returns true.\nControl goes inside if-block and executes: list.remove('O');.\nremove method is overloaded: remove(int) and remove(Object). char can be easily assigned to int so compiler tags remove(int) method.\nlist.remove(<ASCCI value of 'O'>); ASCCI value of 'A' is 65 (this everybody knows) so ASCII value of 'O' will be more than 65.\nlist.remove('O') throws runtime exception, as it tries to remove an item from the index greater than 65 but allowed index is 0 to 3 only."
  },
  {
    "id": 60,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int a = 100;\n        System.out.println(-a++);\n    }\n}",
    "options": [
      { "id": "A", "text": "100" },
      { "id": "B", "text": "-100" },
      { "id": "C", "text": "101" },
      { "id": "D", "text": "-101" }
    ],
    "correctAnswers": ["B"],
    "explanation": "First add parenthesis (round brackets) to the given expression: -a++.\nThere are 2 operators involved. unary minus and Postfix operator. Let's start with expression and value of a.\n-a++; [a = 100].\n-(a++); [a = 100] Postfix operator has got higher precedence than unary operator.\n-(100); [a = 101] Use the value of a (100) in the expression and after that increase the value of a to 101.\n-100; [a = 101] -100 is printed on to the console."
  },
  {
    "id": 61,
    "type": "single",
    "questionText": "Fill in the blanks for the definition of java.lang.Error class:\npublic class java.lang.Error extends ________________ {...}",
    "codeSnippet": "",
    "options": [
      { "id": "A", "text": "Exception" },
      { "id": "B", "text": "Throwable" },
      { "id": "C", "text": "RuntimeException" },
      { "id": "D", "text": "Object" }
    ],
    "correctAnswers": ["B"],
    "explanation": "An Error is a subclass of Throwable class."
  },
  {
    "id": 62,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(100);\n        System.out.println(sb.length() + \":\" + sb.toString().length());\n    }\n}",
    "options": [
      { "id": "A", "text": "100:100" },
      { "id": "B", "text": "0:0" },
      { "id": "C", "text": "100:0" },
      { "id": "D", "text": "0:100" }
    ],
    "correctAnswers": ["B"],
    "explanation": "`new StringBuilder(100);` creates a StringBuilder instance, whose internal char array's length is 100 but length() method of StringBuilder object returns the number of characters stored in the internal array and in this case it is 0. So, `sb.length()` returns 0.\nsb.toString() is the String representation of StringBuilder instance and in this case as there are no characters inside the StringBuilder object, hence sb.toString() returns an empty String \"\", so `sb.toString().length()` also returns 0.\nOutput is 0:0."
  },
  {
    "id": 63,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Double [] arr = new Double[2];\n        System.out.println(arr[0] + arr[1]);\n    }\n}",
    "options": [
      { "id": "A", "text": "0.0" },
      { "id": "B", "text": "null" },
      { "id": "C", "text": "NullPointerException" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["C"],
    "explanation": "Array elements are initialized to their default values.\narr is referring to an array of Double type, which is reference type and hence both the array elements are initialized to null.\nTo calculate arr[0] + arr[1], java runtime converts the expression to arr[0].doubleValue() + arr[1].doubleValue().\nAs arr[0] and arr[1] are null hence calling doubleValue() method throws NullPointerException."
  },
  {
    "id": 64,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca.test;\n \nabstract class Animal {\n    private String name;\n    Animal(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n}\n \nclass Dog extends Animal {\n    private String breed;\n    Dog(String breed) {\n        this.breed = breed;\n    }\n    Dog(String name, String breed) {\n        super(name);\n        this.breed = breed;\n    }\n    public String getBreed() {\n        return breed;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Dog dog1 = new Dog(\"Beagle\");\n        Dog dog2 = new Dog(\"Bubbly\", \"Poodle\");\n        System.out.println(dog1.getName() + \":\" + dog1.getBreed() + \":\" + \n                            dog2.getName() + \":\" + dog2.getBreed());\n    }\n}",
    "options": [
      { "id": "A", "text": "null:Beagle:Bubbly:Poodle" },
      { "id": "B", "text": "Beagle:null:Bubbly:Poodle" },
      { "id": "C", "text": "Compilation error" },
      { "id": "D", "text": "Runtime Exception" }
    ],
    "correctAnswers": ["C"],
    "explanation": "abstract class can have constructors and it also possible to have abstract class without any abstract method.\nSo, there is no issue with Animal class. Java compiler adds super();\nas the first statement inside constructor, if call to another constructor using this(...) or super(...) is not available.\nInside Animal class Constructor, compiler adds super(); => Animal(String name) { super(); this.name = name;\n}, super() in this case invokes the no-arg constructor of Object class and hence no compilation error here.\nCompiler changes Dog(String) constructor to: Dog(String breed) { super(); this.breed = breed; }.\nNo-arg constructor is not available in Animal class and as another constructor is provided, java compiler doesn't add default constructor.\nHence Dog(String) constructor gives compilation error. There is no issue with Dog(String, String) constructor."
  },
  {
    "id": 65,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        String s = new String(\"Hello\");\n        List<String> list = new ArrayList<>();\n        list.add(s);\n        list.add(new String(\"Hello\"));\n        list.add(s);\n        s.replace(\"l\", \"L\");\n        System.out.println(list);\n    }\n}",
    "options": [
      { "id": "A", "text": "[Hello, Hello, Hello]" },
      { "id": "B", "text": "[HeLLo, Hello, HeLLo]" },
      { "id": "C", "text": "[HeLLo, Hello, Hello]" },
      { "id": "D", "text": "[Hello, HeLLo, Hello]" }
    ],
    "correctAnswers": ["A"],
    "explanation": "ArrayList's 1st and 3rd items are referring to same String instance referred by s [s --> \"Hello\"] and 2nd item is referring to another instance of String.\nString is immutable, which means s.replace(\"l\", \"L\"); creates another String instance \"HeLLo\" but s still refers to \"Hello\" [s --> \"Hello\"].\n[Hello, Hello, Hello] is printed in the output."
  },
  {
    "id": 66,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        Period period = Period.of(0, 0, 0);\n        System.out.println(period);\n    }\n}",
    "options": [
      { "id": "A", "text": "P0D" },
      { "id": "B", "text": "P0Y0M0D" },
      { "id": "C", "text": "0-0-0" },
      { "id": "D", "text": "P0" }
    ],
    "correctAnswers": ["A"],
    "explanation": "Period.of(0, 0, 0); is equivalent to Period.ZERO.\nZERO period is displayed as P0D, other than that, Period components (year, month, day) with 0 values are ignored.\ntoString()'s result starts with P, and for non-zero year, Y is appended; for non-zero month, M is appended;\nand for non-zero day, D is appended. P,Y,M and D are in upper case.\nNOTE: Period.parse(CharSequence) method accepts the String parameter in \"PnYnMnD\" format, over here P,Y,M and D can be in any case."
  },
  {
    "id": 67,
    "type": "single",
    "questionText": "Consider below code:\nWhat will be the result of compiling and executing Test class?",
    "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Period;\nimport java.time.format.DateTimeFormatter;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2012, 1, 11);\n        Period period = Period.ofMonths(2);\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MM-dd-yy\");\n        System.out.print(formatter.format(date.minus(period)));\n    }\n}",
    "options": [
      { "id": "A", "text": "11-11-11" },
      { "id": "B", "text": "01-11-12" },
      { "id": "C", "text": "11-11-12" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["A"],
    "explanation": "date --> {2012-01-11}, period --> {P2M}, date.minus(period) --> {2011-11-11} [subtract 2 months period from {2012-01-11}, month is changed to 11 and year is changed to 2011].\nformatter -> {MM-dd-yy}, when date {2011-11-11} is formatter in this format 11-11-11 is printed on to the console."
  },
  {
    "id": 68,
    "type": "single",
    "questionText": "____________ uses access modifiers to protect variables and hide them within a class.\nWhich of the following options accurately fill in the blanks above?",
    "codeSnippet": "",
    "options": [
      { "id": "A", "text": "Encapsulation" },
      { "id": "B", "text": "Polymorphism" },
      { "id": "C", "text": "Inheritance" },
      { "id": "D", "text": "Abstraction" }
    ],
    "correctAnswers": ["A"],
    "explanation": "Encapsulation is all about having private instance variable and providing public getter and setter methods."
  },
  {
    "id": 69,
    "type": "single",
    "questionText": "Consider codes below:\nOne of the statements inside print() method is causing compilation failure.\nWhich of the below solutions will help to resolve compilation error?",
    "codeSnippet": "//A.java\npackage com.udayan.oca;\n \npublic class A {\n     public int i1 = 1;\n     protected int i2 = 2;\n}\n//B.java\npackage com.udayan.oca.test;\n \nimport com.udayan.oca.A;\n \npublic class B extends A {\n    public void print() {\n        A obj = new A();\n        System.out.println(obj.i1); //Line 8\n        System.out.println(obj.i2); //Line 9\n        System.out.println(this.i2); //Line 10\n        System.out.println(super.i2); //Line 11\n    }\n    public static void main(String [] args) {\n        new B().print();\n    }\n}",
    "options": [
      { "id": "A", "text": "Remove Line 9" },
      { "id": "B", "text": "Remove Line 8" },
      { "id": "C", "text": "Remove Line 10" },
      { "id": "D", "text": "Remove Line 11" }
    ],
    "correctAnswers": ["A"],
    "explanation": "class A is declared public and defined in com.udayan.oca package, there is no problem in accessing class A outside com.udayan.oca package.\nclass B is defined in com.udayan.oca.test package, to extend from class A either use import statement \"import com.udayan.oca.A;\"\nor fully qualified name of the class com.udayan.oca.A. No issues with this class definition as well.\nVariable i1 is declared public in class A, so Line 8 doesn't cause any compilation error.\nVariable i2 is declared protected so it can only be accessed in subclass using inheritance but not using object reference variable.\nobj.i2 causes compilation failure. class B inherits variable i2 from class A, so inside class B it can be accessed by using either this or super.\nLine 10 and Line 11 don't cause any compilation error."
  },
  {
    "id": 70,
    "type": "single",
    "questionText": "What will be the result of compiling and executing Test class?",
    "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            main(args);\n        } catch (Exception ex) {\n            System.out.println(\"CATCH-\");\n        }\n            System.out.println(\"OUT\");\n    }\n}",
    "options": [
      { "id": "A", "text": "CATCH- OUT" },
      { "id": "B", "text": "Prints OUT infinitely" },
      { "id": "C", "text": "StackOverflowError" },
      { "id": "D", "text": "Compilation error" }
    ],
    "correctAnswers": ["C"],
    "explanation": "main(args) method is invoked recursively without specifying any exit condition, so this code ultimately throws java.lang.StackOverflowError.\nStackOverflowError is a subclass of Error type and not Exception type, hence it is not handled.\nStack trace is printed to the console and program ends abruptly.\nJava doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block.\ncatch(java.io.FileNotFoundException ex) {} will cause compilation error in this case as main(args); will never throw FileNotFoundException.\nBut Java allows to catch Exception type, hence catch (Exception ex) {} doesn't cause any compilation error."
  }]},
  {
    "id": 2,
    "name": "OCA Practice Exam 2",
    "description": "Set 2",
    "questions": [
      {
        "id": 1,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"Hurrah! I Passed...\");\n        sb.delete(0, 100);\n        System.out.println(sb.length());\n    }\n}",
        "options": [
          { "id": "A", "text": "0" },
          { "id": "B", "text": "19" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "StringIndexOutOfBoundsException" }
        ],
        "correctAnswers": ["A"],
        "explanation": "'delete' method accepts 2 parameters: delete(int start, int end), where start is inclusive and end is exclusive.\nIf end is greater than the length of StringBuilder object, then StringIndexOutOfBoundsException is not thrown and end is set to sb.length().\nSo, in this case, `sb.delete(0, 100);` is equivalent to `sb.delete(0, sb.length());` and this deletes all the characters from the StringBuilder object.\nHence, System.out.println(sb.length()); prints 0 on to the console."
      },
      {
        "id": 2,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(null);\n        list.add(null);\n        list.add(null);\n        System.out.println(list.remove(0) + \":\" + list.remove(null));\n    }\n}",
        "options": [
          { "id": "A", "text": "null:true" },
          { "id": "B", "text": "null:null" },
          { "id": "C", "text": "true:true" },
          { "id": "D", "text": "NullPointerException" }
        ],
        "correctAnswers": ["A"],
        "explanation": "It is possible to add null to ArrayList instant.\nInitially list has 3 elements: [null, null, null].\nremove(int) returns the deleted member of the list. In this case `list.remove(0);` returns null as null was deleted from the 0th index.\nremove(Object) returns true if deletion was successful otherwise false. In this case `list.remove(null)` removes first null from the list and returns true.\nHence, the output is: 'null:true'."
      },
      {
        "id": 3,
        "type": "single",
        "questionText": "How can you force JVM to run Garbage Collector?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "System.gc()" },
          { "id": "B", "text": "Runtime.getRuntime().gc()" },
          { "id": "C", "text": "Setting object to null" },
          { "id": "D", "text": "Garbage Collection cannot be forced" }
        ],
        "correctAnswers": ["D"],
        "explanation": "Both Runtime.getRuntime().gc(); and System.gc(); do the same thing, these make a request to JVM to run Garbage Collector.\nJVM makes the best effort to run Garbage Collector but nothing is guaranteed.\nGarbage Collection cannot be forced."
      },
      {
        "id": 4,
        "type": "single",
        "questionText": "Consider the code of Test.java file:\nWhat will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nclass Student {\n    String name;\n    int age;\n \n    Student() {\n        Student(\"James\", 25);\n    }\n \n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Student s = new Student();\n        System.out.println(s.name + \":\" + s.age);\n    }\n}",
        "options": [
          { "id": "A", "text": "James:25" },
          { "id": "B", "text": "null:0" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "A constructor can call another constructor by using this(...) and not the constructor name.\nHence Student(\"James\", 25); causes compilation error."
      },
      {
        "id": 5,
        "type": "single",
        "questionText": "What will be the result of executing Test class using below command?\njava Test good morning everyone",
        "codeSnippet": "private class Test {\n    public static void main(String args[]) {\n        System.out.println(args[1]);\n    }\n}",
        "options": [
          { "id": "A", "text": "good" },
          { "id": "B", "text": "morning" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Top level class can have two access modifiers: public and default.\nOver here Test class has private modifier and hence compilation error."
      },
      {
        "id": 6,
        "type": "single",
        "questionText": "Consider the following interface declaration:\nWhich of the following incorrectly implements interface I1?",
        "codeSnippet": "public interface I1 {\n    void m1() throws java.io.IOException;\n}",
        "options": [
          { "id": "A", "text": "public void m1() {}" },
          { "id": "B", "text": "public void m1() throws java.io.IOException {}" },
          { "id": "C", "text": "public void m1() throws java.io.FileNotFoundException {}" },
          { "id": "D", "text": "public void m1() throws Exception {}" }
        ],
        "correctAnswers": ["D"],
        "explanation": "NOTE: Question is asking for \"incorrect\" implementation.\nOverriding rule: Cannot declare to throw the super class of the exception thrown by super class / interface method.\nException is super class of IOException, so option D is incorrect implementation."
      },
      {
        "id": 7,
        "type": "single",
        "questionText": "What will be the result of compiling and executing the Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int grade = 75;\n        if(grade > 60)\n            System.out.println(\"Congratulations\");\n            System.out.println(\"You passed\");\n        else\n            System.out.println(\"You failed\");\n    }\n}",
        "options": [
          { "id": "A", "text": "Congratulations\nYou passed" },
          { "id": "B", "text": "Congratulations" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "You failed" }
        ],
        "correctAnswers": ["C"],
        "explanation": "As there is no brackets after if, hence only one statement is part of if block.\nSystem.out.println(\"You passed\"); is between if-else blocks, breaking the if-else syntax.\nThere should not be anything between if-else block and thus Compilation error."
      },
      {
        "id": 8,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int a = 2;\n        boolean res = false;\n        res = a++ == 2 || --a == 2 && --a == 2;\n        System.out.println(a);\n    }\n}",
        "options": [
          { "id": "A", "text": "2" },
          { "id": "B", "text": "3" },
          { "id": "C", "text": "4" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Evaluation: ((a++) == 2) || ...\n(2 == 2) is true.\n|| is a short-circuit operator, so the right side is NOT evaluated.\na was incremented to 3 by a++.\nOutput is 3."
      },
      {
        "id": 9,
        "type": "multiple",
        "questionText": "For the class Test, which options, if used to replace /*INSERT*/, will print TEN on to the console?\nSelect 4 options.",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        /*INSERT*/\n        switch(var) {\n            case 10:\n                System.out.println(\"TEN\");\n                break;\n            default:\n                System.out.println(\"DEFAULT\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "byte var = 10;" },
          { "id": "B", "text": "short var = 10;" },
          { "id": "C", "text": "int var = 10;" },
          { "id": "D", "text": "char var = 10;" },
          { "id": "E", "text": "long var = 10;" },
          { "id": "F", "text": "double var = 10;" }
        ],
        "correctAnswers": ["A", "B", "C", "D"],
        "explanation": "switch can accept primitive types: byte, short, int, char; wrapper types: Byte, Short, Integer, Character; String and enums.\nlong and double are invalid values for switch."
      },
      {
        "id": 10,
        "type": "single",
        "questionText": "Line 5 is giving compilation error as process method is not found.\nWhich of the following method definitions, if used to replace /*INSERT*/, will resolve the compilation error?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int [] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        String str = process(arr, 3, 8); //Line 5\n        System.out.println(str);\n    }\n \n    /*INSERT*/\n}",
        "options": [
          { "id": "A", "text": "public static void process(int[] arr, int start, int end) { return \"\"; }" },
          { "id": "B", "text": "public static String process(int[] arr, int start, int end) { return null; }" },
          { "id": "C", "text": "public void process(int[] arr, int start, int end) { return null; }" },
          { "id": "D", "text": "public static int process(int[] arr, int start, int end) { return 0; }" }
        ],
        "correctAnswers": ["B"],
        "explanation": "From Line 5 `String str = process(arr, 3, 8);`, it is clear that:\n1. Method must be static (called from static main).\n2. Must accept (int[], int, int).\n3. Must return String."
      },
      {
        "id": 11,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nclass Message {\n    String msg = \"Happy New Year!\";\n    public void print() {\n        System.out.println(msg);\n    }\n}\n \npublic class Test {\n    public static void change(Message m) {\n        m.msg = \"Happy Holidays!\";\n    }\n \n    public static void main(String[] args) {\n        Message obj = new Message();\n        obj.print();\n        change(obj);\n        obj.print();\n    }\n}",
        "options": [
          { "id": "A", "text": "Happy New Year!\nHappy New Year!" },
          { "id": "B", "text": "Happy New Year!\nHappy Holidays!" },
          { "id": "C", "text": "Happy Holidays!\nHappy Holidays!" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Line n3 `change(obj)` passes the reference of `obj` to `m`.\n`m.msg = \"Happy Holidays!\";` modifies the `msg` variable of the SAME instance.\nSo when `obj.print()` is called again, it prints the modified value."
      },
      {
        "id": 12,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str1 = \" \";\n        boolean b1 = str1.isEmpty();\n        System.out.println(b1);\n        str1.trim();\n        b1 = str1.isEmpty();\n        System.out.println(b1);\n    }\n}",
        "options": [
          { "id": "A", "text": "false\ntrue" },
          { "id": "B", "text": "false\nfalse" },
          { "id": "C", "text": "true\ntrue" },
          { "id": "D", "text": "true\nfalse" }
        ],
        "correctAnswers": ["B"],
        "explanation": "str1 contains a space, so isEmpty() is false.\n`str1.trim();` creates a NEW string but does NOT reassign it to str1 (Strings are immutable).\nSo str1 remains \" \". The second isEmpty() is also false."
      },
      {
        "id": 13,
        "type": "multiple",
        "questionText": "Which of the following options can replace /*INSERT*/ such that on executing Test class all the array elements are displayed in the output? Select ALL that apply.",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.function.Predicate;\npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"A\", \"ab\", \"bab\", \"Aa\", \"bb\", \"baba\", \"aba\", \"Abab\"};\n        processStringArray(arr, /*INSERT*/);\n    }\n    private static void processStringArray(String [] arr, Predicate<String> predicate) {\n        for(String str : arr) {\n            if(predicate.test(str)) {\n                System.out.println(str);\n            }\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "p -> true" },
          { "id": "B", "text": "p -> !false" },
          { "id": "C", "text": "p -> p.length() >= 1" },
          { "id": "D", "text": "p -> p.length() < 10" }
        ],
        "correctAnswers": ["A", "B", "C", "D"],
        "explanation": "To print all elements, the predicate must return true for every string in the array.\nA: true (always true)\nB: !false (always true)\nC: length >= 1 (All elements have length >= 1)\nD: length < 10 (All elements have length < 10)\nAll options are correct."
      },
      {
        "id": 14,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int score = 60;\n        switch (score) {\n            default:\n                System.out.println(\"Not a valid score\");\n            case score < 70:\n                System.out.println(\"Failed\");\n                break;\n            case score >= 70:\n                System.out.println(\"Passed\");\n                break;\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "Failed" },
          { "id": "B", "text": "Not a valid score" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Switch expression is of `int` type.\nCase expressions `score < 70` evaluate to `boolean`. Types do not match. Compilation error."
      },
      {
        "id": 15,
        "type": "multiple",
        "questionText": "Which of the following changes, done independently, allows the code to compile and on execution prints LogHelper-help? Select 3 options.",
        "codeSnippet": "abstract class Helper {\n    protected abstract void help();\n}\npublic class LogHelper extends Helper {\n    void help() { // Overriding with default access\n        System.out.println(\"LogHelper-help\");\n    }\n    public static void main(String [] args) {\n        new LogHelper().help();\n    }\n}",
        "options": [
          { "id": "A", "text": "Remove protected from Helper.help()" },
          { "id": "B", "text": "Add protected to LogHelper.help()" },
          { "id": "C", "text": "Add public to LogHelper.help()" },
          { "id": "D", "text": "Make Helper.help() private" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "Helper.help() is protected. LogHelper.help() is default (package-private).\nCannot reduce visibility of overridden method.\nSolutions:\n1. Make parent default (remove protected).\n2. Make child protected.\n3. Make child public (increase visibility)."
      },
      {
        "id": 16,
        "type": "single",
        "questionText": "Which of the following keywords is used to manually throw an exception?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "throws" },
          { "id": "B", "text": "throw" },
          { "id": "C", "text": "try" },
          { "id": "D", "text": "catch" }
        ],
        "correctAnswers": ["B"],
        "explanation": "`throws` is for declaration. `throw` is used to manually throw an exception (e.g. `throw new Exception()`)."
      },
      {
        "id": 17,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "List<String> list = new ArrayList<>();\nlist.add(0, \"Array\");\nlist.add(0, \"List\");\nSystem.out.println(list);",
        "options": [
          { "id": "A", "text": "[Array, List]" },
          { "id": "B", "text": "[List, Array]" },
          { "id": "C", "text": "[Array]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "1. add(0, \"Array\") -> [Array]\n2. add(0, \"List\") -> inserts List at 0, shifts Array to 1 -> [List, Array]"
      },
      {
        "id": 18,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "List<Student> students = new ArrayList<>();\nstudents.add(new Student(\"James\", 25));\nstudents.add(new Student(\"James\", 27));\nstudents.add(new Student(\"James\", 25));\nstudents.add(new Student(\"James\", 25));\nstudents.remove(new Student(\"James\", 25));\n// Student class overrides equals() properly",
        "options": [
          { "id": "A", "text": "Prints 3 students" },
          { "id": "B", "text": "Prints 4 students" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Student overrides `equals()`. `remove` finds the first matching object (James, 25) and removes it.\nThere are 3 matching objects initially. One removed. 3 objects remain (James 27, and two James 25)."
      },
      {
        "id": 19,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "System.out.println(\"Output is: \" + (10 != 5));",
        "options": [
          { "id": "A", "text": "Output is: true" },
          { "id": "B", "text": "Output is: false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Output is: 10 != 5" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Parentheses `(10 != 5)` are evaluated first -> true.\nThen concatenation: \"Output is: \" + true -> \"Output is: true\"."
      },
      {
        "id": 20,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "class Child extends Parent {\n    Child(int i, int j) {\n        super(i);\n        this(j);\n    }\n}",
        "options": [
          { "id": "A", "text": "Compiles successfully" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Prints values" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Constructor has `super(i)` AND `this(j)`.\nA constructor must have either `super(...)` OR `this(...)` as the FIRST statement, but never both. Compilation error."
      },
      {
        "id": 21,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "class Parent { public String toString() { return \"Inner \"; } }\nclass Child extends Parent { \n    public String toString() { \n        return super.toString().concat(\"Peace!\"); \n    }\n}\n// main prints new Child()",
        "options": [
          { "id": "A", "text": "Inner" },
          { "id": "B", "text": "Peace!" },
          { "id": "C", "text": "Inner Peace!" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "`super.toString()` returns \"Inner \".\nConcat \"Peace!\" -> \"Inner Peace!\"."
      },
      {
        "id": 22,
        "type": "single",
        "questionText": "Which is not a valid statement based on given code?\nclass A{} class B extends A{}",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "A a = new A();" },
          { "id": "B", "text": "B b = new B();" },
          { "id": "C", "text": "A a = new B();" },
          { "id": "D", "text": "B b = new A();" }
        ],
        "correctAnswers": ["D"],
        "explanation": "`B b = new A();` is invalid. A parent object cannot be assigned to a child reference without explicit casting (and runtime check)."
      },
      {
        "id": 23,
        "type": "single",
        "questionText": "Choose the options that meets the following specification:\nCreate a well encapsulated class Clock with one instance variable model.",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "public variable, private methods" },
          { "id": "B", "text": "private variable, public getter/setter" },
          { "id": "C", "text": "default variable, no methods" },
          { "id": "D", "text": "protected variable" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Encapsulation requires private instance variables accessed via public getter and setter methods."
      },
      {
        "id": 24,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "class Vehicle {}\nclass Car {}\n// main:\nVehicle obj = new Car();",
        "options": [
          { "id": "A", "text": "Compiles successfully" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Prints hashcode" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Car does NOT extend Vehicle. They are unrelated classes.\n`Vehicle obj = new Car();` causes compilation error."
      },
      {
        "id": 25,
        "type": "single",
        "questionText": "Which of the following correctly defines class Printer?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "package ...; import ...; class Printer {}" },
          { "id": "B", "text": "import ...; package ...; class Printer {}" },
          { "id": "C", "text": "class Printer {} package ...;" },
          { "id": "D", "text": "import ...; class Printer {}" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Correct order: 1. Package declaration, 2. Imports, 3. Class declaration."
      },
      {
        "id": 26,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "LocalDate date = LocalDate.parse(\"2000-01-01\");\nPeriod period = Period.ofYears(-3000);\nSystem.out.println(date.plus(period));",
        "options": [
          { "id": "A", "text": "-1000-01-01" },
          { "id": "B", "text": "2000-01-01" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "2000 + (-3000) = -1000. LocalDate supports negative years (BC)."
      },
      {
        "id": 27,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "int [] arr = {3, 2, 1};\nfor(int i : arr) {\n    System.out.println(arr[i]);\n}",
        "options": [
          { "id": "A", "text": "3 2 1" },
          { "id": "B", "text": "1 2 3" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "ArrayIndexOutOfBoundsException" }
        ],
        "correctAnswers": ["D"],
        "explanation": "Iteration 1: i = 3. Accessing arr[3]. Array size is 3 (indices 0,1,2).\narr[3] throws ArrayIndexOutOfBoundsException."
      },
      {
        "id": 28,
        "type": "single",
        "questionText": "Following statement in a Java program compiles successfully: student.report(course);\nWhat can you say for sure?",
        "codeSnippet": "student.report(course);",
        "options": [
          { "id": "A", "text": "student is a class name" },
          { "id": "B", "text": "report is a method name" },
          { "id": "C", "text": "student is a reference variable" },
          { "id": "D", "text": "course is a String" }
        ],
        "correctAnswers": ["B"],
        "explanation": "We don't know if 'student' is a class (static method) or reference (instance method). But 'report' MUST be the method name."
      },
      {
        "id": 29,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "System.out.println(new Boolean(\"ture\"));",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Boolean constructor parses String. It is case-insensitive \"true\" for true. Anything else is false.\n\"ture\" is not \"true\", so it prints false."
      },
      {
        "id": 30,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "list.add(27); list.add(27);\nlist.add(new Integer(27)); list.add(new Integer(27));\nSystem.out.println(list.get(0) == list.get(1));\nSystem.out.println(list.get(2) == list.get(3));",
        "options": [
          { "id": "A", "text": "true\ntrue" },
          { "id": "B", "text": "true\nfalse" },
          { "id": "C", "text": "false\ntrue" },
          { "id": "D", "text": "false\nfalse" }
        ],
        "correctAnswers": ["B"],
        "explanation": "27 is cached (autoboxing). So index 0 and 1 refer to the same object -> true.\nnew Integer(27) creates new objects. Index 2 and 3 are different objects -> false."
      },
      {
        "id": 31,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "List<String> list = new ArrayList<>();\n// add items...\nif(list.remove(2)) { ... }",
        "options": [
          { "id": "A", "text": "Compiles successfully" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Prints list" }
        ],
        "correctAnswers": ["B"],
        "explanation": "list.remove(int index) returns the *removed element* (String), NOT a boolean.\nIf condition expects boolean. String cannot be converted to boolean. Compilation error."
      },
      {
        "id": 32,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "Boolean b1 = new Boolean(\"tRuE\");\nBoolean b2 = new Boolean(\"fAlSe\");\nBoolean b3 = new Boolean(\"abc\");\nBoolean b4 = null;\nSystem.out.println(b1 + \":\" + b2 + \":\" + b3 + \":\" + b4);",
        "options": [
          { "id": "A", "text": "true:false:false:null" },
          { "id": "B", "text": "true:true:false:null" },
          { "id": "C", "text": "true:false:true:null" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "\"tRuE\" -> true (case insensitive).\n\"fAlSe\" -> false.\n\"abc\" -> false.\nnull -> null.\nOutput: true:false:false:null"
      },
      {
        "id": 33,
        "type": "single",
        "questionText": "What is the result?",
        "codeSnippet": "//Guest.main calls Message.main(args)\n// java Guest James Gosling",
        "options": [
          { "id": "A", "text": "Welcome James!" },
          { "id": "B", "text": "Welcome Gosling!" },
          { "id": "C", "text": "Welcome James Gosling!" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Args passed: [\"James\", \"Gosling\"].\nMessage.main prints \"Welcome \" + args[0] + \"!\".\nargs[0] is \"James\". Output: Welcome James!"
      },
      {
        "id": 34,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "public class Test {\n    public String name;\n    public void Test() { name = \"James\"; }\n    public static void main(String [] args) {\n        Test obj = new Test();\n        System.out.println(obj.name);\n    }\n}",
        "options": [
          { "id": "A", "text": "James" },
          { "id": "B", "text": "null" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "`void Test()` is a METHOD, not a constructor. The default constructor is used, which does not initialize `name`.\n`name` remains null."
      },
      {
        "id": 35,
        "type": "single",
        "questionText": "Which of the following 3 statements are true?",
        "codeSnippet": "// A has: public i1, protected i2, default i3, private i4\n// TestA (diff package) creates A obj\n// Accessing obj.i1, obj.i2, obj.i3, obj.i4",
        "options": [
          { "id": "A", "text": "Line 8 (i1) compiles" },
          { "id": "B", "text": "Line 9 (i2) compiles" },
          { "id": "C", "text": "Line 10 (i3) compiles" },
          { "id": "D", "text": "Line 11 (i4) compiles" }
        ],
        "correctAnswers": ["A"],
        "explanation": "TestA is in a different package.\nOnly public members (i1) are accessible via object reference.\nprotected, default, private are not accessible."
      },
      {
        "id": 36,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "String s1 = \"OcA\";\nString s2 = \"oCa\";\nSystem.out.println(s1.equals(s2));",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "String.equals is case-sensitive. \"OcA\" is not equal to \"oCa\". Output: false."
      },
      {
        "id": 37,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "add(10.0, null);\n// overloaded: add(double, double) and add(Double, Double)",
        "options": [
          { "id": "A", "text": "double version" },
          { "id": "B", "text": "Double version" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "NullPointerException" }
        ],
        "correctAnswers": ["D"],
        "explanation": "null cannot be double primitive. So it chooses `add(Double, Double)`.\nInside `add(Double, Double)`, it tries to unbox null (d1+d2). Unboxing null throws NullPointerException."
      },
      {
        "id": 38,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "LocalDate date = LocalDate.parse(\"2018-1-01\");",
        "options": [
          { "id": "A", "text": "2018-01-01" },
          { "id": "B", "text": "2018-1-01" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "DateTimeParseException" }
        ],
        "correctAnswers": ["D"],
        "explanation": "LocalDate.parse requires standard format YYYY-MM-DD (two digits for month/day).\n\"2018-1-01\" fails. Throws exception."
      },
      {
        "id": 39,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "StringBuilder sb = new StringBuilder(\"Java\");\nString s1 = sb.toString();\nString s2 = \"Java\";\nSystem.out.println(s1 == s2);",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "sb.toString() creates a NEW String object (not interned).\ns2 is a String Literal (interned).\nThey refer to different objects. s1 == s2 is false."
      },
      {
        "id": 40,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "int x = 5;\nwhile (x < 10)\n    System.out.println(x);\nx++;",
        "options": [
          { "id": "A", "text": "Prints 5 to 9" },
          { "id": "B", "text": "Prints 5 once" },
          { "id": "C", "text": "Infinite loop printing 5" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Missing braces for while loop. Only the print statement is inside the loop.\nx is never incremented. Infinite loop."
      },
      {
        "id": 41,
        "type": "single",
        "questionText": "Does above code compile successfully?",
        "codeSnippet": "long l = 100_00l;\nint i = 9_2;\nfloat f = 2.02f;\ndouble d = 10_0.35d;",
        "options": [
          { "id": "A", "text": "Yes" },
          { "id": "B", "text": "No, underscore error" },
          { "id": "C", "text": "No, casting error" },
          { "id": "D", "text": "No, suffix error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Underscores are valid between digits. Suffixes l, f, d are valid. Assignments with casting (in full code) are valid. Compiles successfully."
      },
      {
        "id": 42,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "// 4 LocalDates created via parse and of\nSystem.out.println((d1 == d2) + \":\" + (d2 == d3) + \":\" + (d3 == d4));",
        "options": [
          { "id": "A", "text": "true:true:true" },
          { "id": "B", "text": "false:false:false" },
          { "id": "C", "text": "true:false:true" },
          { "id": "D", "text": "false:true:false" }
        ],
        "correctAnswers": ["B"],
        "explanation": "LocalDate.parse and LocalDate.of always create NEW instances.\nReferences are different. == checks reference equality. All false."
      },
      {
        "id": 43,
        "type": "single",
        "questionText": "What will be the result of compiling and executing the following program?",
        "codeSnippet": "try { ... }\ncatch (IOException e) { ... }\ncatch(FileNotFoundException e) { ... }",
        "options": [
          { "id": "A", "text": "Compiles successfully" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Prints A" }
        ],
        "correctAnswers": ["B"],
        "explanation": "FileNotFoundException is a subclass of IOException.\nIt must be caught BEFORE IOException. Unreachable code error."
      },
      {
        "id": 44,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "String fruit = \"mango\";\nswitch (fruit) {\n    case \"Apple\": ...\n    // ...\n    default: System.out.println(\"ANY FRUIT WILL DO\");\n}",
        "options": [
          { "id": "A", "text": "ANY FRUIT WILL DO" },
          { "id": "B", "text": "APPLE" },
          { "id": "C", "text": "MANGO" },
          { "id": "D", "text": "Nothing" }
        ],
        "correctAnswers": ["A"],
        "explanation": "\"mango\" (lowercase) does not match \"Mango\" (case sensitive).\nGoes to default. Prints \"ANY FRUIT WILL DO\"."
      },
      {
        "id": 45,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "ListIterator<String> iterator = dryFruits.listIterator();\nwhile(iterator.hasNext()) {\n    if(iterator.next().startsWith(\"A\")) {\n        iterator.remove();\n    }\n}",
        "options": [
          { "id": "A", "text": "[Walnut, Date]" },
          { "id": "B", "text": "ConcurrentModificationException" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Removes nothing" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Using `iterator.remove()` is the correct way to modify a list during iteration.\nIt removes Apricot and Almond. Result: Walnut, Date."
      },
      {
        "id": 46,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "Period period = Period.of(2, 1, 0).ofYears(10).ofMonths(5).ofDays(2);\nSystem.out.println(period);",
        "options": [
          { "id": "A", "text": "P2D" },
          { "id": "B", "text": "P10Y5M2D" },
          { "id": "C", "text": "P2Y1M0D" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Period methods like `ofYears` are STATIC methods. Chaining them does not combine values.\n`Period.of(...)` returns a period, then `ofYears(10)` is called on that type (static access) returning P10Y, then `ofMonths`... finally `ofDays(2)` returns P2D.\nOnly the last one is assigned."
      },
      {
        "id": 47,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "dates.add(LocalDate.parse(\"2018-7-11\"));",
        "options": [
          { "id": "A", "text": "2018-07-11" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "DateTimeParseException" },
          { "id": "D", "text": "Runtime Exception (other)" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Parse requires 2 digits for month. \"7\" is invalid. Should be \"07\". Throws DateTimeParseException."
      },
      {
        "id": 48,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "final String fName = \"James\";\nString lName = \"Gosling\";\nString name1 = fName + lName;\nString name2 = fName + \"Gosling\";\nString name3 = \"James\" + \"Gosling\";\n// Compare name1==name2, name2==name3",
        "options": [
          { "id": "A", "text": "false\ntrue" },
          { "id": "B", "text": "true\ntrue" },
          { "id": "C", "text": "false\nfalse" },
          { "id": "D", "text": "true\nfalse" }
        ],
        "correctAnswers": ["A"],
        "explanation": "name1: `fName` is const, but `lName` is NOT. Result computed at runtime. Not interned.\nname2: `fName` is const + literal. Constant expression. Interned (\"JamesGosling\").\nname3: Literal + Literal. Constant expression. Interned (\"JamesGosling\").\nname2 and name3 refer to same pool object. name1 does not."
      },
      {
        "id": 49,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "String [] arr = new String[7];\nSystem.out.println(arr);",
        "options": [
          { "id": "A", "text": "[null, null, ...]" },
          { "id": "B", "text": "Memory Address (Hashcode)" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Empty String" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Printing an array object directly prints `[Ljava.lang.String;@...` (Hashcode)."
      },
      {
        "id": 50,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "String[][] arr = { { \"7\", \"6\", \"5\" }, { \"4\", \"3\" }, { \"2\", \"1\" } };\n// Nested loop printing even numbers using switch/break/continue",
        "options": [
          { "id": "A", "text": "642" },
          { "id": "B", "text": "7654321" },
          { "id": "C", "text": "64" },
          { "id": "D", "text": "246" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Logic trace: Loop filters for \"2\", \"4\", \"6\".\nPrints 6 (from first row), 4 (from second), 2 (from third).\nOutput: 642."
      },
      {
        "id": 51,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "list.add(\"X\"); list.add(\"Y\"); list.add(\"X\"); list.add(\"Y\"); list.add(\"Z\");\nlist.remove(new String(\"Y\"));\nSystem.out.println(list);",
        "options": [
          { "id": "A", "text": "[X, X, Y, Z]" },
          { "id": "B", "text": "[X, Y, X, Z]" },
          { "id": "C", "text": "[X, X, Z]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Removes the FIRST occurrence of \"Y\". Result: [X, X, Y, Z]."
      },
      {
        "id": 52,
        "type": "multiple",
        "questionText": "For the class Test, which options, if used to replace /*INSERT*/, will print \"apple mango orange grape \" on to the console? Select 2 options.",
        "codeSnippet": "String [][] fruits = {{\"apple\", \"mango\"}, {\"orange\", \"grape\"}};\n/*INSERT*/",
        "options": [
          { "id": "A", "text": "for(String[] arr : fruits) { for(String f : arr) ... }" },
          { "id": "B", "text": "Standard for loop i=0, j=0" },
          { "id": "C", "text": "for(String[] arr : fruits) { for(int i=0...) }" },
          { "id": "D", "text": "Incorrect loop start index" }
        ],
        "correctAnswers": ["A", "B"],
        "explanation": "Correct iteration requires starting at index 0 and iterating all elements. Both enhanced for loop and standard for loop work."
      },
      {
        "id": 53,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "Predicate pr1 = s -> s.length() < 4;\n// Raw type Predicate",
        "options": [
          { "id": "A", "text": "Prints strings length < 4" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Prints nothing" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Predicate is raw type. The lambda parameter `s` is treated as `Object`.\nObject does not have `length()` method. Compilation error."
      },
      {
        "id": 54,
        "type": "multiple",
        "questionText": "Which of the following statements compile without any warning? Select 2 options.",
        "codeSnippet": "List<String> list4 = new ArrayList<String>(); //Line 8\nList<String> list5 = new ArrayList<>(); //Line 9",
        "options": [
          { "id": "A", "text": "Line 5" },
          { "id": "B", "text": "Line 6" },
          { "id": "C", "text": "Line 8" },
          { "id": "D", "text": "Line 9" }
        ],
        "correctAnswers": ["C", "D"],
        "explanation": "Line 8 is standard pre-Java 7 generic syntax. Line 9 uses diamond operator (Java 7+).\nBoth are valid and warning-free. Raw types (Line 5, 6) cause warnings."
      },
      {
        "id": 55,
        "type": "single",
        "questionText": "What is the output if below program is run with the command line: java Test",
        "codeSnippet": "System.out.println(args.length);",
        "options": [
          { "id": "A", "text": "0" },
          { "id": "B", "text": "1" },
          { "id": "C", "text": "null" },
          { "id": "D", "text": "Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "No arguments passed. args array is empty (length 0)."
      },
      {
        "id": 56,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "class Point { static int x; int y, z; ... } \n// p1.x=17, p2.x=19. x is static.",
        "options": [
          { "id": "A", "text": "Point(17,...) Point(19,...)" },
          { "id": "B", "text": "Point(19, 35, -1) Point(19, 40, 0)" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "x is static (shared). Last assignment `p2.x = 19` overwrites it for all instances.\nBoth p1 and p2 see x=19."
      },
      {
        "id": 57,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "private static void m1() throws Exception { throw new Exception(); }\npublic static void main(String[] args) {\n    try { m1(); } finally { ... }\n}",
        "options": [
          { "id": "A", "text": "Prints A" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Prints Stack Trace" }
        ],
        "correctAnswers": ["B"],
        "explanation": "m1 throws checked Exception. main calls m1 but does NOT handle it (no catch, only finally) and does NOT declare it. Compilation error."
      },
      {
        "id": 58,
        "type": "single",
        "questionText": "Which of these keywords can be used to prevent inheritance of a class?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "static" },
          { "id": "B", "text": "final" },
          { "id": "C", "text": "abstract" },
          { "id": "D", "text": "private" }
        ],
        "correctAnswers": ["B"],
        "explanation": "final class cannot be subclassed."
      },
      {
        "id": 59,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "m1(null);\n// overloaded: m1(CharSequence), m1(String), m1(Object)",
        "options": [
          { "id": "A", "text": "String" },
          { "id": "B", "text": "Object" },
          { "id": "C", "text": "CharSequence" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Most specific type rule. String is a subclass of CharSequence and Object.\nJava chooses the most specific match: String."
      },
      {
        "id": 60,
        "type": "multiple",
        "questionText": "Which of the following are Java Exception classes? Select 3 options.",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "ClassCastException" },
          { "id": "B", "text": "NumberFormatException" },
          { "id": "C", "text": "IllegalArgumentException" },
          { "id": "D", "text": "NullException" },
          { "id": "E", "text": "ArrayIndexException" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "A, B, C are valid runtime exceptions. D and E do not exist (it's NullPointerException and ArrayIndexOutOfBoundsException)."
      },
      {
        "id": 61,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class using below commands? java Test AM PM",
        "codeSnippet": "private static boolean flag = !true;\nSystem.out.println(!flag ? args[0] : args[1]);",
        "options": [
          { "id": "A", "text": "AM" },
          { "id": "B", "text": "PM" },
          { "id": "C", "text": "true" },
          { "id": "D", "text": "false" }
        ],
        "correctAnswers": ["A"],
        "explanation": "flag = false. !flag = true.\nTernary chooses first option: args[0], which is AM."
      },
      {
        "id": 62,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "add(10.0, new Integer(10));\n// overloaded: add(double, double) and add(Double, Double)",
        "options": [
          { "id": "A", "text": "double version: 20.0" },
          { "id": "B", "text": "Double version: 20.0" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Integer -> int -> double (widening). 10.0 is double.\nMatches `add(double, double)`."
      },
      {
        "id": 63,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "ArrayList<Integer> cloned = (ArrayList<Integer>) original.clone();\nInteger i1 = cloned.get(0);\n++i1;\nSystem.out.println(cloned);",
        "options": [
          { "id": "A", "text": "[10]" },
          { "id": "B", "text": "[11]" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Integer is immutable. `++i1` creates a new Integer object referenced by variable `i1`.\nThe list `cloned` still holds reference to the original Integer(10). Output: [10]."
      },
      {
        "id": 64,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "LocalDate date = LocalDate.parse(\"1980-03-16\");\nSystem.out.println(date.minusYears(-5));",
        "options": [
          { "id": "A", "text": "1985-03-16" },
          { "id": "B", "text": "1975-03-16" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Subtracting a negative number is adding. 1980 + 5 = 1985."
      },
      {
        "id": 65,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "List<StringBuilder> days = new ArrayList<>();\n// add Sunday, Monday, Tuesday\nif(days.contains(new StringBuilder(\"Sunday\"))) { add Wednesday }\nSystem.out.println(days.size());",
        "options": [
          { "id": "A", "text": "3" },
          { "id": "B", "text": "4" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "StringBuilder does NOT override equals. `contains` uses default equals (reference equality).\nNew StringBuilder(\"Sunday\") != existing one. Returns false. Wednesday not added. Size 3."
      },
      {
        "id": 66,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"mm-dd-yy\");\nSystem.out.print(formatter.format(date.minus(period)));",
        "options": [
          { "id": "A", "text": "11-11-11" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "UnsupportedTemporalTypeException" },
          { "id": "D", "text": "00-11-11" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Pattern \"mm\" stands for MINUTES.\nLocalDate has no time component. Formatting throws UnsupportedTemporalTypeException."
      },
      {
        "id": 67,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "process(list, e -> e.getAge() > 20);",
        "options": [
          { "id": "A", "text": "James Lucy Bill" },
          { "id": "B", "text": "James Bill" },
          { "id": "C", "text": "James Lucy Bill Jack Liya" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Prints employees with age > 20.\nJames(25), Lucy(23), Bill(27). Jack(19) and Liya(20) skipped."
      },
      {
        "id": 68,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "list.add(100); list.add(200); list.add(100); list.add(200);\nlist.remove(new Integer(100));\nSystem.out.println(list);",
        "options": [
          { "id": "A", "text": "[200, 100, 200]" },
          { "id": "B", "text": "[100, 200, 200]" },
          { "id": "C", "text": "[100, 200, 100, 200]" },
          { "id": "D", "text": "IndexOutOfBoundsException" }
        ],
        "correctAnswers": ["A"],
        "explanation": "`list.remove(Object)` removes the FIRST occurrence.\nRemoves first 100. Result: 200, 100, 200."
      },
      {
        "id": 69,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "LocalDate newYear = LocalDate.of(2018, 1, 1);\nLocalDate eventDate = LocalDate.of(2018, 1, 1);\n// compare isAfter, isBefore",
        "options": [
          { "id": "A", "text": "true:true" },
          { "id": "B", "text": "false:false" },
          { "id": "C", "text": "true:false" },
          { "id": "D", "text": "false:true" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Dates are equal. Not after, not before. Both false."
      },
      {
        "id": 70,
        "type": "single",
        "questionText": "Which of the following array declarations and initializations is NOT legal?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "int[] a = {1, 2};" },
          { "id": "B", "text": "int[] a = new int[]{1, 2};" },
          { "id": "C", "text": "int[] a = new int[2];" },
          { "id": "D", "text": "new int[3]{10, 20, 30};" }
        ],
        "correctAnswers": ["D"],
        "explanation": "You cannot specify the size of the array when using an array initializer.\n`new int[3]{...}` is illegal. Should be `new int[]{...}`."
      }
    ]},
  {
    "id": 3,
    "name": "OCA Practice Exam 3",
    "description": "Set 3",
    "questions": [
      {
        "id": 1,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Hello\" + 1 + 2 + 3 + 4);\n    }\n}",
        "options": [
          { "id": "A", "text": "Hello1234" },
          { "id": "B", "text": "Hello10" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "As expression contains + operator only, which is left to right associative. Let us group the expression.\n\"Hello\" + 1 + 2 + 3 + 4\n= (\"Hello\" + 1) + 2 + 3 + 4\n= ((\"Hello\" + 1) + 2) + 3 + 4\n= (((\"Hello\" + 1) + 2) + 3) + 4\n[Let us solve it now, + operator with String behaves as concatenation operator.]\n= ((\"Hello1\" + 2) + 3) + 4\n= (\"Hello12\" + 3) + 4\n= \"Hello123\" + 4\n= \"Hello1234\""
      },
      {
        "id": 2,
        "type": "single",
        "questionText": "What will be the result of compiling and executing TestBaseDerived class?",
        "codeSnippet": "//TestBaseDerived.java\npackage com.udayan.oca;\n \nclass Base {\n    protected void m1() {\n        System.out.println(\"Base: m1()\");\n    }\n}\n \nclass Derived extends Base {\n    void m1() {\n        System.out.println(\"Derived: m1()\");\n    }\n}\n \npublic class TestBaseDerived {\n    public static void main(String[] args) {\n        Base b = new Derived();\n        b.m1();\n    }\n}",
        "options": [
          { "id": "A", "text": "Base: m1()" },
          { "id": "B", "text": "Derived: m1()" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Derived class overrides method m1() of Base class. Access modifier of method m1() in Base class is protected, so overriding method can use protected or public.\nBut overriding method in this case used default modifier and hence there is compilation error."
      },
      {
        "id": 3,
        "type": "single",
        "questionText": "What will be the output of compiling and executing the Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int x = 2;\n        switch (x) {\n            default:\n                System.out.println(\"Still no idea what x is\");\n            case 1:\n                System.out.println(\"x is equal to 1\");\n                break;\n            case 2:\n                System.out.println(\"x is equal to 2\");\n                break;\n            case 3:\n                System.out.println(\"x is equal to 3\");\n                break;\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "x is equal to 2" },
          { "id": "B", "text": "Still no idea what x is" },
          { "id": "C", "text": "x is equal to 1" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Even though default block is available at the top but matching case is present.\nSo control goes inside matching case and prints \"x is equal to 2\" on to the console.\nAfter that break; statement takes the control out of the switch- case block."
      },
      {
        "id": 4,
        "type": "single",
        "questionText": "super keyword in java is used to:",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "Call static methods of the parent class" },
          { "id": "B", "text": "Refer to the current object" },
          { "id": "C", "text": "Refer to parent class object" },
          { "id": "D", "text": "Import packages" }
        ],
        "correctAnswers": ["C"],
        "explanation": "super refers to parent class object and this refers to currently executing object."
      },
      {
        "id": 5,
        "type": "single",
        "questionText": "For the above code, fill in the blank with one option.",
        "codeSnippet": "package com.udayan.oca;\n \nclass TestException extends Exception {\n    public TestException() {\n        super();\n    }\n \n    public TestException(String s) {\n        super(s);\n    }\n}\n \npublic class Test {\n    public void m1() throws __________ {\n        throw new TestException();\n    }\n}",
        "options": [
          { "id": "A", "text": "TestException" },
          { "id": "B", "text": "RuntimeException" },
          { "id": "C", "text": "Error" },
          { "id": "D", "text": "Object" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Method m1() throws an instance of TestException, which is a checked exception as it extends Exception class.\nSo in throws clause we must provide:\n1. Checked exception.\n2. Exception of TestException type or it's super types (Exception, Throwable), Object cannot be used in throws clause."
      },
      {
        "id": 6,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Bonus class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Bonus {\n    public static void main(String[] args) {\n        int $ = 80000;\n        String msg = ($ >= 50000) ? \"Good bonus\" : \"Average bonus\";\n        System.out.println(msg);\n    }\n}",
        "options": [
          { "id": "A", "text": "Good bonus" },
          { "id": "B", "text": "Average bonus" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "$ is valid identifier. $ = 80000\nThis is an example of ternary operator. First operand ($ >= 50000) is a boolean expression which is true, as 80000 >= 50000 is true.\nmsg will refer to \"Good bonus\"."
      },
      {
        "id": 7,
        "type": "single",
        "questionText": "On execution, does Test class print \"HELLO\" on to the console?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    static Double d1;\n    static int x = d1.intValue();\n \n    public static void main(String[] args) {\n        System.out.println(\"HELLO\");\n    }\n}",
        "options": [
          { "id": "A", "text": "Yes" },
          { "id": "B", "text": "No, it throws ExceptionInInitializerError" },
          { "id": "C", "text": "No, it throws NullPointerException" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "To invoke the special main method, JVM loads the class in the memory.\nAt that time, static fields of Test class are initialized.\nd1 is of Double type so null is assigned to it.\nx is also static variable so d1.intValue(); is executed and as d1 is null hence d1.intValue() throws a NullPointerException and as a result an instance of java.lang.ExceptionInInitializerError is thrown."
      },
      {
        "id": 8,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int a = 20;\n        int var = --a * a++ + a-- - --a;\n        System.out.println(\"a = \" + a);\n        System.out.println(\"var = \" + var);\n    }\n}",
        "options": [
          { "id": "A", "text": "a = 18\nvar = 363" },
          { "id": "B", "text": "a = 20\nvar = 400" },
          { "id": "C", "text": "a = 19\nvar = 380" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "int var = --a * a++ + a-- - --a;\nint var = --a * (a++) + (a--) - --a;\nint var = (--a) * (a++) + (a--) - (--a);\nint var = ((--a) * (a++)) + (a--) - (--a);\nint var = (((--a) * (a++)) + (a--)) - (--a);\nint var = ((19 * (a++)) + (a--)) - (--a); //a = 19\nint var = ((19 * 19) + (a--)) - (--a); //a = 20\nint var = (361 + 20) - (--a); //a = 19\nint var = 381 - (--a); //a = 19\nint var = 381 - 18; //a = 18\nint var = 363 // a = 18\nSo,\na = 18\nvar = 363"
      },
      {
        "id": 9,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nclass M { }\nclass N extends M { }\nclass O extends N { }\nclass P extends O { }\n \npublic class Test {\n    public static void main(String args []) {\n        M obj = new O();\n        if(obj instanceof M)\n            System.out.print(\"M\");\n        if(obj instanceof N)\n            System.out.print(\"N\");\n        if(obj instanceof O)\n            System.out.print(\"O\");\n        if(obj instanceof P)\n            System.out.print(\"P\");\n    }\n}",
        "options": [
          { "id": "A", "text": "MNO" },
          { "id": "B", "text": "MNOP" },
          { "id": "C", "text": "M" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "M\n^\nN\n^\nO [obj refers to instance of O class]\n^\nP\nobj instanceof M -> true\nobj instanceof N -> true\nobj instanceof O -> true\nbut\nobj instanceof P -> false"
      },
      {
        "id": 10,
        "type": "single",
        "questionText": "Suppose you have created a java file, \"MyClass.java\". Which of the following commands will compile the java file?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "java MyClass" },
          { "id": "B", "text": "javac MyClass" },
          { "id": "C", "text": "javac MyClass.java" },
          { "id": "D", "text": "java MyClass.java" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Command to compile a java file: javac <java_file_name>.java [.java extension is compulsory]\nCommand to execute a java class: java <class_file_name> [.class extension should not be used]"
      },
      {
        "id": 11,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"Java Rocks!\";\n        System.out.println(str.length() + \" : \" + str.charAt(10));\n    }\n}",
        "options": [
          { "id": "A", "text": "11 : !" },
          { "id": "B", "text": "10 : !" },
          { "id": "C", "text": "11 : s" },
          { "id": "D", "text": "IndexOutOfBoundsException" }
        ],
        "correctAnswers": ["A"],
        "explanation": "String class has length() method, which returns number of characters in the String. So length() method returns 11.\nString class has charAt(int index) method, which returns character at passed index.\nstr.charAt(10) looks for character at index 10. index starts with 0. ! sign is at index 10.\nHence output is: 11 : !"
      },
      {
        "id": 12,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> fruits = new ArrayList<>();\n        fruits.add(\"apple\");\n        fruits.add(\"orange\");\n        fruits.add(\"grape\");\n        fruits.add(\"mango\");\n        fruits.add(\"banana\");\n        fruits.add(\"grape\");\n \n        if(fruits.remove(\"grape\"))\n            fruits.remove(\"papaya\");\n \n        System.out.println(fruits);\n    }\n}",
        "options": [
          { "id": "A", "text": "[apple, orange, mango, banana, grape]" },
          { "id": "B", "text": "[apple, orange, grape, mango, banana]" },
          { "id": "C", "text": "[apple, orange, mango, banana]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "remove(Object) method of List interface removes the first occurrence of the specified element from the list, if it is present.\nIf this list does not contain the element, it is unchanged.\nremove(Object) method returns true, if removal was successful otherwise false.\nInitially list has: [apple, orange, grape, mango, banana, grape]. fruits.remove(\"grape\") removes the first occurrence of \"grape\" and after the successful remove, list has: [apple, orange, mango, banana, grape].\nfruits.remove(\"grape\") returns true, control goes inside if block and executes fruits.remove(\"papaya\");\nfruits list doesn't have \"papaya\", so the list remain unchanged. In the console, you get: [apple, orange, mango, banana, grape]."
      },
      {
        "id": 13,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Boolean> list = new ArrayList<>();\n        list.add(true);\n        list.add(new Boolean(\"tRue\"));\n        list.add(new Boolean(\"abc\"));\n \n        if(list.remove(1)) {\n            list.remove(1);\n        }\n \n        System.out.println(list);\n    }\n}",
        "options": [
          { "id": "A", "text": "[true, false]" },
          { "id": "B", "text": "[true]" },
          { "id": "C", "text": "[true, true]" },
          { "id": "D", "text": "IndexOutOfBoundsException" }
        ],
        "correctAnswers": ["B"],
        "explanation": "list.add(true); => Auto-boxing converts boolean literal true to Boolean instance containing true. Element at index 0 represents true.\nBoolean class code uses equalsIgnoreCase method to validate the passed String, so if passed String is \"true\" ('t', 'r', 'u' and 'e' can be in any case), then boolean value stored in Boolean object is true otherwise false.\nlist.add(new Boolean(\"tRue\")); => Element at index 1 represents true.\nlist.add(new Boolean(\"abc\")); => Element at index 2 represents false.\nSo initially list contains [true, true, false].\nAs generic list is used, so list.remove(1) removes the Boolean instance (true) stored at index 1 and returns it.\nSo after this operation list contains [true, false].\nFor the boolean expression of if-block, Java runtime extracts the stored boolean value using booleanValue() method, which returns true.\nControl goes inside if-block and executes list.remove(1);  This removes element at index 1 so after this operation list contains [true] and [true] is printed on to the console."
      },
      {
        "id": 14,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nimport java.util.function.Predicate;\n \npublic class Test {\n    public static void main(String[] args) {\n        printNumbers(i -> i % 2 != 0);\n    }\n \n    private static void printNumbers(Predicate<Integer> predicate) {\n        for(int i = 1; i <= 10; i++) {\n            if(predicate.test(i)) {\n                System.out.print(i);\n            }\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "12345678910" },
          { "id": "B", "text": "246810" },
          { "id": "C", "text": "13579" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "In the boolean expression (predicate.test(i)): i is of primitive int type but auto-boxing feature converts it to Integer wrapper type.\ntest(Integer) method of Predicate returns true if passed number is an odd number, so given loop prints only odd numbers.\nfor loops works for the numbers from 1 to 10."
      },
      {
        "id": 15,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate obj = new LocalDate(2020, 2, 14);\n        System.out.println(obj.minus(Period.ofDays(10)));\n    }\n}",
        "options": [
          { "id": "A", "text": "2020-02-04" },
          { "id": "B", "text": "2020-02-14" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Constructor of LocalDate is declared private so cannot be called from outside, hence new LocalDate(2020, 2, 14); causes compilation failure.\nOverloaded static methods \"of\" and \"parse\" are provided to create the instance of LocalDate.\nLocalTime, LocalDateTime, Period also specify private constructors and provide \"of\" and \"parse\" methods to create respective instances."
      },
      {
        "id": 16,
        "type": "multiple",
        "questionText": "Which 3 options, if used to replace /*INSERT*/, on execution will print 9 on to the console?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int [] arr = {1, 2, 3, 4, 5};\n        int x = 0;\n        for(/*INSERT*/) {\n            x += arr[n];\n        }\n        System.out.println(x);\n    }\n}",
        "options": [
          { "id": "A", "text": "int n = 0; n < arr.length; n += 2" },
          { "id": "B", "text": "int n = 1; n < arr.length; n += 2" },
          { "id": "C", "text": "int n = 0; n <= 4; n += 2" },
          { "id": "D", "text": "int n = 1; n < 5; n += 2" }
        ],
        "correctAnswers": ["A", "C"],
        "explanation": "Logic in for loop is adding array elements. You need to find out which array elements when added will result in 9. Possible options are: {1+3+5, 2+3+4, 4+5}.\n1+3+5 corresponds to indices 0, 2, 4. This matches option A (0, 2, 4) and C (0, 2, 4).\n2+3+4 corresponds to indices 1, 2, 3.\n4+5 corresponds to indices 3, 4."
      },
      {
        "id": 17,
        "type": "single",
        "questionText": "Which of the following statement is true?",
        "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \ninterface Sellable {}\nabstract class Animal {}\nclass Mammal extends Animal{}\nclass Rabbit extends Mammal implements Sellable{}\n \npublic class Test {\n    {\n        List<Animal> list = new ArrayList<>();\n        list.add(new Rabbit());\n    }\n    {\n        List<Animal> list = new ArrayList<>();\n        list.add(new Mammal());\n    }\n    {\n        List<Mammal> list = new ArrayList<>();\n        list.add(new Rabbit());\n    }\n    {\n        List<Sellable> list = new ArrayList<>();\n        list.add(new Mammal());\n    }\n    {\n        List<Sellable> list = new ArrayList<>();\n        list.add(new Rabbit());\n    }\n}",
        "options": [
          { "id": "A", "text": "Code compiles successfully" },
          { "id": "B", "text": "Compilation error in initializer block 4" },
          { "id": "C", "text": "Compilation error in initializer block 3" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Even though code seems to be checking the knowledge of ArrayList but it actually checks the knowledge of Polymorphism.\nList<Sellable> list = new ArrayList<>(); is valid statement and list can accept any object passing instanceof check for Sellable type.\nRabbit implements Sellable hence new Rabbit() can be added to list.\nBut as Mammal doesn't implement Sellable hence new Mammal() can't be added to list.\nOther initializer blocks can be verified on similar lines. So there is only one initializer block, which causes compilation error."
      },
      {
        "id": 18,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nclass Super {\n    public Super(int i) {\n        System.out.println(100);\n    }\n}\n \nclass Sub extends Super {\n    public Sub() {\n        System.out.println(200);\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new Sub();\n    }\n}",
        "options": [
          { "id": "A", "text": "100\n200" },
          { "id": "B", "text": "200\n100" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "super(); is added by the compiler as the first statement in both the constructors.\nClass Super extends from Object class and Object class has no-argument constructor, hence no issues with the constructor of Super class.\nBut no-arg constructor is not available in Super class, hence calling super(); from Sub class constructor gives compilation error."
      },
      {
        "id": 19,
        "type": "single",
        "questionText": "Which of the following is true for code below?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        byte [] arr = new byte[0];\n        System.out.println(arr[0]);\n    }\n}",
        "options": [
          { "id": "A", "text": "0" },
          { "id": "B", "text": "null" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "ArrayIndexOutOfBoundsException" }
        ],
        "correctAnswers": ["D"],
        "explanation": "arr refers to an array object of size 0. That means arr stores some memory address.\nSo we will not get NullPointerException in this case. But index 0 is not available for an array object of size 0 and thus ArrayIndexOutOfBoundsException is thrown at runtime."
      },
      {
        "id": 20,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Greetings class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Greetings {\n    String msg = null;\n \n    public Greetings() {\n        this(\"Good Morning!\");\n    }\n \n    public Greetings(String str) {\n        msg = str;\n    }\n \n    public void display() {\n        System.out.println(msg);\n    }\n \n    public static void main(String [] args) {\n        Greetings g1 = new Greetings();\n        Greetings g2 = new Greetings(\"Good Evening!\");\n        g1.display();\n        g2.display();\n    }\n}",
        "options": [
          { "id": "A", "text": "Good Morning!\nGood Evening!" },
          { "id": "B", "text": "Good Evening!\nGood Morning!" },
          { "id": "C", "text": "null\nGood Evening!" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Greetings g1 = new Greetings(); invokes no-arg constructor.\nNo-arg constructor calls parameterized constructor with the argument \"Good Morning!\"\nParameterized constructor assigns \"Good Morning!\" to msg variable of the object referred by g1.\nGreetings g2 = new Greetings(\"Good Evening!\"); invokes parameterized constructor, which assigns \"Good Evening!\"\nto msg variable of the object referred by g2.\ng1.display(); prints Good Morning!\ng2.display(); prints Good Evening!"
      },
      {
        "id": 21,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(1987, 9, 1);\n        String str = date.format(DateTimeFormatter.ISO_DATE_TIME);\n        System.out.println(\"Date is: \" + str);\n    }\n}",
        "options": [
          { "id": "A", "text": "Date is: 1987-09-01T00:00:00" },
          { "id": "B", "text": "Date is: 1987-09-01" },
          { "id": "C", "text": "UnsupportedTemporalTypeException" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "LocalDate object doesn't contain time part but ISO_DATE_TIME looks for time portion and throws exception at runtime.\nFor the OCA exam, you can check following DateTimeFormatter types: BASIC_ISO_DATE, ISO_DATE, ISO_LOCAL_DATE, ISO_TIME, ISO_LOCAL_TIME, ISO_DATE_TIME, ISO_LOCAL_DATE_TIME."
      },
      {
        "id": 22,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"SpaceStation\");\n        sb.delete(5, 6).insert(5, \" S\").toString().toUpperCase();\n        System.out.println(sb);\n    }\n}",
        "options": [
          { "id": "A", "text": "Space Station" },
          { "id": "B", "text": "SPACE STATION" },
          { "id": "C", "text": "SpaceStation" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "sb - > \"SpaceStation\"\nsb.delete(5, 6) -> \"Spacetation\"\nsb.insert(5, \" S\") -> \"Space Station\"\nsb.toString() -> Creates a new String object \"Space Station\"\n\"Space Station\".toUpperCase() -> Creates another String object \"SPACE STATION\" but the String object is not referred and used.\nMethod invocation on sb modifies the same object, so after insert(5, \" S\") method invocation sb refers to \"Space Station\" and this is printed to the Console."
      },
      {
        "id": 23,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        final int i1 = 1;\n        final Integer i2 = 1;\n        final String s1 = \":ONE\";\n \n        String str1 = i1 + s1;\n        String str2 = i2 + s1;\n \n        System.out.println(str1 == \"1:ONE\");\n        System.out.println(str2 == \"1:ONE\");\n    }\n}",
        "options": [
          { "id": "A", "text": "true\nfalse" },
          { "id": "B", "text": "true\ntrue" },
          { "id": "C", "text": "false\ntrue" },
          { "id": "D", "text": "false\nfalse" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution.\nCompile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.\nWhereas, Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.\nFor the statement,  String str1 = i1 + s1; , i1 is a final variable of int type and s1 is a final variable of String type.\nHence, `i1 + s1` is a constant expression which is computed at compile-time and results in String literal \"1:ONE\".\nThis means during compilation, Java compiler translates the statement\nString str1 = i1 + s1;\nto\nString str1 = \"1:ONE\";\nAs \"1:ONE\" is a String literal, hence at runtime it will be referred by String Pool.\nOn the other hand, for the statement,  String str2 = i2 + s1;\n, `i2 + s1` is not a constant expression because i2 is neither of primitive type nor of String type, hence it is computed at run-time and returns a non-pool String object \"1:ONE\".\nAs, str1 refers to String Pool object \"1:ONE\", hence `str1 == \"1:ONE\"` returns true, whereas str2 refers to non-Pool String object \"1:ONE\" and hence `str2 == \"1:ONE\"` returns false."
      },
      {
        "id": 24,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String fruit = new String(new char[] {'M', 'a', 'n', 'g', 'o'});\n        switch (fruit) {\n            default:\n                System.out.println(\"ANY FRUIT WILL DO\");\n            case \"Apple\":\n                System.out.println(\"APPLE\");\n            case \"Mango\":\n                System.out.println(\"MANGO\");\n            case \"Banana\":\n                System.out.println(\"BANANA\");\n                break;\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "MANGO\nBANANA" },
          { "id": "B", "text": "MANGO" },
          { "id": "C", "text": "ANY FRUIT WILL DO" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "fruit refers to String object \"Mango\". Matching case is available, MANGO is printed on to the console.\nNo break statement inside case \"Mango\":, hence control enters in fall-through and executes remaining blocks until the break;\nis found or switch block ends.\nSo in this case, it prints BANANA and break; statement takes control out of switch block.\nmain method ends and program terminates successfully."
      },
      {
        "id": 25,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2018-06-06\");\n        date.minusDays(10);\n        System.out.println(date);\n    }\n}",
        "options": [
          { "id": "A", "text": "2018-06-06" },
          { "id": "B", "text": "2018-05-27" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "date --> {2018-06-06}.\ndate.minusDays(10); => as LocalDate is immutable, hence a new LocalDate object is created {2018-05-27} but no variable refers to it.\ndate still refers to {2018-06-06}.\n2018-06-06 is displayed on to the console."
      },
      {
        "id": 26,
        "type": "single",
        "questionText": "Which of the following method definitions, if used to replace /*INSERT*/, will resolve the compilation error?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int [] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        System.out.println(process(arr, 3, 8)); //Line 5\n    }\n \n    /*INSERT*/\n}",
        "options": [
          { "id": "A", "text": "public static String process(int[] arr, int start, int end) { return null; }" },
          { "id": "B", "text": "public void process(int[] arr, int start, int end) { }" },
          { "id": "C", "text": "public static void process(int[] arr, int start, int end) { }" },
          { "id": "D", "text": "public static int process(int[] arr, int start, int end) { return 0; }" }
        ],
        "correctAnswers": ["A"],
        "explanation": "It is clear from Line 5 that, method name should be process, it should be static method, it should accept 3 parameters (int[], int, int).\nAs process(arr, 3, 8) is passed as an argument of System.out.println method, hence process method's return type can be anything apart from void.\nprintln method is overloaded to accept all primitive types, char [], String type and Object type.\nint[] are String [] are of Object type.\nIn the given options, method specifying int as return type cannot return null as null can't be assigned to primitive type.\nint process(...) would cause compilation error."
      },
      {
        "id": 27,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        for:\n        for (int i = 2; i <= 100; i = i + 2) {\n            for(int j = 1; j <= 10; j++) {\n                System.out.print(i * j + \"\\t\");\n            }\n            System.out.println();\n            if(i == 10) {\n                break for;\n            }\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "Prints multiplication table" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Infinite loop" }
        ],
        "correctAnswers": ["B"],
        "explanation": "for is a keyword and hence can't be used as a label.\nJava labels follow the identifier naming rules and one rule is that we can't use java keywords as identifier.\nHence, Compilation error."
      },
      {
        "id": 28,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Month;\nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2000, Month.JANUARY, 1);\n        Period period = Period.parse(\"p-30000y\");\n        System.out.println(date.plus(period));\n    }\n}",
        "options": [
          { "id": "A", "text": "-28000-01-01" },
          { "id": "B", "text": "2000-01-01" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "There are 2 of methods available in LocalDate class: of(int, int, int) and of(int, Month, int).\nMonth can either be passed as int value (1 to 12) or enum constants Month.JANUARY to Month.DECEMBER.\nPeriod.parse(CharSequence) method accepts the String parameter in \"PnYnMnD\" format, over here P,Y,M and D can be in any case.\n\"p-30000y\" means Period of -30000 years.\nThe minimum supported LocalDate is: {-999999999-01-01} and maximum supported LocalDate is: {+999999999-12-31}.\nIf period of -30000 years is added to 1st Jan 2000, then result is 1st Jan -28000."
      },
      {
        "id": 29,
        "type": "single",
        "questionText": "When does a class get the default constructor?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "Always" },
          { "id": "B", "text": "When no constructor is defined in the class" },
          { "id": "C", "text": "When declared as public" },
          { "id": "D", "text": "Never" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Default constructor (which is no-argument constructor) is added by Java compiler, only if there are no constructors in the class."
      },
      {
        "id": 30,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.io.FileNotFoundException;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            System.out.println(1);\n        } catch (NullPointerException ex) {\n            System.out.println(\"ONE\");\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"TWO\");\n        }\n        System.out.println(\"THREE\");\n    }\n}",
        "options": [
          { "id": "A", "text": "1\nTHREE" },
          { "id": "B", "text": "1\nTWO\nTHREE" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Java doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block.\ncatch(FileNotFoundException ex) {} causes  compilation error in this case as System.out.println(1); will never throw FileNotFoundException.\nNOTE: Java allows to catch Exception type. catch(Exception ex) {} will never cause compilation error."
      },
      {
        "id": 31,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(5);\n        sb.append(\"0123456789\");\n        sb.delete(8, 1000);\n        System.out.println(sb);\n    }\n}",
        "options": [
          { "id": "A", "text": "01234567" },
          { "id": "B", "text": "0123456789" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "StringIndexOutOfBoundsException" }
        ],
        "correctAnswers": ["A"],
        "explanation": "`new StringBuilder(5);` creates a StringBuilder instance, whose internal char array's length is 5 but the internal char array's length is adjusted when characters are added/removed from the StringBuilder instance.\n`sb.append(\"0123456789\");` successfully appends \"0123456789\" to the StringBuilder's instance referred by sb.\ndelete method accepts 2 parameters: delete(int start, int end), where start is inclusive and end is exclusive.\nThis method throws StringIndexOutOfBoundsException for following scenarios:\nA. start is negative\nB. start is greater than sb.length()\nC. start is greater than end\nIf end is greater than the length of StringBuilder object, then StringIndexOutOfBoundsException is not thrown and end is set to sb.length().\nSo, in this case, `sb.delete(8, 1000);` is equivalent to `sb.delete(8, sb.length());` and this deletes characters at 8th index (8) and 9th index (9).\nSo remaining characters are: \"01234567\".\nStringBuilder class overrides toString() method, which prints the text stored in StringBuilder instance.\nHence, `System.out.println(sb);` prints 01234567 on to the console."
      },
      {
        "id": 32,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> trafficLight = new ArrayList<>();\n        trafficLight.add(1, \"RED\");\n        trafficLight.add(2, \"ORANGE\");\n        trafficLight.add(3, \"GREEN\");\n \n        trafficLight.remove(new Integer(2));\n \n        System.out.println(trafficLight);\n    }\n}",
        "options": [
          { "id": "A", "text": "[RED, ORANGE, GREEN]" },
          { "id": "B", "text": "[RED, GREEN]" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "IndexOutOfBoundsException" }
        ],
        "correctAnswers": ["D"],
        "explanation": "There is no element at index 0 so call to add element at index 1, \"trafficLight.add(1, \"RED\");\"\nthrows an instance of java.lang.IndexOutOfBoundsException.\ntrafficLight.remove(new Integer(2)); matches with trafficLight.remove(Object) and hence no compilation error."
      },
      {
        "id": 33,
        "type": "single",
        "questionText": "For the given code, which option is correct?",
        "codeSnippet": "package com.udayan.oca;\n \ninterface I01 {\n    void m1();\n}\n \npublic class Implementer extends Object implements I01{\n    protected void m1() {\n \n    }\n}",
        "options": [
          { "id": "A", "text": "Compiles successfully" },
          { "id": "B", "text": "Compilation error due to method m1" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Code doesn't implement interface properly" }
        ],
        "correctAnswers": ["B"],
        "explanation": "void m1(); in interface I01 is equivalent to public abstract void m1(); So method m1() is implicitly public and abstract.\nIn java,  a class can extend from only one class but can implement multiple interfaces.\nCorrect keywords are: extends and implements.\nso class declaration is correct.\nAs method m1() is implicitly public in I01, hence overriding method in Implementer class should also be public.\nBut it is protected and hence compiler complains."
      },
      {
        "id": 34,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    static Boolean[] arr = new Boolean[1];\n    public static void main(String[] args) {\n        if(arr[0]) {\n            System.out.println(true);\n        } else {\n            System.out.println(false);\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "NullPointerException" }
        ],
        "correctAnswers": ["D"],
        "explanation": "All the array elements are initialized to their default values.\narr is of Boolean type (reference type), so arr[0] is initialized to null.\nif expression works with Boolean type variable, so \"if(arr[0])\" doesn't give compilation error but java runtime extracts the boolean value stored in arr[0] and it uses booleanValue() method.\narr[0].booleanValue() means booleanValue() method is invoked on null reference and hence NullPointerException is thrown at runtime."
      },
      {
        "id": 35,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int start = 1;\n        int sum = 0;\n        do {\n            if(start % 2 == 0) {\n                continue;\n            }\n            sum += start;\n        } while(++start <= 10);\n        System.out.println(sum);\n    }\n}",
        "options": [
          { "id": "A", "text": "25" },
          { "id": "B", "text": "30" },
          { "id": "C", "text": "55" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "When start is divisible by 2 [2, 4, 6, 8, 10], continue;\nstatement takes the control to boolean expression and hence sum += start; is not executed.\nHence result is the sum of numbers 1,3,5,7,9 (which is 25)."
      },
      {
        "id": 36,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate joiningDate = LocalDate.parse(\"2006-03-16\");\n        System.out.println(joiningDate.withDayOfYear(29));\n    }\n}",
        "options": [
          { "id": "A", "text": "2006-01-29" },
          { "id": "B", "text": "2006-03-29" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "joiningDate --> {2006-03-16}.\njoiningDate.withDayOfYear(29) returns a new LocalDate object with the day of the Year altered.\nA year has 365 days, so 29 means 29th day of the year, which is 29th Jan 2006.\nNOTE: There are other with methods, you should know for the exam. withDayOfMonth(int), withMonth(int) and withYear(int)."
      },
      {
        "id": 37,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(0, \"Array\");\n        list.set(0, \"List\");\n \n        System.out.println(list);\n    }\n}",
        "options": [
          { "id": "A", "text": "[Array, List]" },
          { "id": "B", "text": "[List]" },
          { "id": "C", "text": "[Array]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "list.add(0, \"Array\"); means list --> [Array],\nlist.set(0, \"List\"); means replace the current element at index 0 with the passed element \"List\".\nSo after this operation, list --> [List]. In the console, [List] is printed."
      },
      {
        "id": 38,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(100);\n        list.add(7);\n        list.add(50);\n        list.add(17);\n        list.add(10);\n        list.add(5);\n \n        list.removeIf(a -> a % 10 == 0);\n \n        System.out.println(list);\n    }\n}",
        "options": [
          { "id": "A", "text": "[100, 50, 10]" },
          { "id": "B", "text": "[7, 17, 5]" },
          { "id": "C", "text": "[100, 7, 50, 17, 10, 5]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "removeIf(Predicate) method was added as a default method in Collection interface in JDK 8 and it removes all the elements of this collection that satisfy the given predicate.\nPredicate's test method returns true for all the Integers divisible by 10."
      },
      {
        "id": 39,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2000-06-25\");\n        while(date.getDayOfMonth() >= 20) {\n            System.out.println(date);\n            date.plusDays(-1);\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "Prints date descending" },
          { "id": "B", "text": "Infinite loop" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Prints nothing" }
        ],
        "correctAnswers": ["B"],
        "explanation": "date --> {2000-06-25}. date.getDayOfMonth() = 25, 25 >= 20 is true, hence control goes inside while loop and executes System.out.println(date);\nstatement.\ndate.plusDays(-1); creates a new LocalDate object {2000-06-24} but date reference variable still refers to {2000-06-25}.\ndate.getDayOfMonth() again returns 25, this is an infinite loop."
      },
      {
        "id": 40,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String msg = \"Hello\";\n        boolean [] flag = new boolean[1];\n        if(flag[0]) {\n            msg = \"Welcome\";\n        }\n        System.out.println(msg);\n    }\n}",
        "options": [
          { "id": "A", "text": "Hello" },
          { "id": "B", "text": "Welcome" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "NullPointerException" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Variable msg is referring to String object \"Hello\".\nThere is only one element in boolean array object and it is initialized to default value of boolean, which is false.\nflag[0] is false, if-check fails and control doesn't enter if block.\nSystem.out.println(msg) prints original value of msg, which is \"Hello\"."
      },
      {
        "id": 41,
        "type": "single",
        "questionText": "Given the code:\nWhen is the Pen object, created at Line 1 eligible for Garbage Collection?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Pen {\n    public static void main(String[] args) {\n        Pen p1 = new Pen(); //Line 1\n        Pen p2 = new Pen(); //Line 2\n        p1 = p2; //Line 3\n        p1 = null; //Line 4\n    }\n}",
        "options": [
          { "id": "A", "text": "After Line 1" },
          { "id": "B", "text": "After Line 3" },
          { "id": "C", "text": "After Line 4" },
          { "id": "D", "text": "Never" }
        ],
        "correctAnswers": ["B"],
        "explanation": "At Line 3, p1 starts referring to the object referred by p2(Created at Line 2).\nSo, after Line 3, object created at Line 1 becomes unreachable and thus eligible for Garbage Collection."
      },
      {
        "id": 42,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(110);\n        list.add(new Integer(110));\n        list.add(110);\n \n        list.removeIf(i -> i == 110);\n        System.out.println(list);\n    }\n}",
        "options": [
          { "id": "A", "text": "[]" },
          { "id": "B", "text": "[110]" },
          { "id": "C", "text": "[110, 110]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "As list can store only wrapper objects and not primitives, hence\nfor list.add(110); auto-boxing creates an Integer object {110}.\nfor list.add(new Integer(110)); as new keyword is used so another Integer object {110} is created.\nfor 3rd add method call, list.add(110); auto-boxing kicks in and as 110 is between -128 to 127, hence Integer object created at 1st statement is referred.\nremoveIf(Predicate) method was added as a default method in Collection interface in JDK 8 and it removes all the elements of this collection that satisfy the given predicate.\nBoolean expression is : i == 110; in this expression i is wrapper object and 110 is int literal so java extracts int value of wrapper object, i and then equates.\nAs all the 3 objects store 110, hence true is returned. All integer objects are removed form the list.\nIf list.removeIf(i -> i == new Integer(110)); was used, then all three list elements would return false as object references are equated and not contents."
      },
      {
        "id": 43,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test extends String {\n    @Override\n    public String toString() {\n        return \"TEST\";\n    }\n \n    public static void main(String[] args) {\n        Test obj = new Test();\n        System.out.println(obj);\n    }\n}",
        "options": [
          { "id": "A", "text": "TEST" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "String" }
        ],
        "correctAnswers": ["B"],
        "explanation": "String is a final class so it cannot be extended."
      },
      {
        "id": 44,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void change(int num) {\n        num++;\n        System.out.println(num);\n    }\n \n    public static void main(String[] args) {\n        int i1 = 1;\n        Test.change(i1);\n        System.out.println(i1);\n    }\n}",
        "options": [
          { "id": "A", "text": "2\n1" },
          { "id": "B", "text": "2\n2" },
          { "id": "C", "text": "1\n1" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "There are no compilation errors and main(String[]) method is invoked on executing Test class.\ni1 = 1. `Test.change(i1)` is executed next, contents of i1 (which is 1) is copied to the variable 'num' and method change(int) starts executing.\n`num++;` increments the value of num by 1, num = 2. There are no changes to the value of variable 'i1' of main(String[]) method, which still contains 1. `System.out.println(num);` prints 2 on to the console.\nchange(int) method finishes its execution and control goes back to the main(String[]) method. `System.out.println(i1);` prints 1 on to the console."
      },
      {
        "id": 45,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Error obj = new Error();\n        boolean flag1 = obj instanceof RuntimeException; //Line n1\n        boolean flag2 = obj instanceof Exception; //Line n2\n        boolean flag3 = obj instanceof Error; //Line n3\n        boolean flag4 = obj instanceof Throwable; //Line n4\n        System.out.println(flag1 + \":\" + flag2 + \":\" + flag3 + \":\" + flag4);\n    }\n}",
        "options": [
          { "id": "A", "text": "true:true:true:true" },
          { "id": "B", "text": "false:false:true:true" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "class Error extends Throwable, so `obj instanceof Error;` and `obj instanceof Throwable;` return true.\nBut Error class is not related to Exception and RuntimeException classes in multilevel inheritance and that is why Line n1 and Line n2 causes compilation error."
      },
      {
        "id": 46,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nclass Point {\n    static int x;\n    private int y;\n \n    public String toString() {\n        return \"Point(\" + x + \", \" + y + \")\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Point p1 = new Point();\n        p1.x = 100;\n        p1.y = 200;\n        Point p2 = new Point();\n        p2.x = 100;\n        p2.y = 200;\n        System.out.println(p1);\n    }\n}",
        "options": [
          { "id": "A", "text": "Point(100, 200)" },
          { "id": "B", "text": "Point(100, 0)" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Variable y is private so it cannot be accessed outside the boundary of Point class.\np1.y and p2.y used inside Test class, cause the compilation error."
      },
      {
        "id": 47,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int [] arr1 = {5, 10, 15};\n        int [] arr2 = {'A', 'B'};\n        arr1 = arr2;\n        System.out.println(arr1.length + arr2.length);\n    }\n}",
        "options": [
          { "id": "A", "text": "4" },
          { "id": "B", "text": "5" },
          { "id": "C", "text": "6" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Initially arr1 refers to an int array object of 3 elements.\nAnd arr2 refers to an int array object of 2 elements [char type is compatible with int type] When the statement `arr1 = arr2;` executes, variable arr1 copies the content of arr2, which is the address of array object containing 2 elements.\nHence, arr1 also starts referring to same array object. arr1.length = 2 and arr2.length = 2. Therefore, output is: 4"
      },
      {
        "id": 48,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nclass Base {\n    public void m1() throws NullPointerException {\n        System.out.println(\"Base: m1()\");\n    }\n}\n \nclass Derived extends Base {\n    public void m1() throws RuntimeException {\n        System.out.println(\"Derived: m1()\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base obj = new Derived();\n        obj.m1();\n    }\n}",
        "options": [
          { "id": "A", "text": "Derived: m1()" },
          { "id": "B", "text": "Base: m1()" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "NullPointerException extends RuntimeException, but there are no overriding rules related to unchecked exceptions.\nSo, method m1() in Derived class correctly overrides Base class method. Rest is simple polymorphism.\nobj refers to an instance of Derived class and hence obj.m1();\ninvokes method m1() of Derived class, which prints \"Derived: m1()\" to the console."
      },
      {
        "id": 49,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<StringBuilder> dryFruits = new ArrayList<>();\n        dryFruits.add(new StringBuilder(\"Walnut\"));\n        dryFruits.add(new StringBuilder(\"Apricot\"));\n        dryFruits.add(new StringBuilder(\"Almond\"));\n        dryFruits.add(new StringBuilder(\"Date\"));\n \n        for(int i = 0; i < dryFruits.size(); i++)\n        {\n            if(i == 0) {\n                dryFruits.remove(new StringBuilder(\"Almond\"));\n            }\n        }\n \n        System.out.println(dryFruits);\n    }\n}",
        "options": [
          { "id": "A", "text": "[Walnut, Apricot, Almond, Date]" },
          { "id": "B", "text": "[Walnut, Apricot, Date]" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "ConcurrentModificationException" }
        ],
        "correctAnswers": ["A"],
        "explanation": "In this example, code is trying to remove an item from the list while iterating using traditional for loop so one can think that this code would throw java.util.ConcurrentModificationException.\nBut note, java.util.ConcurrentModificationException will never be thrown for traditional for loop.\nIt is thrown for for-each loop or while using Iterator/ListIterator. In this case dryFruits.remove(new StringBuilder(\"Almond\"));\nwill never remove any items from the list as StringBuilder class doesn't override the equals(Object) method of Object class.\nStringBuilder instances created at \"dryFruits.add(new StringBuilder(\"Almond\"));\" and \"dryFruits.remove(new StringBuilder(\"Almond\"));\" are at different memory locations and equals(Object) method returns false for these instances."
      },
      {
        "id": 50,
        "type": "multiple",
        "questionText": "Consider below Lambda expression: Predicate predicate = s -> true;\nWhich of the lambda expression can successfully replace the lambda expression in above statement?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "(s) -> true" },
          { "id": "B", "text": "(String s) -> { return true; }" },
          { "id": "C", "text": "s -> { return true; }" },
          { "id": "D", "text": "All of the above" }
        ],
        "correctAnswers": ["D"],
        "explanation": "In the lambda expression's body, if used, all 3 [return, {}, ;] must be used together."
      },
      {
        "id": 51,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    private static void m1() {\n        System.out.println(1/0);\n    }\n \n    public static void main(String[] args) {\n        try {\n            m1();\n        } finally {\n            System.out.println(\"A\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "A followed by ArithmeticException" },
          { "id": "B", "text": "ArithmeticException followed by A" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "A" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Method m1() throws an instance of ArithmeticException and method m1() doesn't handle it, so it forwards the exception to calling method main.\nMethod main doesn't handle ArithmeticException so it forwards it to JVM, but just before that finally block is executed.\nThis prints A on to the console. After that JVM prints the stack trace and terminates the program abruptly."
      },
      {
        "id": 52,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Boolean b = new Boolean(\"tRUe\");\n        switch(b) {\n            case true:\n                System.out.println(\"ONE\");\n            case false:\n                System.out.println(\"TWO\");\n            default:\n                System.out.println(\"THREE\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "ONE" },
          { "id": "B", "text": "ONE\nTWO\nTHREE" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "THREE" }
        ],
        "correctAnswers": ["C"],
        "explanation": "switch can accept primitive types: byte, short, int, char;\nwrapper types: Byte, Short, Integer, Character; String and enums. switch(b) causes compilation failure as b is of Boolean type."
      },
      {
        "id": 53,
        "type": "single",
        "questionText": "Which one of these top level classes cannot be sub-classed?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "final class" },
          { "id": "B", "text": "abstract class" },
          { "id": "C", "text": "public class" },
          { "id": "D", "text": "default class" }
        ],
        "correctAnswers": ["A"],
        "explanation": "class Dog {}: can be sub-classed within the same package.\nabstract class Cat {}: can be sub-classed within the same package.\nfinal class Electronics {}: a class with final modifier cannot be sub-classed.\nprivate class Car {}: a top level class cannot be declared with private modifier."
      },
      {
        "id": 54,
        "type": "single",
        "questionText": "Which of the following javac command, typed from above location, will generate Exam.class file structure under classes directory?",
        "codeSnippet": "package com.udayan.test;\n \npublic class Exam {\n    public static void main(String [] args) {\n        System.out.println(\"All the best!\");\n    }\n}\n// Location: D:\\WORK\\QUIZ\\SEC07\\src\\com\\udayan\\test\\Exam.java\n// Current dir: D:\\WORK\\Quiz\\Sec07>",
        "options": [
          { "id": "A", "text": "javac -d classes src\\com\\udayan\\test\\Exam.java" },
          { "id": "B", "text": "javac src\\com\\udayan\\test\\Exam.java" },
          { "id": "C", "text": "javac -d . src\\com\\udayan\\test\\Exam.java" },
          { "id": "D", "text": "javac Exam.java" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Use -d option with javac command.\nAs you are typing javac command from within Sec07 directory, hence path of java file relative to Sec07 directory needs to be given.\nSo, correct command is: javac -d classes\\ src\\com\\udayan\\test\\Exam.java"
      },
      {
        "id": 55,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = new String[1];\n        System.out.println(arr[0].isEmpty());\n    }\n}",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "NullPointerException" }
        ],
        "correctAnswers": ["D"],
        "explanation": "All the elements of array are initialized to respective zeros (in case of primitive type) or null (in case of reference type).\nSo, arr[0] refers to null. Method 'isEmpty()' is invoked on null reference and hence NullPointerException is thrown at runtime."
      },
      {
        "id": 56,
        "type": "single",
        "questionText": "What will be the result of compiling and executing TestStudent class?",
        "codeSnippet": "//TestStudent.java\npackage com.udayan.oca;\n \nclass Student {\n    String name;\n    int age;\n    boolean result;\n    double height;\n}\n \npublic class TestStudent {\n    public static void main(String[] args) {\n        Student stud = new Student();\n        System.out.println(stud.name + stud.height + stud.result + stud.age);\n    }\n}",
        "options": [
          { "id": "A", "text": "null0.0false0" },
          { "id": "B", "text": "null 0.0 false 0" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "name, height, result and age are instance variables of Student class.\nAnd instance variables are initialized to their respective default values.\nname is initialized to null, age to 0, result to false and height to 0.0.\nStatement System.out.println(stud.name + stud.height + stud.result + stud.age); prints null0.0false0"
      },
      {
        "id": 57,
        "type": "single",
        "questionText": "Which of the following statement declares a constant field in Java?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "final" },
          { "id": "B", "text": "static" },
          { "id": "C", "text": "const" },
          { "id": "D", "text": "volatile" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Fields declared with final are constant fields."
      },
      {
        "id": 58,
        "type": "single",
        "questionText": "How many blocks can replace /*INSERT*/ such that output is: [100, 100, 100]?",
        "codeSnippet": "//Counter.java\npackage com.udayan.oca;\npublic class Counter {\n    public int count = 0;\n    public Counter(int start) { count = start; }\n    public int getCount() { return count; }\n    public void increase(int val) { count = count + val; }\n    public String toString() { return this.count + \"\"; }\n}\n//Test.java\npackage com.udayan.oca.test;\nimport java.util.Arrays;\nimport com.udayan.oca.Counter;\npublic class Test {\n    public static void main(String[] args) {\n        Counter[] arr = new Counter[] { new Counter(-1000), new Counter(539), new Counter(0) };\n        /* INSERT */\n        System.out.println(Arrays.toString(arr));\n    }\n}\n/* Blocks:\n1. for(Counter ctr : arr) { ctr.count = 100; }\n2. for (Counter ctr : arr) { int x = ctr.getCount(); x = 100; }\n3. for (Counter ctr : arr) { ctr.getCount() = 100; }\n4. for(Counter ctr : arr) { ctr.increase(100 - ctr.count); }\n5. for (Counter ctr : arr) { ctr.increase(100 - ctr.getCount()); }\n6. for(Counter ctr : arr) { ctr.increase(-ctr.getCount() + 100); }\n7. for(Counter ctr : arr) { ctr.increase(-ctr.count + 100); }\n*/",
        "options": [
          { "id": "A", "text": "3" },
          { "id": "B", "text": "4" },
          { "id": "C", "text": "5" },
          { "id": "D", "text": "6" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Blocks 1, 4, 5, 6, 7 work.\nBlock 2 modifies local variable x.\nBlock 3 causes compilation error (assignment to value)."
      },
      {
        "id": 59,
        "type": "single",
        "questionText": "Which of the following options, if used to replace /*INSERT*/, compiles successfully?",
        "codeSnippet": "public static void process(/*INSERT*/ list) {\n    list.add(100); //Line 2\n    int x = list.get(0); //Line 3\n    System.out.println(list.size() + \":\" + x);\n}",
        "options": [
          { "id": "A", "text": "List<Integer>" },
          { "id": "B", "text": "List<int>" },
          { "id": "C", "text": "List<Object>" },
          { "id": "D", "text": "List" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Generic type can only be reference type and not primitive type, hence List<int> is not a valid syntax.\nIf you use raw type List or List<Object> then Line 3 will give compilation error as list.get(0) will return Object type.\nObject type cannot be converted to primitive type int, so List and List<Object> will cause compilation failure of Line 3. List<Integer> is the only correct option left."
      },
      {
        "id": 60,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        m(1);\n    }\n    private static void m(Object obj) {\n        System.out.println(\"Object version\");\n    }\n    private static void m(Number obj) {\n        System.out.println(\"Number version\");\n    }\n    private static void m(Double obj) {\n        System.out.println(\"Double version\");\n    }\n}",
        "options": [
          { "id": "A", "text": "Number version" },
          { "id": "B", "text": "Object version" },
          { "id": "C", "text": "Double version" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "There are 3 overloaded method m.\nNote all the numeric wrapper classes (Byte, Short, Integer, Long, Float and Double) extend from Number and Number extends from Object.\nCompiler either does implicit casting or Wrapping but not both.\n1 is int literal, Java compiler can't implicit cast it to double and then box it to Double rather it boxes i to Integer and as Number is the immediate super class of Integer so Number version refers to Integer object.\nNumber version is printed on to the console."
      },
      {
        "id": 61,
        "type": "single",
        "questionText": "Does below code compile successfully?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        System.out.println(\"Hello\");;;;;;;;;\n    }\n}",
        "options": [
          { "id": "A", "text": "Yes" },
          { "id": "B", "text": "No" }
        ],
        "correctAnswers": ["A"],
        "explanation": "In java, it is allowed to put multiple statements on one line.\nEmpty statements (just the semicolon) are also allowed in java, therefore below code is legal."
      },
      {
        "id": 62,
        "type": "multiple",
        "questionText": "Which of the following correctly imports Animal class from com.masaimara package?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "import com.masaimara.*;" },
          { "id": "B", "text": "import com.masaimara.Animal;" },
          { "id": "C", "text": "import com.masaimara.Animal.*;" },
          { "id": "D", "text": "import com.masaimara;" }
        ],
        "correctAnswers": ["A", "B"],
        "explanation": "Following import statements are correct:  import com.masaimara.*;  import com.masaimara.Animal;\nNOTE: all small case letters in import keyword."
      },
      {
        "id": 63,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"Good\"; //Line 3\n        change(str); //Line 4\n        System.out.println(str); //Line 5\n    }\n    private static void change(String s) {\n        s.concat(\"_Morning\"); //Line 9\n    }\n}",
        "options": [
          { "id": "A", "text": "Good" },
          { "id": "B", "text": "Good_Morning" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "When change(String) method is called, both variable s and str refers to same String object.\nLine 9 doesn't modify the passed object instead creates a new String object \"Good_Morning\".\nBut this newly created object is not referred and hence is a candidate for GC.\nWhen control goes back to calling method main(String[]), str still refers to \"Good\".\nLine 5 prints \"Good\" on to the console."
      },
      {
        "id": 64,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2020, 9, 6);\n        System.out.println(date);\n    }\n}",
        "options": [
          { "id": "A", "text": "2020-09-06" },
          { "id": "B", "text": "2020-9-6" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "In LocalDate.of(int, int, int) method, 1st parameter is year, 2nd is month and 3rd is day of the month.\ntoString() method of LocalDate class prints the LocalDate object in ISO-8601 format: \"uuuu-MM-dd\"."
      },
      {
        "id": 65,
        "type": "single",
        "questionText": "For the class Apple, which option, if used to replace /*INSERT*/, will print GREEN on to the console?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Apple {\n    public String color;\n    public Apple(String color) {\n        /*INSERT*/\n    }\n    public static void main(String [] args) {\n        Apple apple = new Apple(\"GREEN\");\n        System.out.println(apple.color);\n    }\n}",
        "options": [
          { "id": "A", "text": "this.color = color;" },
          { "id": "B", "text": "color = color;" },
          { "id": "C", "text": "color = \"GREEN\";" },
          { "id": "D", "text": "this.color = \"GREEN\";" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Instance variable color is shadowed by the parameter variable color of parameterized constructor.\nSo, color = color will have no effect, because short hand notation within constructor body will always refer to LOCAL variable.\nTo refer to instance variable, this reference is needed. Hence 'this.color = color;' is correct. 'color = GREEN;' and 'this.color = GREEN;' cause compilation error as GREEN is not within double quotes(\"\"). NOTE: 'color = \"GREEN\";' will only assign 'GREEN' to local variable and not instance variable but 'this.color = \"GREEN\";' will assign 'GREEN' to instance variable."
      },
      {
        "id": 66,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int i = 5;\n        if(i++ < 6) {\n            System.out.println(i++);\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "6" },
          { "id": "B", "text": "5" },
          { "id": "C", "text": "7" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Initially i = 5. if(i++ < 6) means if(5 < 6) and then i = 6. 5 < 6 is true, control goes inside if-block and executes System.out.println(i++);\nThis prints current value of i to the console, which is 6 and after that increments the value of i by 1, so i becomes 7."
      },
      {
        "id": 67,
        "type": "single",
        "questionText": "What will be the result of compiling and executing following program?",
        "codeSnippet": "package com.udayan.oca;\n \nclass Rectangle {\n    private int height;\n    private int width;\n    public Rectangle(int height, int width) {\n        this.height = height;\n        this.width = width;\n    }\n    public int getHeight() { return height; }\n    public int getWidth() { return width; }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        private int i = 100;\n        private int j = 200;\n        Rectangle rect = new Rectangle(i, j);\n        System.out.println(rect.getHeight() + \", \" + rect.getWidth());\n    }\n}",
        "options": [
          { "id": "A", "text": "100, 200" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "0, 0" }
        ],
        "correctAnswers": ["B"],
        "explanation": "i and j cannot be declared private as i and j are local variables.\nOnly final modifier can be used with local variables."
      },
      {
        "id": 68,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \nclass Student {\n    private String name;\n    private int age;\n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String toString() {\n        return \"Student[\" + name + \", \" + age + \"]\";\n    }\n    public boolean equals(Student obj) {\n        if(obj instanceof Student) {\n            Student stud = (Student)obj;\n            if(this.name.equals(stud.name) && this.age == stud.age) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>();\n        students.add(new Student(\"James\", 25));\n        students.add(new Student(\"James\", 27));\n        students.add(new Student(\"James\", 25));\n        students.add(new Student(\"James\", 25));\n        students.remove(new Student(\"James\", 25));\n        for(Student stud : students) {\n            System.out.println(stud);\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "Prints 4 students" },
          { "id": "B", "text": "Prints 3 students" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Before you answer this, you must know that there are 5 different Student object created in the memory (4 at the time of adding to the list and 1 at the time of removing from the list).\nThis means these 5 Student objects will be stored at different memory addresses.\nremove(Object) method removes the first occurrence of matching object and equals(Object) method decides whether 2 objects are equal or not.\nequals(Object) method has NOT been overridden by the Student class. In fact, equals(Student) is overloaded.\nBut overloaded version is not invoked while equating the Student objects.\nequals(Object) method defined in Object class is invoked and equals(Object) method defined in Object class uses == operator to check the equality and in this case as all the Student objects are stored at different memory location, hence not equal.\nNothing is removed from the students list, all the 4 Student objects are printed in the insertion order."
      },
      {
        "id": 69,
        "type": "single",
        "questionText": "Which of the following statement is correct for below code?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        final boolean flag = false;\n        while(flag) {\n            System.out.println(\"Good Morning!\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "Compilation error" },
          { "id": "B", "text": "Prints nothing" },
          { "id": "C", "text": "Prints Good Morning!" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "final boolean flag = false; statement makes flag a compile time constant.\nCompiler knows the value of flag, which is false at compile time and hence it gives \"Unreachable Code\" error."
      },
      {
        "id": 70,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        for(int i=0; i<=2; i++){}\n        System.out.println(i);\n    }\n}",
        "options": [
          { "id": "A", "text": "3" },
          { "id": "B", "text": "2" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Variable i is declared inside for loop, hence it is not accessible beyond loop's body.\nSystem.out.println(i); causes compilation error."
      }
    ]},
  {
    "id": 4,
    "name": "OCA Practice Exam 4",
    "description": "Set 4",
    "questions": [
      {
        "id": 1,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String fName = \"James\";\n        String lName = \"Gosling\";\n        System.out.println(fName = lName);\n    }\n}",
        "options": [
          { "id": "A", "text": "James" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "true" },
          { "id": "D", "text": "None of the other options" }
        ],
        "correctAnswers": ["D"],
        "explanation": "Both fName and lName are of reference type. fName refers to \"James\" and lName refers to \"Gosling\". \n In System.out.println() statement, we have used assignment operator (=) and not equality operator (==). So result is never boolean. \n fName = lName means copy the contents of lName to fName. \n As lName is referring to \"Gosling\" and so after the assignment, fName starts referring to \"Gosling\" as well. \n System.out.println() finally prints the String referred by fName, which is \"Gosling\". \n This option is is not available, hence correct answer is \"None of the other options\"."
      },
      {
        "id": 2,
        "type": "single",
        "questionText": "Given the following definitions of the class Insect and the interface Flyable, the task is to declare a class Mosquito that inherits from the class Insect and implements the interface Flyable.",
        "codeSnippet": "class Insect {}\ninterface Flyable {}",
        "options": [
          { "id": "A", "text": "class Mosquito extends Insect implements Flyable {}" },
          { "id": "B", "text": "class Mosquito implements Flyable extends Insect {}" },
          { "id": "C", "text": "class Mosquito extends Insect, Flyable {}" },
          { "id": "D", "text": "class Mosquito implements Insect, Flyable {}" }
        ],
        "correctAnswers": ["A"],
        "explanation": "A class in Java extends class and implements interface. "
      },
      {
        "id": 3,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n \n    private static void add(double d1, double d2) {\n        System.out.println(\"double version: \" + (d1 + d2));\n    }\n \n    private static void add(Double d1, Double d2) {\n        System.out.println(\"Double version: \" + (d1 + d2));\n    }\n \n    public static void main(String[] args) {\n        add(10.0, new Double(10.0));\n    }\n \n}",
        "options": [
          { "id": "A", "text": "double version: 20.0" },
          { "id": "B", "text": "Double version: 20.0" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "An exception is thrown at runtime" }
        ],
        "correctAnswers": ["C"],
        "explanation": "add(10.0, new Double(10.0)); is an ambiguous call as compiler can't decide whether to convert 1st argument to Double reference type or 2nd argument to double primitive type. \n So, add(10.0, new Double(10.0)); causes compilation error. "
      },
      {
        "id": 4,
        "type": "single",
        "questionText": "DateTimeFormatter is defined inside which package?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "java.time" },
          { "id": "B", "text": "java.time.format" },
          { "id": "C", "text": "java.util" },
          { "id": "D", "text": "java.time.chrono" }
        ],
        "correctAnswers": ["B"],
        "explanation": "DateTimeFormatter is a part of \"java.time.format\" package, whereas LocalDate, LocalTime, LocalDateTime and Period are defined inside \"java.time\" package. "
      },
      {
        "id": 5,
        "type": "single",
        "questionText": "Predict Output, if the above code is run with given command: java Test",
        "codeSnippet": "public class Test {\n    private static int [] arr;\n    public static void main(String [] args) {\n        if(arr.length > 0 && arr != null) {\n            System.out.println(arr[0]);\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "0" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "NullPointerException is thrown at runtime" },
          { "id": "D", "text": "No output" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Variable arr is a class variable of int [] type, so by default it is initialized to null. \n In if block, arr.length > 0 is checked first. Accessing length property on null reference throws NullPointerException. \n Correct logical if block declaration should be: if(arr != null && arr.length > 0)\n. First check for null and then access properties/methods. "
      },
      {
        "id": 6,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    static String msg; //Line 2\n    public static void main(String[] args) {\n        String msg; //Line 4\n        if(args.length > 0) {\n            msg = args[0]; //Line 6\n        }\n        System.out.println(msg); //Line 8\n    }\n}",
        "options": [
          { "id": "A", "text": "null" },
          { "id": "B", "text": "Compilation error at Line 6" },
          { "id": "C", "text": "Line 8 causes compilation failure" },
          { "id": "D", "text": "Prints first command line argument" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Line 4 code shadows the variable at Line 2. msg variable created at Line 4 is a local variable and should be initialized before it is used. \n Initialization code is inside if-block, so compiler is not sure about msg variable's initialization. Hence, Line 8 causes compilation failure. "
      },
      {
        "id": 7,
        "type": "single",
        "questionText": "What will be the result of compiling and executing DivModTest class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class DivModTest {\n    public static void main(String[] args) {\n        System.out.println( 23 / 2.0 );\n        System.out.println( 23 % 2.0 );\n    }\n}",
        "options": [
          { "id": "A", "text": "11\n1" },
          { "id": "B", "text": "11.5\n1.0" },
          { "id": "C", "text": "11.5\n1" },
          { "id": "D", "text": "11\n1.0" }
        ],
        "correctAnswers": ["B"],
        "explanation": "As floating point numbers are used in the expression, hence result should be in floating point number. \n Correct result is: 23 / 2.0 = 11.5 \n and 23 % 2.0 = 1.0."
      },
      {
        "id": 8,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> days = new ArrayList<>();\n        days.add(\"SUNDAY\");\n        days.add(\"SUNDAY\");\n        days.add(\"MONDAY\");\n        System.out.println(days.size());\n        days.clear();\n        System.out.println(days.size());\n    }\n}",
        "options": [
          { "id": "A", "text": "2\n0" },
          { "id": "B", "text": "3\n3" },
          { "id": "C", "text": "3\n0" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "ArrayList can have duplicate elements, so after addition, list is: [SUNDAY, SUNDAY, MONDAY]. \n days.size() returns 3 so 3 is printed on to the console. \n days.clear(); removes all the elements from the days list\n. So 2nd System.out.println statement prints 0 on to the console. "
      },
      {
        "id": 9,
        "type": "single",
        "questionText": "For the code below, what should be the name of java file?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class HelloWorld {\n    public static void main(String [] args) {\n        System.out.println(\"Hello World!\");\n    }\n}",
        "options": [
          { "id": "A", "text": "helloworld.java" },
          { "id": "B", "text": "HelloWorld.java" },
          { "id": "C", "text": "HelloWorld.class" },
          { "id": "D", "text": "Any name is fine" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Java is case sensitive language. File name should match with public class's name, which is \"HelloWorld\". \n \"helloworld\" is different from \"HelloWorld\". "
      },
      {
        "id": 10,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//A.java, B.java, C.java, Test.java\npublic class Test {\n    public static void main(String[] args) {\n        A obj1 = new C();\n        A obj2 = new B();\n        C obj3 = (C)obj1;\n        C obj4 = (C)obj2;\n        obj3.print();\n    }\n}",
        "options": [
          { "id": "A", "text": "C" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "ClassCastException is thrown at runtime" },
          { "id": "D", "text": "A" }
        ],
        "correctAnswers": ["C"],
        "explanation": "C obj4 = (C)obj2; => obj2 actually refers to an instance of B class, so at runtime obj4 (C type) will refer to an instance of B class. \n B and C are siblings and can't refer to each other, so this statement will throw ClassCastException at runtime. "
      },
      {
        "id": 11,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"A\", \"B\", \"C\", \"D\"};\n        arr[0] = arr[1];\n        arr[1] = \"E\";\n        for(String s : arr) {\n            System.out.print(s + \" \");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "A B C D" },
          { "id": "B", "text": "B B C D" },
          { "id": "C", "text": "B E C D" },
          { "id": "D", "text": "A E C D" }
        ],
        "correctAnswers": ["C"],
        "explanation": "arr[0] -> \"A\" and arr[1] -> \"B\". \n arr[0] = arr[1]; => arr[0] -> \"B\" and arr[1] -> \"B\". \n arr[1] = \"E\"; => arr[0] -> \"B\" and arr[1] -> \"E\". \n Hence output is: B E C D."
      },
      {
        "id": 12,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int [] arr1 = {1, 2, 3};\n        char [] arr2 = {'A', 'B'};\n        arr1 = arr2;\n        for(int i = 0; i < arr1.length; i++) {\n            System.out.print(arr1[i] + \" \");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "65 66" },
          { "id": "B", "text": "1 2 3" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "An exception is thrown at runtime" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Statement arr1 = arr2; gives compilation error as char [] is not compatible with int [] even though char is compatible with int. "
      },
      {
        "id": 13,
        "type": "single",
        "questionText": "For the class Test, which option, if used to replace /*INSERT*/, will print \"Lucky no. 7\" on to the console?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        /*INSERT*/\n        switch(var) {\n            case '7':\n                System.out.println(\"Lucky no. 7\");\n                break;\n            default:\n                System.out.println(\"DEFAULT\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "int var = 7;" },
          { "id": "B", "text": "Integer var = 7;" },
          { "id": "C", "text": "int var = '7';" },
          { "id": "D", "text": "char var = 7;" }
        ],
        "correctAnswers": ["C"],
        "explanation": "int var = '7'; => Lucky no. 7 \n. char '7' cannot be converted to Integer, so Integer var = '7' causes compilation error \n. case '7' can easily be compared with int value but not with Integer type."
      },
      {
        "id": 14,
        "type": "single",
        "questionText": "What will be the result if Test class is executed by below command: java Test 10",
        "codeSnippet": "public class Test {\n    public static void main(String[] args) {\n        System.out.println(\"ONE\");\n    }\n \n    public static void main(Integer[] args) {\n        System.out.println(\"TWO\");\n    }\n \n    public static void main(byte [] args) {\n        System.out.println(\"THREE\");\n    }\n}",
        "options": [
          { "id": "A", "text": "ONE" },
          { "id": "B", "text": "TWO" },
          { "id": "C", "text": "THREE" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Like any other method, main method can also be overloaded. \n But main method called by JVM is always with String [] parameter. \n Run above class with any command line arguments or 0 command line argument, output will always be ONE. "
      },
      {
        "id": 15,
        "type": "single",
        "questionText": "On execution, does Test class print \"HELLO\" on to the console?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    static Double d1;\n    int x = d1.intValue();\n \n    public static void main(String[] args) {\n        System.out.println(\"HELLO\");\n    }\n}",
        "options": [
          { "id": "A", "text": "Yes, HELLO is printed on to the console" },
          { "id": "B", "text": "No, NullPointerException is thrown" },
          { "id": "C", "text": "No, ExceptionInInitializerError is thrown" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "To invoke the special main method, JVM loads the class in the memory. \n At that time, static fields are initialized. \n d1 is of Double type so null is assigned to it. \n x is not static variable, so int x = d1.intValue(); is not executed. \n Class is loaded successfully and \"HELLO\" is printed. "
      },
      {
        "id": 16,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.time.LocalDate;\npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date1 = LocalDate.parse(\"1980-03-16\");\n        LocalDate date2 = LocalDate.parse(\"1980-03-16\");\n        System.out.println(date1.equals(date2) + \" : \" + date1.isEqual(date2));\n    }\n}",
        "options": [
          { "id": "A", "text": "true : true" },
          { "id": "B", "text": "true : false" },
          { "id": "C", "text": "false : true" },
          { "id": "D", "text": "false : false" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Both the methods \"public boolean isEqual(ChronoLocalDate)\" and \"public boolean equals(Object)\" return true if date objects are equal otherwise false. "
      },
      {
        "id": 17,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int a = 3;\n        System.out.println(a++ == 3 || --a == 3 && --a == 3);\n    }\n}",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "An exception is thrown at runtime" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Let's start solving it: ((a++) == 3) || (((--a) == 3) && ((--a) == 3)); \n (3 == 3) evaluates to true\n. || is a short-circuit operator, hence no need to evaluate expression on the right. \n res is true. "
      },
      {
        "id": 18,
        "type": "single",
        "questionText": "Which of the following method is declared in Predicate<T> interface?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "boolean test(T t);" },
          { "id": "B", "text": "boolean accept(T t);" },
          { "id": "C", "text": "void apply(T t);" },
          { "id": "D", "text": "boolean match(T t);" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Single abstract method declared in Predicate<T> interface is boolean test(T t); "
      },
      {
        "id": 19,
        "type": "single",
        "questionText": "Which of the following can be used as a constructor for the class given below?",
        "codeSnippet": "public class Planet {\n}",
        "options": [
          { "id": "A", "text": "void Planet() {}" },
          { "id": "B", "text": "public planet(String str) {}" },
          { "id": "C", "text": "public Planet(String str) {}" },
          { "id": "D", "text": "Planet construct() {}" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Constructor has the same name as the class, doesn't have return type and can accept parameters. "
      },
      {
        "id": 20,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.ArrayList;\nimport java.util.List;\nabstract class Animal {}\nclass Dog extends Animal{}\npublic class Test {\n    public static void main(String [] args) {\n        List<Animal> list = new ArrayList<Dog>();\n        list.add(0, new Dog());\n        System.out.println(list.size() > 0);\n    }\n}",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "ClassCastException" }
        ],
        "correctAnswers": ["C"],
        "explanation": "In generics syntax, Parameterized types are not polymorphic, this means ArrayList<Animal> is not super type of ArrayList<Dog>. \n So List<Animal> list = new ArrayList<Dog>(); is not allowed. "
      },
      {
        "id": 21,
        "type": "multiple",
        "questionText": "Which of the following will give you current system time? Select 2 options.",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "System.out.println(LocalDateTime.now());" },
          { "id": "B", "text": "System.out.println(LocalDate.now());" },
          { "id": "C", "text": "System.out.println(LocalTime.now());" },
          { "id": "D", "text": "new LocalTime()" }
        ],
        "correctAnswers": ["A", "C"],
        "explanation": "LocalTime.now() prints current time only\n. LocalDateTime.now() prints current date and time both\n. LocalDate.now() prints current date only \n. new LocalTime() gives compilation error as constructor is private."
      },
      {
        "id": 22,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        System.out.println(sb.append(\"\").append(\"\").append(\"\").length());\n    }\n}",
        "options": [
          { "id": "A", "text": "1" },
          { "id": "B", "text": "3" },
          { "id": "C", "text": "0" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "As \"\" is empty string, hence nothing is appended to the StringBuilder instance and length() method returns 0. "
      },
      {
        "id": 23,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        String javaworld = \"JavaWorld\";\n        String java = \"Java\";\n        String world = \"World\";\n        java += world;\n        System.out.println(java == javaworld);\n    }\n}",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "An exception is thrown at runtime" }
        ],
        "correctAnswers": ["B"],
        "explanation": "java += world is calculated at runtime and returns a non pool String object, which is referred by variable 'java' \n. variable 'javaworld' refers to String Pool object\n. As both variables refer to different String objects, java == javaworld returns false."
      },
      {
        "id": 24,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"Good\");\n        change(sb);\n        System.out.println(sb);\n    }\n \n    private static void change(StringBuilder s) {\n        s.append(\"_Morning\");\n    }\n}",
        "options": [
          { "id": "A", "text": "Good" },
          { "id": "B", "text": "Good_Morning" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "An exception is thrown at runtime" }
        ],
        "correctAnswers": ["B"],
        "explanation": "When change method is called, both variable s and sb refers to same StringBuilder object. \n Line 9 modifies the passed object and appends \"_Morning\" to it. \n As a result sb refers to \"Good_Morning\" so Line 5 prints \"Good_Morning\". "
      },
      {
        "id": 25,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nclass A {\n    A() { this(1); System.out.println(\"M\"); }\n    A(int i) { System.out.println(\"N\"); }\n}\nclass B extends A {}\npublic class Test {\n    public static void main(String[] args) {\n        new B();\n    }\n}",
        "options": [
          { "id": "A", "text": "M N" },
          { "id": "B", "text": "N M" },
          { "id": "C", "text": "M" },
          { "id": "D", "text": "N" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Executing new B(); invokes B's default constructor, which invokes no-arg constructor of class A [super();]. \n no-arg constructor of A invokes parameterized constructor of A [this(1);]. \n N is printed first and after that M is printed. "
      },
      {
        "id": 26,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    private static String s;\n    public static void main(String[] args) {\n        try {\n            System.out.println(s.length());\n        } catch(NullPointerException | RuntimeException ex) {\n            System.out.println(\"DONE\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "DONE" },
          { "id": "B", "text": "NullPointerException is thrown" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "No output" }
        ],
        "correctAnswers": ["C"],
        "explanation": "NullPointerException extends RuntimeException and in multi-catch syntax we can't specify multiple Exceptions related to each other in multilevel inheritance. "
      },
      {
        "id": 27,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int a = 3;\n        m(++a, a++);\n        System.out.println(a);\n    }\n \n    private static void m(int i, int j) {\n        i++;\n        j--;\n    }\n}",
        "options": [
          { "id": "A", "text": "3" },
          { "id": "B", "text": "4" },
          { "id": "C", "text": "5" },
          { "id": "D", "text": "6" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Method m works on copies and changes are local to method m only. \n m(++a, a++); \n a=3 initially. ++a makes a=4. Then a++ passes 4 and then makes a=5. \n System.out.println(a) prints 5. "
      },
      {
        "id": 28,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int a = 7;\n        boolean res = a++ == 7 && ++a == 9 || a++ == 9;\n        System.out.println(\"a = \" + a);\n        System.out.println(\"res = \" + res);\n    }\n}",
        "options": [
          { "id": "A", "text": "a = 8\nres = true" },
          { "id": "B", "text": "a = 9\nres = true" },
          { "id": "C", "text": "a = 10\nres = true" },
          { "id": "D", "text": "a = 9\nres = false" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Solving: ((a++) == 7) && ((++a) == 9) || ((a++) == 9)\n. (7 == 7) is true, a becomes 8\n. (true && (9 == 9)) is true, a becomes 9\n. (true && true) is true\n. true || ... short-circuits. So a = 9, res = true."
      },
      {
        "id": 29,
        "type": "single",
        "questionText": "Location of files: D:\\WORK\\QUIZ\\SEC07\\classes\\com\\udayan\\test\\Exam.class. You are currently at WORK folder (D:\\WORK>). Which of the following java command will show All the best! on to the console?",
        "codeSnippet": "package com.udayan.test;\npublic class Exam {\n    public static void main(String [] args) {\n        System.out.println(\"All the best!\");\n    }\n}",
        "options": [
          { "id": "A", "text": "java com.udayan.test.Exam" },
          { "id": "B", "text": "java -cp Quiz\\Sec07\\classes\\ com.udayan.test.Exam" },
          { "id": "C", "text": "java -cp Quiz\\Sec07\\classes\\ Exam" },
          { "id": "D", "text": "java Quiz\\Sec07\\classes\\com.udayan.test.Exam" }
        ],
        "correctAnswers": ["B"],
        "explanation": "To execute Exam class from WORK folder, you should specify the classpath (Quiz\\Sec07\\classes\\) which contains whole path of the class\n. And you should also use fully qualified name: com.udayan.test.Exam\n. Correct option: java -cp Quiz\\Sec07\\classes\\ com.udayan.test.Exam."
      },
      {
        "id": 30,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.function.Predicate;\npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"*\", \"**\", \"***\", \"****\", \"*****\", \"******\"};\n        Predicate<String> pr1 = s -> s.length() < 4;\n        print(arr, pr1);\n    }\n    private static void print(String [] arr, Predicate<String> predicate) {\n        for(String str : arr) {\n            if(predicate.test(str)) {\n                System.out.println(str);\n            }\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "*\n**\n***\n****" },
          { "id": "B", "text": "*\n**\n***" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "An exception is thrown" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Lambda expression s -> s.length() < 4 returns true if string's length is < 4. \n So first three array elements are printed. "
      },
      {
        "id": 31,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.time.LocalTime;\npublic class Test {\n    public static void main(String [] args) {\n        LocalTime time = LocalTime.of(23, 60);\n        System.out.println(time);\n    }\n}",
        "options": [
          { "id": "A", "text": "00:00" },
          { "id": "B", "text": "23:60" },
          { "id": "C", "text": "An exception is thrown at runtime" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Valid value for minute is 0 to 59. \n java.time.DateTimeException is thrown if invalid values are passed as arguments. "
      },
      {
        "id": 32,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>(4);\n        list.add(0, \"Array\");\n        list.add(2, \"List\");\n        System.out.println(list);\n    }\n}",
        "options": [
          { "id": "A", "text": "[Array, null, List]" },
          { "id": "B", "text": "[Array, List]" },
          { "id": "C", "text": "An exception is thrown at runtime" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Addition of elements in ArrayList should be continuous. You simply can't skip any index. \n list.add(0, \"Array\") adds to 0th index. \n You can't add at index 2 without adding at index 1 first. \n Throws java.lang.IndexOutOfBoundsException. "
      },
      {
        "id": 33,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Boolean [] arr = new Boolean[2];\n        System.out.println(arr[0] + \":\" + arr[1]);\n    }\n}",
        "options": [
          { "id": "A", "text": "false:false" },
          { "id": "B", "text": "null:null" },
          { "id": "C", "text": "true:true" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Array elements are initialized to their default values. \n arr is referring to an array of Boolean type, which is reference type and hence both array elements are initialized to null. "
      },
      {
        "id": 34,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "//Super, Sub, Test classes involving IOException and FileNotFoundException\npublic class Test {\n    public static void main(String[] args) {\n        Super s = new Sub();\n        try {\n            s.m1();\n        } catch (FileNotFoundException e) {\n            System.out.print(\"X\");\n        } catch (IOException e) {\n            System.out.print(\"Y\");\n        } finally {\n            System.out.print(\"Z\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "X" },
          { "id": "B", "text": "Y" },
          { "id": "C", "text": "XZ" },
          { "id": "D", "text": "YZ" }
        ],
        "correctAnswers": ["C"],
        "explanation": "At runtime an instance of FileNotFoundException is thrown. \n A catch handler for FileNotFoundException is available so X is printed. \n After that finally block executes, printing Z. \n Result: XZ."
      },
      {
        "id": 35,
        "type": "single",
        "questionText": "Which of the following statement is true regarding Class1, Class2, and Class3?",
        "codeSnippet": "//Class1, Class2, Class3 definitions",
        "options": [
          { "id": "A", "text": "Class1.java, Class2.java and Class3.java compile successfully" },
          { "id": "B", "text": "Class1.java and Class2.java compile successfully" },
          { "id": "C", "text": "Only Class2.java compiles successfully" },
          { "id": "D", "text": "All classes fail to compile" }
        ],
        "correctAnswers": ["B"],
        "explanation": "read() method of Class1 doesn't have to throw Exception just because it declares it. \n Variable and method name can be same as class name (Class2 valid). \n LOCAL variable can be declared with final modifier only; Class3's msg variable is declared private, causing error. "
      },
      {
        "id": 36,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.time.LocalDate;\npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2068, 4, 15);\n        System.out.println(date.getMonth() + \":\" + date.getMonthValue());\n    }\n}",
        "options": [
          { "id": "A", "text": "4:4" },
          { "id": "B", "text": "APRIL:4" },
          { "id": "C", "text": "April:4" },
          { "id": "D", "text": "APRIL:April" }
        ],
        "correctAnswers": ["B"],
        "explanation": "date.getMonth() returns the month of the year using Month enum (upper case names) \n. date.getMonthValue() returns the value of the month (starting with 1)."
      },
      {
        "id": 37,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        int i;\n        outer:\n        do {\n            i = 5;\n            inner:\n            while (true) {\n                System.out.println(i--);\n                if (i == 4) {\n                    break outer;\n                }\n            }\n        } while (true);\n    }\n}",
        "options": [
          { "id": "A", "text": "Prints 5 once." },
          { "id": "B", "text": "Prints 5 in infinite loop." },
          { "id": "C", "text": "Prints 5 and 4." },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "do-while initializes i to 5. while(true) prints i-- (prints 5, i becomes 4). if(i == 4) evaluates to true, break outer executes and terminates do-while. \n 5 is printed once. "
      },
      {
        "id": 38,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"Hello\");\n        List<StringBuilder> list = new ArrayList<>();\n        list.add(sb);\n        list.add(new StringBuilder(\"Hello\"));\n        list.add(sb);\n        sb.append(\"World!\");\n        System.out.println(list);\n    }\n}",
        "options": [
          { "id": "A", "text": "[Hello, Hello, Hello]" },
          { "id": "B", "text": "[HelloWorld!, Hello, HelloWorld!]" },
          { "id": "C", "text": "[HelloWorld!, HelloWorld!, HelloWorld!]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "1st and 3rd list items refer to same StringBuilder instance sb. \n sb.append(\"World!\") makes sb -> \"HelloWorld!\". \n 2nd item refers to a different instance. Output: [HelloWorld!, Hello, HelloWorld!]. "
      },
      {
        "id": 39,
        "type": "single",
        "questionText": "Which of the following is the correct package declaration to declare Test class in com.exam.oca package?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "package com.exam.oca.*;" },
          { "id": "B", "text": "package com.exam.oca.Test;" },
          { "id": "C", "text": "package com.exam.oca;" },
          { "id": "D", "text": "import com.exam.oca;" }
        ],
        "correctAnswers": ["C"],
        "explanation": "To declare Test class in com.exam.oca package, use: package com.exam.oca;\n. No wildcard (*) allowed. Don't include class name. "
      },
      {
        "id": 40,
        "type": "single",
        "questionText": "Which of the following statement is correct regarding the provided code?",
        "codeSnippet": "package com.udayan.oca;\nimport java.time.LocalDate;\npublic class Test {\n    public static void main(String [] args) {\n        LocalDate obj = LocalDate.now();\n        System.out.println(obj.getHour());\n    }\n}",
        "options": [
          { "id": "A", "text": "Prints current hour" },
          { "id": "B", "text": "Code fails to compile" },
          { "id": "C", "text": "Throws exception at runtime" },
          { "id": "D", "text": "Prints 0" }
        ],
        "correctAnswers": ["B"],
        "explanation": "obj is of LocalDate type and getHour() method is not defined in LocalDate class, it is defined in LocalTime and LocalDateTime class. \n Hence obj.getHour() causes compilation failure. "
      },
      {
        "id": 41,
        "type": "single",
        "questionText": "Which of the method of String class is used to remove leading and trailing white spaces?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "ltrim()" },
          { "id": "B", "text": "rtrim()" },
          { "id": "C", "text": "trim()" },
          { "id": "D", "text": "trimBoth()" }
        ],
        "correctAnswers": ["C"],
        "explanation": "trim() method is used for removing leading and trailing white spaces. \n ltrim(), rtrim() and trimBoth() are not defined in String class. "
      },
      {
        "id": 42,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void print() { System.out.println(\"static method\"); }\n    public static void main(String[] args) {\n        Test obj = null;\n        obj.print();\n    }\n}",
        "options": [
          { "id": "A", "text": "static method" },
          { "id": "B", "text": "NullPointerException" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "No output" }
        ],
        "correctAnswers": ["A"],
        "explanation": "static methods can also be invoked using reference variable: obj.print(); \n Even though obj has null value, we don't get NullPointerException as objects are not needed to call static methods. "
      },
      {
        "id": 43,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"abc\", \"TrUe\", \"false\", null, \"FALSE\"};\n        for(String s : arr) {\n            System.out.print(Boolean.valueOf(s) ? \"T\" : \"F\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "FTFFF" },
          { "id": "B", "text": "TFFFT" },
          { "id": "C", "text": "FFFFF" },
          { "id": "D", "text": "TTTTT" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Boolean.valueOf(String s) returns true if passed argument is not null and equals (ignoring case) \"true\". \n In all other cases it returns false. \n Results: \"abc\"->false, \"TrUe\"->true, \"false\"->false, null->false, \"FALSE\"->false. \n Output: FTFFF."
      },
      {
        "id": 44,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.time.Period;\npublic class Test {\n    public static void main(String [] args) {\n        Period period = Period.of(0, 1000, 0);\n        System.out.println(period);\n    }\n}",
        "options": [
          { "id": "A", "text": "P0Y1000M0D" },
          { "id": "B", "text": "P1000M" },
          { "id": "C", "text": "P1000M0D" },
          { "id": "D", "text": "P0Y1000M" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Period components (year, month, day) with 0 values are ignored in toString(). \n Result starts with P, for non-zero month M is appended. \n Output: P1000M."
      },
      {
        "id": 45,
        "type": "multiple",
        "questionText": "There is a compilation error in the Student class. Which modifications, done independently, print \"James:25\" on to the console? Select 2 options.",
        "codeSnippet": "package com.udayan.oca;\nclass Student {\n    String name; int age;\n    Student() { Student(\"James\", 25); }\n    Student(String name, int age) { this.name = name; this.age = age; }\n}",
        "options": [
          { "id": "A", "text": "Replace Student(\"James\", 25); with this(\"James\", 25);" },
          { "id": "B", "text": "Replace Student(\"James\", 25); with super(\"James\", 25);" },
          { "id": "C", "text": "Add below code: void Student(String name, int age) { this.name = name; this.age = age; }" },
          { "id": "D", "text": "Change Student class to public" }
        ],
        "correctAnswers": ["A", "C"],
        "explanation": "no-arg constructor calling another constructor by name causes compilation error. \n Fix 1: replace with this(\"James\", 25). Fix 2: add a void Student(String, int) method (methods can have class name). "
      },
      {
        "id": 46,
        "type": "single",
        "questionText": "What is the signature of special main method?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "public static void main(String [] a) {}" },
          { "id": "B", "text": "static void main(String [] args) {}" },
          { "id": "C", "text": "public void main(String [] args) {}" },
          { "id": "D", "text": "public static void main(String args) {}" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Special main method should have public access specifier and it takes argument of String [] type. \n The argument can use any identifier name. "
      },
      {
        "id": 47,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        try {\n            for(;;) { sb.append(\"OCA\"); }\n        } catch(Exception e) {\n            System.out.println(\"Exception!!!\");\n        }\n        System.out.println(\"Main ends!!!\");\n    }\n}",
        "options": [
          { "id": "A", "text": "Exception!!!" },
          { "id": "B", "text": "Main ends!!!" },
          { "id": "C", "text": "Program terminates abruptly" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["C"],
        "explanation": "for(;;) is an infinite loop and sb.append(\"OCA\") causes OutOfMemoryError, which is a subclass of Error. \n Catching Exception does not catch OutOfMemoryError, so the program terminates abruptly. "
      },
      {
        "id": 48,
        "type": "single",
        "questionText": "How many String objects are there in the HEAP memory, when control is at Line 9?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        String s1 = new String(\"Java\"); //Line 3\n        String s2 = \"JaVa\"; //Line 4\n        String s3 = \"JaVa\"; //Line 5\n        String s4 = \"Java\"; //Line 6\n        String s5 = \"Java\"; //Line 7\n        int i = 1; //Line 9\n    }\n}",
        "options": [
          { "id": "A", "text": "5" },
          { "id": "B", "text": "2" },
          { "id": "C", "text": "3" },
          { "id": "D", "text": "4" }
        ],
        "correctAnswers": ["C"],
        "explanation": "s1 = new String(\"Java\") creates 1 Pool and 1 non-pool object \n. s2 = \"JaVa\" creates 1 Pool object \n. s3 refers to Pool \"JaVa\" \n. s4 and s5 refer to Pool \"Java\"\n. Total: 3 objects available (2 Pool, 1 non-pool). "
      },
      {
        "id": 49,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Greetings class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Greetings {\n    String msg = null;\n    public Greetings() {}\n    public Greetings(String str) { msg = str; }\n    public void display() { System.out.println(msg); }\n    public static void main(String [] args) {\n        Greetings g1 = new Greetings();\n        Greetings g2 = new Greetings(\"Good Evening!\");\n        g1.display();\n        g1.display();\n    }\n}",
        "options": [
          { "id": "A", "text": "null\nnull" },
          { "id": "B", "text": "Good Evening!\nGood Evening!" },
          { "id": "C", "text": "null\nGood Evening!" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "g1 = new Greetings() assigns null to its msg property \n. g1.display() is called twice, printing null each time \n. display() was never called on g2."
      },
      {
        "id": 50,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Circus?",
        "codeSnippet": "//Animal, Cat, Deer, Circus classes\npublic class Circus {\n    public static void main(String[] args) {\n        Animal cat = new Cat();\n        Animal deer = new Deer();\n        cat.jump();\n        deer.jump();\n    }\n}",
        "options": [
          { "id": "A", "text": "Cat\nDeer" },
          { "id": "B", "text": "Animal\nAnimal" },
          { "id": "C", "text": "Animal\nDeer" },
          { "id": "D", "text": "Cat\nAnimal" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Cat class overloads jump(int) but doesn't override jump() \n. cat.jump() calls Animal's version\n. Deer class overrides jump(), so deer.jump() calls Deer's version\n. Result: Animal Deer."
      },
      {
        "id": 51,
        "type": "multiple",
        "questionText": "Which 2 changes are necessary so that code compiles successfully?",
        "codeSnippet": "//ReadTheFile and Test classes involving IOException\nstatic void print() {\n    throw new IOException();\n}",
        "options": [
          { "id": "A", "text": "Replace Line 4 with: static void print() throws Exception {" },
          { "id": "B", "text": "Surround Line 11 with try { ReadTheFile.print(); } catch(Exception e) { e.printStackTrace(); }" },
          { "id": "C", "text": "Replace Line 5 with: try { throw new IOException(); } catch(IOException e) {}" },
          { "id": "D", "text": "Make main method abstract" }
        ],
        "correctAnswers": ["A", "B"],
        "explanation": "Line 5 throws IOException (checked) but it's not declared in throws \n. print method needs throws clause for Exception or super type\n. Line 11 also needs handling. Correct pairing: change print signature to throws Exception and surround call with try-catch(Exception) ."
      },
      {
        "id": 52,
        "type": "single",
        "questionText": "Currently the code causes compilation error. Which of the options can successfully print TEXT,25 on to the console?",
        "codeSnippet": "//Document, Word, Test classes",
        "options": [
          { "id": "A", "text": "Replace INSERT-1 with: this.type = type; AND Replace INSERT-2 with: this(type);" },
          { "id": "B", "text": "Replace INSERT-1 with: type = type; AND Replace INSERT-2 with: super(pages);" },
          { "id": "C", "text": "Replace INSERT-1 with: this.type = type; AND Replace INSERT-2 with: super(pages);" },
          { "id": "D", "text": "No modification needed" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Word constructor causes error because Document has no no-arg constructor\n. Replace INSERT-1 with this.type = type to set value\n. Replace INSERT-2 with this(type) to set type variable via the other constructor \n. using super(pages) would be redundant."
      },
      {
        "id": 53,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date1 = LocalDate.parse(\"1947-08-15\", DateTimeFormatter.ISO_DATE);\n        LocalDate date2 = LocalDate.parse(\"1947-08-15\", DateTimeFormatter.ISO_LOCAL_DATE);\n        LocalDate date3 = LocalDate.of(1947, 8, 15);\n        System.out.println(date1.equals(date2) + \" : \" + date2.equals(date3));\n    }\n}",
        "options": [
          { "id": "A", "text": "true : true" },
          { "id": "B", "text": "true : false" },
          { "id": "C", "text": "false : true" },
          { "id": "D", "text": "false : false" }
        ],
        "correctAnswers": ["A"],
        "explanation": "ISO_LOCAL_DATE and ISO_DATE both work for \"1947-08-15\"\n. All three date instances are meaningfully equal."
      },
      {
        "id": 54,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        int i;\n        for(i=0; i<=2; i++){}\n        System.out.println(i);\n    }\n}",
        "options": [
          { "id": "A", "text": "2" },
          { "id": "B", "text": "3" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "An exception is thrown" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Loop executes 3 times for i=0, 1, 2. For i=3, control goes out\n. Since i is declared outside, it is accessible\n. Prints 3. "
      },
      {
        "id": 55,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class Test {\n    public static void main(String[] args) {\n        List<Character> list = new ArrayList<>();\n        list.add(0, 'V');\n        list.add('T');\n        list.add(1, 'E');\n        list.add(3, 'O');\n        if(list.contains('O')) { list.remove(3); }\n        for(char ch : list) { System.out.print(ch); }\n    }\n}",
        "options": [
          { "id": "A", "text": "VET" },
          { "id": "B", "text": "VEO" },
          { "id": "C", "text": "VETO" },
          { "id": "D", "text": "VT" }
        ],
        "correctAnswers": ["A"],
        "explanation": "List progression: [V] -> [V,T] -> [V,E,T] -> [V,E,T,O] \n. list.contains('O') is true \n. list.remove(3) removes 'O'\n. Prints VET."
      },
      {
        "id": 56,
        "type": "single",
        "questionText": "On executing Counter class, how many Counter objects are created in the memory?",
        "codeSnippet": "package com.udayan.oca;\npublic class Counter {\n    int count;\n    private static void increment(Counter counter) { counter.count++; }\n    public static void main(String [] args) {\n        Counter c1 = new Counter();\n        Counter c2 = c1;\n        Counter c3 = null;\n        c2.count = 1000;\n        increment(c2);\n    }\n}",
        "options": [
          { "id": "A", "text": "1" },
          { "id": "B", "text": "2" },
          { "id": "C", "text": "3" },
          { "id": "D", "text": "4" }
        ],
        "correctAnswers": ["A"],
        "explanation": "new Counter(); is invoked only once, so only one object is created. \n c1, c2, c3 and counter are reference variables, not objects. "
      },
      {
        "id": 57,
        "type": "single",
        "questionText": "Which of the following statement is correct for below code?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        final boolean flag;\n        flag = false;\n        while(flag) { System.out.println(\"Good Morning!\"); }\n    }\n}",
        "options": [
          { "id": "A", "text": "Prints \"Good Morning!\" once" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Program compiles and executes but produces no output" },
          { "id": "D", "text": "Prints \"Good Morning!\" in infinite loop" }
        ],
        "correctAnswers": ["C"],
        "explanation": "final boolean flag; flag = false; doesn't make flag a compile time constant\n. Compiler allows it\n. At runtime loop doesn't execute."
      },
      {
        "id": 58,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class Test {\n    public static void main(String[] args) {\n        Integer i = 10;\n        List<Integer> list = new ArrayList<>();\n        list.add(i);\n        list.add(new Integer(i));\n        list.add(i);\n        list.removeIf(i -> i == 10);\n        System.out.println(list);\n    }\n}",
        "options": [
          { "id": "A", "text": "[]" },
          { "id": "B", "text": "[10, 10, 10]" },
          { "id": "C", "text": "Compilation Error" },
          { "id": "D", "text": "An exception is thrown" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Variable \"i\" used in lambda expression clashes with another local variable \"i\" and hence causes compilation error. "
      },
      {
        "id": 59,
        "type": "single",
        "questionText": "Which of the following statement is correct for below code?",
        "codeSnippet": "package com.udayan.oca;\npublic class Wall {\n    public static void main(String args[]) {\n        double area = 5.7;\n        String color;\n        if (area < 7) color = \"green\";\n        System.out.println(color);\n    }\n}",
        "options": [
          { "id": "A", "text": "Prints green" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "NullPointerException" },
          { "id": "D", "text": "Prints null" }
        ],
        "correctAnswers": ["B"],
        "explanation": "color is LOCAL variable and must be initialized\n. Compiler cannot be sure if it will be initialized as there's no else block and area is not constant."
      },
      {
        "id": 60,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class Test {\n    public static void main(String[] args) {\n        List<String> fruits = new ArrayList<>();\n        fruits.add(\"apple\"); fruits.add(\"orange\"); fruits.add(\"grape\");\n        fruits.add(\"mango\"); fruits.add(\"banana\"); fruits.add(\"grape\");\n        if(fruits.remove(\"grape\")) fruits.remove(\"apple\");\n        System.out.println(fruits);\n    }\n}",
        "options": [
          { "id": "A", "text": "[orange, mango, banana, grape]" },
          { "id": "B", "text": "[apple, orange, mango, banana]" },
          { "id": "C", "text": "[orange, grape, mango, banana, grape]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "fruits.remove(\"grape\") removes first occurrence and returns true\n. Then fruits.remove(\"apple\") executes\n. Final list: [orange, mango, banana, grape]."
      },
      {
        "id": 61,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(1 + 2 + 3 + 4 + \"Hello\");\n    }\n}",
        "options": [
          { "id": "A", "text": "1234Hello" },
          { "id": "B", "text": "10Hello" },
          { "id": "C", "text": "Hello10" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Expression is left to right associative: 1+2=3, 3+3=6, 6+4=10 \n. + with String is concatenation: 10 + \"Hello\" = 10Hello."
      },
      {
        "id": 62,
        "type": "single",
        "questionText": "Wrapper classes are defined in which of the following package?",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "java.util" },
          { "id": "B", "text": "java.lang" },
          { "id": "C", "text": "java.io" },
          { "id": "D", "text": "java.wrapper" }
        ],
        "correctAnswers": ["B"],
        "explanation": "All wrapper classes are defined in java.lang package. "
      },
      {
        "id": 63,
        "type": "single",
        "questionText": "What will be the output of compiling and executing the Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        int a = 5; int x = 10;\n        switch(x) {\n            case 10: a *= 2;\n            case 20: a *= 3;\n            case 30: a *= 4;\n        }\n        System.out.println(a);\n    }\n}",
        "options": [
          { "id": "A", "text": "10" },
          { "id": "B", "text": "120" },
          { "id": "C", "text": "30" },
          { "id": "D", "text": "5" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Matches case 10, a = 5*2=10\n. No break, so fall-through: case 20 makes a = 10*3=30 \n. case 30 makes a = 30*4=120."
      },
      {
        "id": 64,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        extractInt(2.7); extractInt(2);\n    }\n    private static void extractInt(Double obj) { System.out.println(obj.intValue()); }\n}",
        "options": [
          { "id": "A", "text": "2\n2" },
          { "id": "B", "text": "Compilation error in main method" },
          { "id": "C", "text": "ClassCastException" },
          { "id": "D", "text": "2\n0" }
        ],
        "correctAnswers": ["B"],
        "explanation": "extractInt(2.7) boxes double literal to Double \n. extractInt(2) fails because Java compiler does not do both implicit casting (int to double) and Wrapping in one step. "
      },
      {
        "id": 65,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        byte b1 = (byte) (127 + 21);\n        System.out.println(b1);\n    }\n}",
        "options": [
          { "id": "A", "text": "148" },
          { "id": "B", "text": "-108" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "127" }
        ],
        "correctAnswers": ["B"],
        "explanation": "127 + 21 = 148\n. Binary of 148 has left most bit 0 as int \n, but after cast to byte, left most bit is 1, making it negative\n. 10010100 = -108. "
      },
      {
        "id": 66,
        "type": "multiple",
        "questionText": "Which modifications, done independently, print \"Integer version\" on to the console? Select 3 options.",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    private static void add(int i, int j) { System.out.println(\"int version\"); }\n    private static void add(Integer i, Integer j) { System.out.println(\"Integer version\"); }\n    public static void main(String[] args) { add(10, 20); }\n}",
        "options": [
          { "id": "A", "text": "Remove add(int i, int j) method declaration and definition." },
          { "id": "B", "text": "Replace add(10, 20); by add(new Integer(10), new Integer(20));" },
          { "id": "C", "text": "Replace add(10, 20); by add(null, null);" },
          { "id": "D", "text": "Replace add(10, 20); by add(10.0, 20.0);" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "Removing int version causes auto-boxing\n. Explicitly passing Integer instances calls Integer version\n. Passing null maps to reference type Integer\n. Option D causes compilation error."
      },
      {
        "id": 67,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.*;\npublic class Test {\n    public static void main(String[] args) {\n        Boolean [] arr = new Boolean[2];\n        List<Boolean> list = new ArrayList<>();\n        list.add(arr[0]); list.add(arr[1]);\n        if(list.remove(0)) { list.remove(1); }\n        System.out.println(list);\n    }\n}",
        "options": [
          { "id": "A", "text": "[null]" },
          { "id": "B", "text": "NullPointerException is thrown at runtime" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "[]" }
        ],
        "correctAnswers": ["B"],
        "explanation": "arr[0] and arr[1] are null \n. list.remove(0) returns null\n. For if-block expression, Java tries booleanValue() on null, throwing NullPointerException. "
      },
      {
        "id": 68,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        char [][] arr = { {'A', 'B', 'C'}, {'D', 'E', 'F'}, {'G', 'H', 'I'} };\n        for(int i = 0; i < arr.length; i++) {\n            for(int j = 0; j < arr[i].length; j++) { System.out.print(arr[i][1]); }\n            System.out.println();\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "ABC\nDEF\nGHI" },
          { "id": "B", "text": "BBB\nEEE\nHHH" },
          { "id": "C", "text": "AAA\nDDD\nGGG" },
          { "id": "D", "text": "BBB\nFFF\nIII" }
        ],
        "correctAnswers": ["B"],
        "explanation": "The inner loop prints arr[i][1] (2nd element of a particular row) for each iteration of j. \n Result: BBB EEE HHH."
      },
      {
        "id": 69,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayan.oca;\nimport java.util.*;\npublic class Test {\n    public static void main(String[] args) {\n        List<String> dryFruits = new ArrayList<>();\n        dryFruits.add(\"Walnut\"); dryFruits.add(\"Apricot\");\n        dryFruits.add(\"Almond\"); dryFruits.add(\"Date\");\n        for(String dryFruit : dryFruits) {\n            if(dryFruit.startsWith(\"A\")) { dryFruits.remove(dryFruit); }\n        }\n        System.out.println(dryFruits);\n    }\n}",
        "options": [
          { "id": "A", "text": "[Walnut, Almond, Date]" },
          { "id": "B", "text": "An exception is thrown at runtime" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "[Walnut, Date]" }
        ],
        "correctAnswers": ["B"],
        "explanation": "ConcurrentModificationException is thrown when a collection is modified (remove) while being iterated by for-each loop. \n Specifically, when iterator.next() is called after size changed. "
      },
      {
        "id": 70,
        "type": "single",
        "questionText": "Which of the following statement is correct about below code?",
        "codeSnippet": "package com.udayan.oca;\npublic class Test {\n    public static void main(String[] args) {\n        do { System.out.println(100); } while (true);\n        System.out.println(\"Bye\");\n    }\n}",
        "options": [
          { "id": "A", "text": "Prints 100 in infinite loop" },
          { "id": "B", "text": "Unreachable code compilation error" },
          { "id": "C", "text": "Prints 100 then Bye" },
          { "id": "D", "text": "Compilation error on do-while" }
        ],
        "correctAnswers": ["B"],
        "explanation": "while (true) uses literal true, so compiler knows it is an infinite loop\n. Statements after it are marked as Unreachable Code, causing compilation error."
      }
    ]},
  {
    "id": 5,
    "name": "OCA Practice Exam 5",
    "description": "Set 5",
    "questions": [
      {
        "id": 1,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String [][] arr = { {\"%\", \"$$\"}, {\"***\", \"@@@@\", \"#####\"}};\n        for(String [] str : arr) {\n            for(String s : str) {\n                System.out.println(s);\n                if(s.length() == 4) //Line n1\n                    break; //Line n2\n            }\n            break; //Line n3\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "%\n$$" },
          { "id": "B", "text": "%\n$$\n***" },
          { "id": "C", "text": "%\n$$\n***\n@@@@" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Variable 'arr' refers to a two-dimensional array. for-each loops are used to iterate the given array.\nIn 1st iteration of outer loop, str refers to one-dimensional String array {\"%\", \"$$\"}.\nIn 1st iteration of inner loop, s refers to \"%\" and \"%\" will be printed on to the console. Boolean expression of Line n1 evaluates to false so Line n2 is not executed.\nIn 2nd iteration of inner loop, s refers to \"$$\" and \"$$\" will be printed on to the console. Boolean expression of Line n1 evaluates to false so Line n2 is not executed.\nIteration of inner for-each loop is over and control executes Line n3. break;\nstatement at Line n3 terminates the outer loop and program ends successfully.\nSo, output is:\n%\n$$"
      },
      {
        "id": 2,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void m() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            throw e;\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            m();\n        } catch(SQLException e) {\n            System.out.println(\"CAUGHT SUCCESSFULLY\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "CAUGHT SUCCESSFULLY" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "An exception is thrown at runtime" },
          { "id": "D", "text": "None of the above" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Even though it seems like method m() will not compile successfully, but starting with JDK 7, it is allowed to use super class reference variable in throw statement referring to sub class Exception object.\nIn this case, method m() throws SQLException and compiler knows that variable e (Exception type) refers to an instance of SQLException only and hence allows it.\nProgram executes successfully and prints CAUGHT SUCCESSFULLY on to the console."
      },
      {
        "id": 3,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int a = 3;\n        int b = 5;\n        int c = 7;\n        int d = 9;\n        boolean res = --a + --b < 1 && c++ + d++ > 1;\n        System.out.printf(\"a = %d, b = %d, c = %d, d = %d, res = %b\", a, b, c, d, res);\n    }\n}",
        "options": [
          { "id": "A", "text": "a = 2, b = 4, c = 7, d = 9, res = false" },
          { "id": "B", "text": "a = 2, b = 4, c = 8, d = 10, res = false" },
          { "id": "C", "text": "a = 2, b = 4, c = 8, d = 10, res = true" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Given expression: --a + --b < 1 && c++ + d++ > 1;\nEvaluate left operand of && first: [{(--a) + (--b)} < 1]. a becomes 2, b becomes 4. 2 + 4 = 6. 6 < 1 is false.\n&& is short circuit operator, hence right operand [c++ + d++ > 1] is not evaluated and false is returned.\nValues of c and d remain 7 and 9.\nOutput of the given program is: a = 2, b = 4, c = 7, d = 9, res = false"
      },
      {
        "id": 4,
        "type": "single",
        "questionText": "Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print LOCK-OPEN on to the console?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nclass Lock {\n    public void open() {\n        System.out.println(\"LOCK-OPEN\");\n    }\n}\n \nclass Padlock extends Lock {\n    public void open() {\n        System.out.println(\"PADLOCK-OPEN\");\n    }\n}\n \nclass DigitalPadlock extends Padlock {\n    public void open() {\n        /*INSERT*/\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Lock lock = new DigitalPadlock();\n        lock.open();\n    }\n}",
        "options": [
          { "id": "A", "text": "super.open();" },
          { "id": "B", "text": "super.super.open();" },
          { "id": "C", "text": "((Lock)super).open();" },
          { "id": "D", "text": "None of the other options" }
        ],
        "correctAnswers": ["D"],
        "explanation": "super.open(); => invokes open() method of Padlock class (immediate parent), printing PADLOCK-OPEN.\nsuper.super.open(); => causes compilation error.\n((Lock)super).open(); => causes compilation error.\nIt is not possible to directly reach to 2 levels up using super keyword.\nHence, correct answer is: 'None of the other options'"
      },
      {
        "id": 5,
        "type": "single",
        "questionText": "Which of the following statements is correct?",
        "codeSnippet": "package com.udayankhattry.oca;\n \ninterface X1 {\n    default void print() {\n        System.out.println(\"X1\");\n    }\n}\n \ninterface X2 extends X1 {\n    void print();\n}\n \ninterface X3 extends X2 {\n    default void print() {\n        System.out.println(\"X3\");\n    }\n}\n \nclass X implements X3 {}\n \npublic class Test {\n    public static void main(String[] args) {\n        X1 obj = new X();\n        obj.print();\n    }\n}",
        "options": [
          { "id": "A", "text": "X1" },
          { "id": "B", "text": "X3" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "X implements X3. X3 extends X2 extends X1.\nX3 overrides the abstract method print() of X2 with a default method printing \"X3\".\n`obj.print()` invokes the default method print() defined in interface X3 (the most specific implementation) and hence X3 is printed on to the console."
      },
      {
        "id": 6,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        boolean flag1 = \"Java\" == \"Java\".replace('J', 'J'); //Line n1\n        boolean flag2 = \"Java\" == \"Java\".replace(\"J\", \"J\"); //Line n2\n        System.out.println(flag1 && flag2);\n    }\n}",
        "options": [
          { "id": "A", "text": "true" },
          { "id": "B", "text": "false" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "replace(char, char): If no replacement is done (or same chars), source String object is returned. flag1 is true.\nreplace(CharSequence, CharSequence): Returns a new String object if match found, even if replacement is same. flag2 is false.\nflag1 && flag2 evaluates to false."
      },
      {
        "id": 7,
        "type": "single",
        "questionText": "What will be the result of compiling and executing above code?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nclass X {\n    void greet() {\n        System.out.println(\"Good Morning!\");\n    }\n}\n \nclass Y extends X {\n    void greet() {\n        System.out.println(\"Good Afternoon!\");\n    }\n}\n \nclass Z extends Y {\n    void greet() {\n        System.out.println(\"Good Night!\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        X x = new Z();\n        x.greet(); //Line n1\n        ((Y)x).greet(); //Line n2\n        ((Z)x).greet(); //Line n3\n    }\n}",
        "options": [
          { "id": "A", "text": "Good Morning!\nGood Afternoon!\nGood Night!" },
          { "id": "B", "text": "Good Night!\nGood Night!\nGood Night!" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Variable x refers to an instance of Z class. Methods are overridden. Which overriding method to invoke is decided at runtime based on the instance.\nAt runtime, all three statements (Line n1, n2, n3) invoke the greet() method of Z class, which prints \"Good Night!\" three times."
      },
      {
        "id": 8,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void availableSeats() throws SQLException {\n        throw null; //Line 7\n    }\n \n    public static void main(String[] args) {\n        try {\n            availableSeats(); //Line 12\n        } catch(SQLException e) {\n            System.out.println(\"SEATS NOT AVAILABLE\");\n        }\n    }\n}",
        "options": [
          { "id": "A", "text": "SEATS NOT AVAILABLE" },
          { "id": "B", "text": "NullPointerException" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "No output" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Throwing null causes a NullPointerException at runtime. The catch block expects SQLException, so it doesn't catch the NullPointerException (unchecked). Program ends abruptly with stack trace."
      },
      {
        "id": 9,
        "type": "single",
        "questionText": "Which of the following statements is correct?",
        "codeSnippet": "interface ILog {\n    default void log() {\n        System.out.println(\"ILog\");\n    }\n}\n \nabstract class Log {\n    public static void log() {\n        System.out.println(\"Log\");\n    }\n}\n \nclass MyLogger extends Log implements ILog {}",
        "options": [
          { "id": "A", "text": "Code compiles successfully" },
          { "id": "B", "text": "Compilation error in MyLogger" },
          { "id": "C", "text": "Compilation error in Log" },
          { "id": "D", "text": "Compilation error in ILog" }
        ],
        "correctAnswers": ["C"],
        "explanation": "MyLogger inherits default instance method log() from ILog. It also has access to static method log() from Log class. Static and non-static methods with the same signature are not allowed in one scope. Therefore, class MyLogger (or the inheritance structure) fails to compile."
      },
      {
        "id": 10,
        "type": "single",
        "questionText": "What needs to be done so that all the classes can read/change the value of radius field and Circle class is well encapsulated as well?",
        "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Circle {\n    private double radius;\n \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n \n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}",
        "options": [
          { "id": "A", "text": "Change radius to public" },
          { "id": "B", "text": "Add public getRadius() and setRadius() methods" },
          { "id": "C", "text": "Add default getRadius() and setRadius() methods" },
          { "id": "D", "text": "Change radius to protected" }
        ],
        "correctAnswers": ["B"],
        "explanation": "To be well encapsulated, radius must be private, and public accessors (getters/setters) should be provided.\nAdd public double getRadius() { return radius; } and public void setRadius(double radius) { this.radius = radius; }"
      },
      {
        "id": 11,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nabstract class Animal {\n    abstract void jump() throws RuntimeException;\n}\n \nclass Deer extends Animal {\n    void jump() { //Line n1\n        System.out.println(\"DEER JUMPS\");\n    }\n \n    void jump(int i) {\n        System.out.println(\"DEER JUMPS TO \" + i + \" FEET\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Animal animal = new Deer();\n        ((Deer)animal).jump(); //Line n2\n        ((Deer)animal).jump(5); //Line n3\n    }\n}",
        "options": [
          { "id": "A", "text": "DEER JUMPS\nDEER JUMPS TO 5 FEET" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "DEER JUMPS" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Overriding method in Deer does not need to throw RuntimeException (unchecked). Line n1 is valid.\nCasting animal to Deer allows access to overloaded jump(int). Code compiles and runs printing:\nDEER JUMPS\nDEER JUMPS TO 5 FEET"
      },
      {
        "id": 12,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        byte b = 10;\n        list.add(b); //Line n1\n        int mul = list.get(0) * list.get(0); //Line n2\n        System.out.println(mul);\n    }\n}",
        "options": [
          { "id": "A", "text": "100" },
          { "id": "B", "text": "Compilation error at Line n1" },
          { "id": "C", "text": "Compilation error at Line n2" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "list is List<Integer>. variable 'b' is byte. Autoboxing converts byte to Byte.\nList<Integer> cannot accept Byte object. Integer and Byte are siblings (both extend Number), not subclasses of each other.\nLine n1 causes compilation error."
      },
      {
        "id": 13,
        "type": "single",
        "questionText": "What will be the result of compiling and executing above code?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nclass Super {\n    void Super() {\n        System.out.print(\"KEEP_\");\n    }\n}\n \nclass Base extends Super {\n    Base() {\n        Super();\n        System.out.print(\"GOING_\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new Base();\n    }\n}",
        "options": [
          { "id": "A", "text": "KEEP_GOING_" },
          { "id": "B", "text": "GOING_KEEP_" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "GOING_" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Base() constructor implicitly calls super(). Super() has default no-arg constructor.\nThen Base() calls Super() method (not constructor), which prints \"KEEP_\".\nThen \"GOING_\" is printed. Result: KEEP_GOING_"
      },
      {
        "id": 14,
        "type": "single",
        "questionText": "How many statements can replace /*INSERT*/ such that there is no compilation error?",
        "codeSnippet": "interface Workable {\n    void work();\n}\n \n/*INSERT*/ {\n    public void work() {} //Line n1\n}",
        "options": [
          { "id": "A", "text": "1" },
          { "id": "B", "text": "2" },
          { "id": "C", "text": "3" },
          { "id": "D", "text": "4" }
        ],
        "correctAnswers": ["C"],
        "explanation": "The block has a concrete method work().\n1. abstract class Work implements Workable: Valid.\n2. class Work implements Workable: Valid.\n5. abstract class Work: Valid (doesn't have to implement interface, just defines method).\nInterfaces (options 3 & 4) cannot have concrete methods without 'default'.\n3 statements are valid."
      },
      {
        "id": 15,
        "type": "single",
        "questionText": "How many definitions of get() method can replace /*INSERT*/ such that there is no compilation error?",
        "codeSnippet": "abstract class Super {\n    abstract List<Father> get();\n}\n \nclass Sub extends Super {\n    /*INSERT*/\n}",
        "options": [
          { "id": "A", "text": "2" },
          { "id": "B", "text": "4" },
          { "id": "C", "text": "6" },
          { "id": "D", "text": "8" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Return type must be List<Father> or subtype.\nArrayList<Father> is subtype of List<Father>.\nList<Son> is NOT subtype of List<Father> (Generics are invariant).\nOnly List<Father> and ArrayList<Father> are valid return types.\nAnswer: 2 definitions."
      },
      {
        "id": 16,
        "type": "multiple",
        "questionText": "Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print 3 on to the console? Select 3 options.",
        "codeSnippet": "public class Test {\n    public static void main(String[] args) {\n        /*INSERT*/ x = 7, y = 200;\n        System.out.println(String.valueOf(x + y).length());\n    }\n}",
        "options": [
          { "id": "A", "text": "short" },
          { "id": "B", "text": "int" },
          { "id": "C", "text": "long" },
          { "id": "D", "text": "byte" },
          { "id": "E", "text": "double" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "byte: 200 is out of range. Compile error.\nshort, int, long: x+y = 207. String length is 3.\nfloat, double: x+y = 207.0. String length is 5.\nCorrect options: short, int, long."
      },
      {
        "id": 17,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        boolean flag = false;\n        do {\n            if(flag = !flag) { //Line n1\n                System.out.print(1); //Line n2\n                continue; //Line n3\n            }\n            System.out.print(2); //Line n4\n        } while(flag); //Line n5\n    }\n}",
        "options": [
          { "id": "A", "text": "12" },
          { "id": "B", "text": "1" },
          { "id": "C", "text": "1212..." },
          { "id": "D", "text": "2" }
        ],
        "correctAnswers": ["A"],
        "explanation": "1st pass: flag becomes true. if(true) -> prints 1. continue checks while(flag) -> true. Loop again.\n2nd pass: flag becomes false. if(false) -> else (no else). prints 2. while(flag) -> false. Loop ends.\nOutput: 12"
      },
      {
        "id": 18,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nclass A {\n    public String toString() {\n        return null;\n    }\n}\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = null;\n        text = text + new A(); //Line n1\n        System.out.println(text.length()); //Line n2\n    }\n}",
        "options": [
          { "id": "A", "text": "8" },
          { "id": "B", "text": "4" },
          { "id": "C", "text": "NullPointerException" },
          { "id": "D", "text": "0" }
        ],
        "correctAnswers": ["A"],
        "explanation": "text is null -> converts to string \"null\".\nnew A().toString() returns null. String concat handles null return by using string \"null\".\nResult: \"null\" + \"null\" = \"nullnull\". Length is 8."
      },
      {
        "id": 19,
        "type": "single",
        "questionText": "What will be the result of compiling and executing above code?",
        "codeSnippet": "public class TestBook {\n    public static void main(String[] args) {\n        private Book book = new Book(\"Head First Java\", \"Kathy Sierra\");\n        System.out.println(book.getName());\n        System.out.println(book.getAuthor());\n    }\n}",
        "options": [
          { "id": "A", "text": "Head First Java" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "null" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Local variables cannot have access modifiers (private). Compilation error."
      },
      {
        "id": 20,
        "type": "single",
        "questionText": "How many of above x,y pair(s) can replace x and y at Line n1 such that Test.java file compiles successfully?",
        "codeSnippet": "int[][] arr = new int[x][y]; //Line n1",
        "options": [
          { "id": "A", "text": "All 7 pairs" },
          { "id": "B", "text": "Only positive pairs" },
          { "id": "C", "text": "None" },
          { "id": "D", "text": "2 pairs" }
        ],
        "correctAnswers": ["A"],
        "explanation": "For compilation, any int expression is allowed for array dimension. Runtime behavior (NegativeArraySizeException) is ignored for this question. All 7 pairs compile."
      },
      {
        "id": 21,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        boolean flag = false;\n        System.out.println((flag = true) | (flag = false) || (flag = true));\n        System.out.println(flag);\n    }\n}",
        "options": [
          { "id": "A", "text": "true\nfalse" },
          { "id": "B", "text": "true\ntrue" },
          { "id": "C", "text": "false\nfalse" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "(flag=true) | (flag=false) evaluates to true. flag is false (last assignment).\ntrue || ... evaluates to true (short circuit).\nPrints true.\nThen prints flag, which is false."
      },
      {
        "id": 22,
        "type": "single",
        "questionText": "How many of the above statements is/are true?",
        "codeSnippet": "package main;\n \npublic class main {\n    static String main = \"ONE\";\n \n    public main() {\n        System.out.println(\"TWO\");\n    }\n \n    public static void main(String [] args) {\n        main();\n    }\n \n    public static void main() {\n        System.out.println(main);\n    }\n}",
        "options": [
          { "id": "A", "text": "Code doesn't compile" },
          { "id": "B", "text": "Code compiles, prints ONE" },
          { "id": "C", "text": "Code compiles, prints TWO" },
          { "id": "D", "text": "Runtime Error" }
        ],
        "correctAnswers": ["B"],
        "explanation": "It is valid to have class, method, and variable named 'main'.\nmain(String[]) calls static main(), which prints variable main (\"ONE\").\nConstructor is not called.\nCorrect option is that code compiles and prints ONE."
      },
      {
        "id": 23,
        "type": "single",
        "questionText": "What will be the result of compiling and executing AvoidThreats class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \npublic class AvoidThreats {\n    public static void evaluate(Threat t) { //Line n5\n        t = new Threat(); //Line n6\n        t.name = \"PHISHING\"; //Line n7\n    }\n \n    public static void main(String[] args) {\n        Threat obj = new Threat(); //Line n1\n        obj.print(); //Line n2\n        evaluate(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}\n \nclass Threat {\n    String name = \"VIRUS\";\n \n    public void print() {\n        System.out.println(name);\n    }\n}",
        "options": [
          { "id": "A", "text": "VIRUS\nVIRUS" },
          { "id": "B", "text": "VIRUS\nPHISHING" },
          { "id": "C", "text": "PHISHING\nPHISHING" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Java passes references by value. In evaluate(), 't' is reassigned to a new object. Modification to 't's name affects the new object, not 'obj' in main.\nOutput: VIRUS, then VIRUS again."
      },
      {
        "id": 24,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    static int i1 = 10;\n    int i2 = 20;\n \n    int add() {\n        return this.i1 + this.i2; //Line n1\n    }\n \n    public static void main(String[] args) {\n        System.out.println(new Test().add()); //Line n2\n    }\n}",
        "options": [
          { "id": "A", "text": "30" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "1020" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Static variable i1 can be accessed via 'this.i1' (though not recommended). Code compiles and prints 30."
      },
      {
        "id": 25,
        "type": "single",
        "questionText": "Which of the following statements is true for above code?",
        "codeSnippet": "Base b = null;\nDerived d = (Derived) b; //Line n3\nd.print(); //Line n4",
        "options": [
          { "id": "A", "text": "Prints DERIVED" },
          { "id": "B", "text": "NullPointerException" },
          { "id": "C", "text": "ClassCastException" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Casting null to Derived is valid (b is null). d becomes null.\nd.print() invokes static method. Static methods are bound to class type, not object instance. No NPE.\nDerived.print() is called. Prints DERIVED."
      },
      {
        "id": 26,
        "type": "single",
        "questionText": "How many statements are legal?",
        "codeSnippet": "1. int x = 5____0;\n2. int y = ____50;\n3. int z = 50____;\n4. float f = 123.76_86f;\n5. double d = 1_2_3_4;",
        "options": [
          { "id": "A", "text": "1" },
          { "id": "B", "text": "2" },
          { "id": "C", "text": "3" },
          { "id": "D", "text": "4" }
        ],
        "correctAnswers": ["C"],
        "explanation": "Underscores must be between digits.\n1. Valid (50).\n2. Invalid (start).\n3. Invalid (end).\n4. Valid.\n5. Valid.\n3 statements are legal."
      },
      {
        "id": 27,
        "type": "single",
        "questionText": "Which of the following statements is correct?",
        "codeSnippet": "Counter [] arr = new Counter[2]; //Line n2\nfor(Counter ctr : arr) {\n    System.out.print(ctr.count); //Line n3\n}",
        "options": [
          { "id": "A", "text": "1010" },
          { "id": "B", "text": "NullPointerException" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "00" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Counter.count is static (interface field). Accessing static field via null reference (ctr) is allowed. Prints 10 twice."
      },
      {
        "id": 28,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "String str = \"ALASKA\";\nSystem.out.println(str.charAt(str.indexOf(\"A\") + 1));",
        "options": [
          { "id": "A", "text": "L" },
          { "id": "B", "text": "A" },
          { "id": "C", "text": "S" },
          { "id": "D", "text": "K" }
        ],
        "correctAnswers": ["A"],
        "explanation": "indexOf(\"A\") returns 0. charAt(1) returns 'L'."
      },
      {
        "id": 29,
        "type": "single",
        "questionText": "How many definitions of main method can replace /* INSERT */ such that \"Java Rocks!\" is printed?",
        "codeSnippet": "/* INSERT */",
        "options": [
          { "id": "A", "text": "1" },
          { "id": "B", "text": "2" },
          { "id": "C", "text": "3" },
          { "id": "D", "text": "4" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Valid special main signatures:\n1. public static final void main(String... a)\n4. public static void main(String [] args)\n2 definitions work."
      },
      {
        "id": 30,
        "type": "multiple",
        "questionText": "Which of the following declarations/definitions can replace /*INSERT*/ such that there is no compilation error? Select 5 options.",
        "codeSnippet": "abstract class Traveller {\n    void travel(String place){}\n}\n \nabstract class BeachTraveller extends Traveller {\n    /*INSERT*/\n}",
        "options": [
          { "id": "A", "text": "abstract void travel();" },
          { "id": "B", "text": "abstract void travel(String beach);" },
          { "id": "C", "text": "public abstract void travel();" },
          { "id": "D", "text": "public void travel() throws RuntimeException {}" },
          { "id": "E", "text": "public void travel(Object obj) {}" }
        ],
        "correctAnswers": ["A", "B", "C", "D", "E"],
        "explanation": "All listed options are valid overloadings or abstract overrides permitted in an abstract subclass."
      },
      {
        "id": 31,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "package d;\nimport a.Animal;\npublic class Dog extends Animal {\n    public Dog() {\n        System.out.print(\"DOG\");\n    }\n}",
        "options": [
          { "id": "A", "text": "ANIMAL-DOG" },
          { "id": "B", "text": "Compilation error in Dog.java" },
          { "id": "C", "text": "Compilation error in Test.java" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Dog constructor implicitly calls super(). Animal() constructor is package-private (in package 'a'). Dog is in package 'd'. Not visible. Compilation error."
      },
      {
        "id": 32,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "int val = 25;\nif(val++ < 26) {\n    System.out.println(val++);\n}",
        "options": [
          { "id": "A", "text": "26" },
          { "id": "B", "text": "25" },
          { "id": "C", "text": "27" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "val++ < 26 -> 25 < 26 (true), val becomes 26.\nInside if: print val++ -> prints 26, val becomes 27."
      },
      {
        "id": 33,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "String[] arr = { \"L\", \"I\", \"V\", \"E\" };\nint i = -2;\nif (i++ == -1) { ... } // false\nelse if (--i == -2) { // true\n    arr[-++i] = \"O\"; // arr[1] = \"O\"\n}",
        "options": [
          { "id": "A", "text": "LOVE" },
          { "id": "B", "text": "LIVE" },
          { "id": "C", "text": "LIVF" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "The logic modifies arr[1] to \"O\". Loop prints elements. Result: LOVE."
      },
      {
        "id": 34,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "System.out.println(!flag1 == flag2 != flag3 == !flag4);\nSystem.out.println(flag1 = flag2 != flag3 == !flag4);",
        "options": [
          { "id": "A", "text": "false\ntrue" },
          { "id": "B", "text": "true\ntrue" },
          { "id": "C", "text": "false\nfalse" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Expression 1 evaluates to false.\nExpression 2 assigns true to flag1 and prints true.\nOutput: false\ntrue"
      },
      {
        "id": 35,
        "type": "single",
        "questionText": "What is the result?",
        "codeSnippet": "try {\n    try {\n        System.out.println(args[1]);\n    } catch(RuntimeException e) {\n        System.out.print(\"INHALE-\");\n        throw e;\n    } finally {\n        System.out.print(\"EXHALE-\");\n    }\n} catch(RuntimeException e) {\n    System.out.print(\"INHALE-\");\n} finally {\n    System.out.print(\"EXHALE\");\n}",
        "options": [
          { "id": "A", "text": "INHALE-EXHALE-INHALE-EXHALE" },
          { "id": "B", "text": "INHALE-EXHALE-" },
          { "id": "C", "text": "INHALE-INHALE-EXHALE-EXHALE-" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Inner catch: INHALE-. Inner finally: EXHALE-. Outer catch: INHALE-. Outer finally: EXHALE."
      },
      {
        "id": 36,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "public String generateReport() { return \"CSV\"; }\npublic Object generateReport() { return \"XLSX\"; }",
        "options": [
          { "id": "A", "text": "CSV:XLSX" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "None of the above" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Methods have same signature (name + params). Return type is not part of signature. Duplicate method error."
      },
      {
        "id": 37,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "catch (Exception e) {\n    e = null;\n    throw e;\n}",
        "options": [
          { "id": "A", "text": "NOT AVAILABLE" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "NullPointerException" },
          { "id": "D", "text": "No output" }
        ],
        "correctAnswers": ["B"],
        "explanation": "Modifying 'e' prevents precise rethrow. 'throw e' is treated as throwing Exception. Method only throws SQLException. Compilation error."
      },
      {
        "id": 38,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "Profitable obj = new Business();\nSystem.out.println(obj.profitPercentage);",
        "options": [
          { "id": "A", "text": "42.0" },
          { "id": "B", "text": "50.0" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Variable access is not polymorphic. obj is Profitable. Accesses Profitable.profitPercentage (42.0)."
      },
      {
        "id": 39,
        "type": "multiple",
        "questionText": "Which of the following code segments, written inside main method will compile successfully? Select 3 options.",
        "codeSnippet": "",
        "options": [
          { "id": "A", "text": "short s1 = 10;" },
          { "id": "B", "text": "final int i3 = 10; short s3 = i3;" },
          { "id": "C", "text": "final int i5 = 10; short s5 = i5 + 100;" },
          { "id": "D", "text": "short s2 = 32768;" },
          { "id": "E", "text": "int i7 = 10; short s7 = i7;" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "A: Implicit narrowing of literal. B: Implicit narrowing of final variable. C: Implicit narrowing of constant expression."
      },
      {
        "id": 40,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "System.out.println(sb.reverse().replace(\"O\", \"A\"));",
        "options": [
          { "id": "A", "text": "TAMATA" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "OTAMAT" }
        ],
        "correctAnswers": ["B"],
        "explanation": "StringBuilder.replace takes (int, int, String). replace(\"O\", \"A\") is invalid."
      },
      {
        "id": 41,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "String [] arr = new String[7];\nSystem.out.println(arr);",
        "options": [
          { "id": "A", "text": "Text containing @" },
          { "id": "B", "text": "[null, null, ...]" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Empty String" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Default toString() on array prints classname@hashcode."
      },
      {
        "id": 42,
        "type": "single",
        "questionText": "Which of the following needs to be done so that LIGHT is printed on to the console?",
        "codeSnippet": "void speed(Byte val) { ... }\nvoid speed(byte... vals) { ... }\n// call: new Car().speed(b); where b is byte",
        "options": [
          { "id": "A", "text": "Delete speed(Byte) method" },
          { "id": "B", "text": "Pass explicit array" },
          { "id": "C", "text": "Cast to byte[]" },
          { "id": "D", "text": "None" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Boxing (Byte) is preferred over Varargs. Deleting speed(Byte) forces usage of speed(byte...)."
      },
      {
        "id": 43,
        "type": "multiple",
        "questionText": "Which 3 modifications, done independently, enable the code to compile?",
        "codeSnippet": "abstract class Food { protected abstract double getCalories(); }\nclass JunkFood extends Food { double getCalories() { return 200.0; } }",
        "options": [
          { "id": "A", "text": "Remove protected from Food" },
          { "id": "B", "text": "Make JunkFood method protected" },
          { "id": "C", "text": "Make JunkFood method public" },
          { "id": "D", "text": "Make Food method private" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "Cannot reduce visibility. JunkFood (package) < Food (protected). Need to make JunkFood protected/public OR make Food package."
      },
      {
        "id": 44,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "for(System.out.print(i++); i < 2; System.out.print(i++)) {\n    System.out.print(i);\n}",
        "options": [
          { "id": "A", "text": "011" },
          { "id": "B", "text": "012" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Infinite loop" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Sequence: Init(0), Check(1<2), Body(1), Update(1), Check(2<2 fail). Output 011."
      },
      {
        "id": 45,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "ILogger [] loggers = new ILogger[2];\nfor(ILogger logger : loggers)\n    logger.log();",
        "options": [
          { "id": "A", "text": "NullPointerException" },
          { "id": "B", "text": "No output" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Logs nothing" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Array initialized to nulls. logger.log() throws NPE."
      },
      {
        "id": 46,
        "type": "multiple",
        "questionText": "Which of the options can be used to replace /*INSERT*/ such that there is no compilation error? Select 5 options.",
        "codeSnippet": "interface Multiplier { void multiply(int... x) throws SQLException; }",
        "options": [
          { "id": "A", "text": "SQLException" },
          { "id": "B", "text": "SQLWarning" },
          { "id": "C", "text": "RuntimeException" },
          { "id": "D", "text": "Error" },
          { "id": "E", "text": "NullPointerException" }
        ],
        "correctAnswers": ["A", "B", "C", "D", "E"],
        "explanation": "Overriding method can throw same checked, subclass of checked, or any unchecked exception."
      },
      {
        "id": 47,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "Sellable obj = new Chair();\nSystem.out.println(obj.symbol() + obj.getPrice());",
        "options": [
          { "id": "A", "text": "35.0" },
          { "id": "B", "text": "$35.0" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Runtime Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Chair overrides default symbol() with \"\". getPrice() is 35. Output 35.0."
      },
      {
        "id": 48,
        "type": "single",
        "questionText": "Which of the following statements is correct?",
        "codeSnippet": "Sub sub = null;\nSystem.out.println(sub.name);",
        "options": [
          { "id": "A", "text": "SUPER" },
          { "id": "B", "text": "NullPointerException" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "No output" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Accessing static field via null reference is valid. Prints SUPER."
      },
      {
        "id": 49,
        "type": "single",
        "questionText": "Which of the following statements is correct?",
        "codeSnippet": "public class Dog extends Animal implements Moveable {}",
        "options": [
          { "id": "A", "text": "Compilation error" },
          { "id": "B", "text": "Compiles successfully" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "ANIMAL MOVING" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Dog inherits package-private move(). Moveable requires public move(). Dog fails to implement interface method with correct visibility."
      },
      {
        "id": 50,
        "type": "single",
        "questionText": "Which of the following statements is true for above code?",
        "codeSnippet": "class N extends M {\n    public static void main(String[] args) { ... } \n}",
        "options": [
          { "id": "A", "text": "Compilation error at Line n2" },
          { "id": "B", "text": "Compiles and runs" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "Prints M" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Static method cannot hide instance method. M has instance main(). N tries to define static main(). Error."
      },
      {
        "id": 51,
        "type": "single",
        "questionText": "What is the result?",
        "codeSnippet": "java Test \"James Gosling\" \"Bill Joy\"",
        "options": [
          { "id": "A", "text": "Welcome James Gosling!" },
          { "id": "B", "text": "Welcome James!" },
          { "id": "C", "text": "Welcome \"James Gosling\"!" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Arguments are grouped by quotes. args[0] is \"James Gosling\"."
      },
      {
        "id": 52,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "P p = new R();\nSystem.out.println(p.compute(\"Go\"));",
        "options": [
          { "id": "A", "text": "gogogo" },
          { "id": "B", "text": "GOGOGO" },
          { "id": "C", "text": "GoGoGo" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "R calls Q (super). Q calls P (super) with lowerCase. P returns triple string. Result: gogogo."
      },
      {
        "id": 53,
        "type": "multiple",
        "questionText": "Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print true on to the console? Select 2 options.",
        "codeSnippet": "String s1 = \"OCP\"; String s2 = \"ocp\";",
        "options": [
          { "id": "A", "text": "s1.length() == s2.length()" },
          { "id": "B", "text": "s1.equalsIgnoreCase(s2)" },
          { "id": "C", "text": "s1.equals(s2)" },
          { "id": "D", "text": "s1.contentEquals(s2)" }
        ],
        "correctAnswers": ["A", "B"],
        "explanation": "Length is 3 for both. equalsIgnoreCase is true. equals is false."
      },
      {
        "id": 54,
        "type": "single",
        "questionText": "What will be the result of compiling and executing above code?",
        "codeSnippet": "Shape s = new Square();\nSystem.out.println(s.side + \":\" + s.getSide());",
        "options": [
          { "id": "A", "text": "0:4" },
          { "id": "B", "text": "4:4" },
          { "id": "C", "text": "0:0" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Variable hiding: s.side uses Shape's side (0). Method overriding: s.getSide() uses Square's (4)."
      },
      {
        "id": 55,
        "type": "multiple",
        "questionText": "Which three modifications, done independently, print 1000 on to the console? Select 3.",
        "codeSnippet": "Child obj = new Child();\nSystem.out.println(obj.var); //Error",
        "options": [
          { "id": "A", "text": "Delete Line n2" },
          { "id": "B", "text": "Change Line n4 to Parent obj = new Child();" },
          { "id": "C", "text": "Change Line n5 to System.out.println(obj.getVar());" },
          { "id": "D", "text": "Change Line n1 to private" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "A: Removes hiding private var. B: Access via Parent ref. C: getVar() uses super.var."
      },
      {
        "id": 56,
        "type": "single",
        "questionText": "Which of the following needs to be done so that there is no compilation error?",
        "codeSnippet": "public abstract class Profit implements Profitable1, Profitable2 { /*INSERT*/ }",
        "options": [
          { "id": "A", "text": "public double profit() { return Profitable2.super.profit(); }" },
          { "id": "B", "text": "No modification needed" },
          { "id": "C", "text": "double profit() { return 50.0; }" },
          { "id": "D", "text": "public default double profit() { ... }" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Must resolve default method conflict. Syntax: Interface.super.method()."
      },
      {
        "id": 57,
        "type": "multiple",
        "questionText": "How many of the above options can be used to replace /*INSERT*/ to print BUS? Select 3.",
        "codeSnippet": "String word = \"REBUS\";",
        "options": [
          { "id": "A", "text": "word.substring(2)" },
          { "id": "B", "text": "word.substring(2, 5)" },
          { "id": "C", "text": "word.replace(\"RE\", \"\")" },
          { "id": "D", "text": "word.substring(2, 6)" },
          { "id": "E", "text": "word.delete(0, 2)" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "Options A, B, C produce BUS. D is out of bounds. E is invalid (String has no delete)."
      },
      {
        "id": 58,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "try { div(); } finally { System.out.println(\"FINALLY\"); }",
        "options": [
          { "id": "A", "text": "FINALLY" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "No output" },
          { "id": "D", "text": "FINALLY followed by Stack Trace" }
        ],
        "correctAnswers": ["D"],
        "explanation": "div() throws ArithmeticException. Finally executes. Exception propagates."
      },
      {
        "id": 59,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "m('A'); m('A', 'B'); m('A', 'B', 'C'); m('A', 'B', 'C', 'D');",
        "options": [
          { "id": "A", "text": "1233" },
          { "id": "B", "text": "1111" },
          { "id": "C", "text": "3333" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Implicit cast to int preferred over varargs. m(int), m(int,int) called first."
      },
      {
        "id": 60,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "List<String> subList = list.subList(1, 2);\nsubList.set(0, \"E\");\nSystem.out.println(list);",
        "options": [
          { "id": "A", "text": "[P, E, T]" },
          { "id": "B", "text": "[P, O, T]" },
          { "id": "C", "text": "[P, E]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "subList changes affect original list."
      },
      {
        "id": 61,
        "type": "single",
        "questionText": "What is the result?",
        "codeSnippet": "LocalDate date = LocalDate.parse(\"1983-06-30\");\nSystem.out.println(date.plusMonths(8));",
        "options": [
          { "id": "A", "text": "1984-02-29" },
          { "id": "B", "text": "1984-02-28" },
          { "id": "C", "text": "1984-02-30" },
          { "id": "D", "text": "Exception" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Feb 1984 is leap year. 30th invalid, adjusts to 29th."
      },
      {
        "id": 62,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "search(\"virat.pdf\") // Loop i <= 4",
        "options": [
          { "id": "A", "text": "Runtime Exception (ArrayIndexOutOfBounds)" },
          { "id": "B", "text": "NOT FOUND" },
          { "id": "C", "text": "FOUND" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Loop exceeds array bounds."
      },
      {
        "id": 63,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "Exception ex = new Exception(e);\nthrow ex;",
        "options": [
          { "id": "A", "text": "Compilation error" },
          { "id": "B", "text": "END" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "No output" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Throwing checked Exception in method not declaring it."
      },
      {
        "id": 64,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "k += i + j; // Labeled loop logic",
        "options": [
          { "id": "A", "text": "15" },
          { "id": "B", "text": "11" },
          { "id": "C", "text": "6" },
          { "id": "D", "text": "Infinite loop" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Calculates sum correctly to 15."
      },
      {
        "id": 65,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "list.removeIf(sb -> sb.equals(new StringBuilder(\"AAA\")));",
        "options": [
          { "id": "A", "text": "[AAA, BBB, AAA]" },
          { "id": "B", "text": "[BBB]" },
          { "id": "C", "text": "[]" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "StringBuilder.equals uses reference equality. New object not equal to existing ones. Removes nothing."
      },
      {
        "id": 66,
        "type": "multiple",
        "questionText": "Which of the block of codes can be used to replace /*INSERT*/ such that there is no compilation error? Select 3 options.",
        "codeSnippet": "/*INSERT*/",
        "options": [
          { "id": "A", "text": "catch(IOException | SQLException ex) {}" },
          { "id": "B", "text": "catch(SQLException | IOException ex) {}" },
          { "id": "C", "text": "catch(Exception ex) {}" },
          { "id": "D", "text": "catch(Exception | RuntimeException ex) {}" }
        ],
        "correctAnswers": ["A", "B", "C"],
        "explanation": "Multi-catch disjoint checked exceptions is valid. Catching superclass Exception is valid."
      },
      {
        "id": 67,
        "type": "single",
        "questionText": "Which of the following statements is correct?",
        "codeSnippet": "AntMan.shrinkPercentage();",
        "options": [
          { "id": "A", "text": "Compilation error" },
          { "id": "B", "text": "80%" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "No output" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Interface static methods are not inherited. Must use Interface.method()."
      },
      {
        "id": 68,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "new Child();",
        "options": [
          { "id": "A", "text": "HAKUNAMATATA" },
          { "id": "B", "text": "Compilation error" },
          { "id": "C", "text": "Runtime Exception" },
          { "id": "D", "text": "MATATA" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Constructor chaining with exceptions handled correctly."
      },
      {
        "id": 69,
        "type": "single",
        "questionText": "What will be the result of compiling and executing Test class?",
        "codeSnippet": "M obj1 = new M();\nN obj2 = (N)obj1;",
        "options": [
          { "id": "A", "text": "ClassCastException" },
          { "id": "B", "text": "N" },
          { "id": "C", "text": "M" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Downcasting super instance to sub type fails at runtime."
      },
      {
        "id": 70,
        "type": "single",
        "questionText": "What is the result?",
        "codeSnippet": "args[1] = \"Day!\";",
        "options": [
          { "id": "A", "text": "Runtime Exception (ArrayIndexOutOfBounds)" },
          { "id": "B", "text": "Good Day!" },
          { "id": "C", "text": "Compilation error" },
          { "id": "D", "text": "Good" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Args array size is 1. Accessing index 1 fails."
      },
      {
        "id": 71,
        "type": "single",
        "questionText": "Which of the above options needs to be done so that on executing TestCreator class, \"Planet: Earth\" is printed?",
        "codeSnippet": "// Imports",
        "options": [
          { "id": "A", "text": "Import Planet in Creator and Creator in TestCreator" },
          { "id": "B", "text": "Import Planet in TestCreator" },
          { "id": "C", "text": "No imports needed" },
          { "id": "D", "text": "Import TestCreator in Creator" }
        ],
        "correctAnswers": ["A"],
        "explanation": "Cross-package usage requires imports."
      },
      {
        "id": 72,
        "type": "single",
        "questionText": "What will be the result of compiling and executing TestSquare class?",
        "codeSnippet": "package com.udayankhattry.oca;\n \nclass Square {\n    int length;\n    Square sq;\n \n    Square(int length) {\n        this.length = length;\n    }\n \n    void setInner(Square sq) {\n        this.sq = sq;\n    }\n \n    int getLength() {\n        return this.length;\n    }\n}\n \npublic class TestSquare {\n    public static void main(String[] args) {\n        Square sq1 = new Square(10); //Line n1\n        Square sq2 = new Square(5); //Line n2\n        sq1.setInner(sq2); //Line n3\n        System.out.println(sq1.sq.length); //Line n4\n    }\n}",
        "options": [
          { "id": "A", "text": "5" },
          { "id": "B", "text": "10" },
          { "id": "C", "text": "NullPointerException" },
          { "id": "D", "text": "Compilation error" }
        ],
        "correctAnswers": ["A"],
        "explanation": "As both the classes: Square and TestSquare are in the same file, hence variables 'length' and 'sq' can be accessed using dot operator.\nGiven code compiles successfully.\nLine n1 creates an instance of Square class and 'sq1' refers to it. sq1.length = 10 and sq1.sq = null.\nLine n2 creates an instance of Square class and 'sq2' refers to it. sq2.length = 5 and sq2.sq = null.\nOn execution of Line n3, sq1.sq = sq2.\nLine n4: System.out.println(sq1.sq.length); => System.out.println(sq2.length);\n=> Prints 5 on to the console."
      }
    ]},
  {
    "id": 6,
    "name": "OCA Practice Exam 6",
    "description": "Set 6",
    "questions": [
        {
          "id": 1,
          "type": "single",
          "questionText": "What is the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        char c1 = 'a'; //ASCII code of 'a' is 97\n        int i1 = c1; //Line n1\n        System.out.println(i1); //Line n2\n    }\n}",
          "options": [
            { "id": "A", "text": "97" },
            { "id": "B", "text": "a" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Range of char data type is from 0 to 65535 and hence it can be easily assigned to int type.\nprintln() method is overloaded to accept char type and int type both.\nIf char type value is passed, it prints char value and if int type value is passed, it prints int value.\nAs i1 is of int type, hence corresponding int value, which is 97, is printed on to the console."
        },
        {
          "id": 2,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        boolean status = true;\n        System.out.println(status = false || status = true | status = false);\n        System.out.println(status);\n    }\n}",
          "options": [
            { "id": "A", "text": "true" },
            { "id": "B", "text": "false" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["C"],
          "explanation": "System.out.println(status = false || status = true | status = false);\nAs it contains multiple operators, hence let's group the operators first.\nSystem.out.println(status = false || status = (true | status) = false); //Bitwise inclusive OR |\nhas highest precedence over logical or || and assignment =\nFor assignment operator to work, left operand must be variable but in above case, `(true | status) = false` causes compilation failure as left operand (true | status) evaluates to a boolean value and not boolean variable."
        },
        {
          "id": 3,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int var = 3;\n        String [][] arr = new String[--var][var++]; //Line n1\n        arr[1][1] = \"X\"; //Line n2\n        arr[1][2] = \"Y\"; //Line n3\n        for(String [] arr1 : arr) {\n            for(String s : arr1) {\n                if(s != null)\n                    System.out.print(s);\n            }\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "XY" },
            { "id": "B", "text": "Compilation error" },
            { "id": "C", "text": "ArrayIndexOutOfBoundsException" },
            { "id": "D", "text": "NullPointerException" }
          ],
          "correctAnswers": ["C"],
          "explanation": "Line n1:\nString [][] arr = new String[--var][var++]; //var = 3\nAccess array element operator [] is left to right associative.\n=> String [][] arr = new String[2][var++]; //var = 2, var is decremented first and then used in the expression.\n=> String [][] arr = new String[2][2]; //var = 3, value of var is used first and then it is incremented by 1\nHence, arr refers to 2-dimensional String array object {{null, null}, {null, null}}.\nAt Line n2, arr[1][1] = \"X\"; assigns \"X\" to element at index [1][1], therefore arr --> {{null, null}, {null, \"X\"}}\nAt Line n3, arr[1][2] = \"Y\"; causes ArrayIndexOutOfBoundsException as 2nd index 2 is out of range.\nAs Line n3 throws Exception at runtime, hence for loop will not be executed."
        },
        {
          "id": 4,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void getData() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            e = new SQLException();\n            throw e;\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            getData();\n        } catch(SQLException e) {\n            System.out.println(\"SQL\");\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "SQL" },
            { "id": "B", "text": "Compilation error" },
            { "id": "C", "text": "Runtime Exception" },
            { "id": "D", "text": "No output" }
          ],
          "correctAnswers": ["B"],
          "explanation": "If you don't initialize variable e inside catch block using `e = new SQLException();` and simply throw e, then code would compile successfully as compiler is certain that 'e' would refer to an instance of SQLException only.\nBut the moment compiler finds `e = new SQLException();`, `throw e;` causes compilation error as at runtime 'e' may refer to any Exception type."
        },
        {
          "id": 5,
          "type": "single",
          "questionText": "Which of the following statements is correct?",
          "codeSnippet": "//I1.java\npackage com.udayankhattry.oca;\n\npublic interface I1 {\n    int i = 10;\n}\n//I2.java\npackage com.udayankhattry.oca;\n\npublic interface I2 {\n    int i = 20;\n}\n//I3.java\npackage com.udayankhattry.oca;\n\npublic interface I3 extends I1, I2 { //Line n1\n\n}\n//Test.java\npackage com.udayankhattry.oca;\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(I1.i); //Line n2\n        System.out.println(I2.i); //Line n3\n        System.out.println(I3.i); //Line n4\n    }\n}",
          "options": [
            { "id": "A", "text": "Prints 10" },
            { "id": "B", "text": "Prints 20" },
            { "id": "C", "text": "Compilation error at Line n4" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["C"],
          "explanation": "Variable 'i' declared inside interface I1 is implicitly public, static and final and similarly variable i declared inside interface I2 is implicitly public, static and final as well.\nIn Java a class can extend from only one class but an interface can extend from multiple interfaces.\nstatic variables are not inherited and hence there is no issue with Line n1.\nI1.i points to variable 'i' of interface I1.\nI2.i points to variable 'i' of interface I2.\nI3.i is an ambiguous call as compiler is not sure whether to point to I1.i or I2.i and therefore, Line n4 causes compilation error."
        },
        {
          "id": 6,
          "type": "single",
          "questionText": "Which of the following statements is correct?",
          "codeSnippet": "//GetSetGo.java\npackage com.udayankhattry.oca;\n\npublic interface GetSetGo {\n    int count = 1; //Line n1\n}\n//Test.java\npackage com.udayankhattry.oca;\n\npublic class Test {\n    public static void main(String[] args) {\n        GetSetGo [] arr = new GetSetGo[5]; //Line n2\n        for(GetSetGo obj : arr) {\n            obj.count++; //Line n3\n        }\n        System.out.println(GetSetGo.count); //Line n4\n    }\n}",
          "options": [
            { "id": "A", "text": "Prints 2" },
            { "id": "B", "text": "Compilation error at Line n3" },
            { "id": "C", "text": "NullPointerException" },
            { "id": "D", "text": "Prints 1" }
          ],
          "correctAnswers": ["B"],
          "explanation": "Variable 'count' declared inside interface GetSetGo is implicitly public, static and final.\nLine n1 compiles successfully.\nLine n2 creates one dimensional array of 5 elements of GetSetGo type and all 5 elements are initialized to null.\nLine n2 compiles successfully.\nThough correct way to refer static variable is by using the type name, such as GetSetGo.count but it can also be invoked by using GetSetGo reference variable.\nHence, obj.count at Line n3 correctly points to the count variable at Line n1.\nBut as variable 'count' is implicitly final, therefore obj.count++ causes compilation error. Line n3 fails to compile.\nLine n4 compiles successfully as variable 'count' is implicitly static and GetSetGo.count is the correct syntax to point to 'count' variable of interface GetSetGo."
        },
        {
          "id": 7,
          "type": "single",
          "questionText": "What will be the result of compiling and executing above code?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Super {\n    Super() {\n        System.out.print(\"Reach\");\n    }\n}\n \nclass Sub extends Super {\n    Sub() {\n        Super();\n        System.out.print(\"Out\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new Sub();\n    }\n}",
          "options": [
            { "id": "A", "text": "ReachOut" },
            { "id": "B", "text": "Reach" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["C"],
          "explanation": "Parent (Super) class constructor is invoked by `super();` (all letters in lowercase) from within the constructor of subclass.\nFirst statement inside no-argument constructor of Sub class is: `Super();` (Letter 'S' is in uppercase) and hence it causes compilation error."
        },
        {
          "id": 8,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    private static void div(int i, int j) {\n        try {\n            System.out.println(i / j);\n        } catch(ArithmeticException e) {\n            throw (RuntimeException)e;\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            div(5, 0);\n        } catch(ArithmeticException e) {\n            System.out.println(\"AE\");\n        } catch(RuntimeException e) {\n            System.out.println(\"RE\");\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "AE" },
            { "id": "B", "text": "RE" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Any RuntimeException can be thrown without any need it to be declared in throws clause of surrounding method.\n`throw (RuntimeException)e;` doesn't cause any compilation error.\nEven though variable 'e' is type casted to RuntimeException but exception object is still of ArithmeticException, which is caught in main method and 'AE' is printed to the console."
        },
        {
          "id": 9,
          "type": "single",
          "questionText": "Which of the options are correct so that instance variables 'testNo' and 'desc' are accessible only within 'com.udayankhattry.oca' package?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    String testNo;\n    String desc;\n    /*\n    Other codes...\n    */\n}",
          "options": [
            { "id": "A", "text": "No changes are necessary" },
            { "id": "B", "text": "Make them private" },
            { "id": "C", "text": "Make them protected" },
            { "id": "D", "text": "Make them public" }
          ],
          "correctAnswers": ["A"],
          "explanation": "As member variables 'testNo' and 'desc' are declared with no explicit access specifier, this means these variables have package scope, hence these variables are accessible only to classes within the same package.\nHence, no changes are necessary.\nIf you use private, then instance variables will not be accessible to any other classes, even within the same package.\nIf you use protected, then instance variables will be accessible to the subclasses outside 'com.udayankhattry.oca' package.\nIf you use public, then instance variables will be accessible to all the classes."
        },
        {
          "id": 10,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"B\"); //Line n1\n        sb.append(sb.append(\"A\")); //Line n2\n        System.out.println(sb); //Line n3\n    }\n}",
          "options": [
            { "id": "A", "text": "BA" },
            { "id": "B", "text": "BABA" },
            { "id": "C", "text": "BB" },
            { "id": "D", "text": "AB" }
          ],
          "correctAnswers": ["B"],
          "explanation": "At Line n1:\nsb --> {\"B\"}\nappend(...) method in StringBuilder class is overloaded to accept various arguments and 2 such arguments are String and CharSequence.\nIt's return type is StringBuilder and as StringBuilder class implements CharSequence interface, hence 'sb.append(\"A\")' can easily be passed as and argument to sb.append(...) method.\nLine n2 compiles successfully.\nAt Line n2:\nsb.append(sb.append(\"A\")); //sb --> {\"B\"}\nsb.append({\"BA\"}); //sb --> {\"BA\"}\n{\"BABA\"}\nHence, Line n3 prints BABA"
        },
        {
          "id": 11,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int [] arr = {10, 20, 30}; //Line n1\n        int i = 0;\n        arr[i++] = arr[++i] = 40; //Line n2\n        for(int x : arr)\n            System.out.println(x);\n    }\n}",
          "options": [
            { "id": "A", "text": "40 20 40" },
            { "id": "B", "text": "40 40 40" },
            { "id": "C", "text": "10 20 30" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "At Line n1, an int [] object of three elements is created and 'arr' refers to this array object.\narr[0] = 10, arr[1] = 20 and arr[2] = 30;\nGiven expression at Line n2:\narr[i++] = arr[++i] = 40;\nMultiple assignment operators are available, so lets group it first.\n=> arr[i++] = (arr[++i] = 40); //Assignment operator is right to left associative\nAbove expression is valid, hence Line n2 compiles successfully.\nLet's solve the expression now. Left operand is 'arr[i++]' and right operand is '(arr[++i] = 40)'.\nLeft operand is evaluated first.\n=> arr[0] = (arr[++i] = 40); //i = 1\nRight hand operand is evaluated next.\n=> arr[0] = (arr[2] = 40); //i = 2\n=> arr[0] = 40; //i = 2, arr[2] = 40.\nHence after Line n2, arr refers to int [] object {40, 20, 40}.\nGiven loop prints below on to the console:\n40\n20\n40"
        },
        {
          "id": 12,
          "type": "single",
          "questionText": "Which of the following statements is correct?",
          "codeSnippet": "package com.udayankhattry.oca;\n \ninterface M {\n    public static void log() {\n        System.out.println(\"M\");\n    }\n}\n \nabstract class A {\n    public static void log() {\n        System.out.println(\"N\");\n    }\n}\n \nclass MyClass extends A implements M {}\n \npublic class Test {\n    public static void main(String[] args) {\n        M obj1 = new MyClass();\n        obj1.log(); //Line n1\n\n        A obj2 = new MyClass();\n        obj2.log(); //Line n2\n\n        MyClass obj3 = new MyClass();\n        obj3.log(); //Line n3\n    }\n}",
          "options": [
            { "id": "A", "text": "Line n1 compiles successfully" },
            { "id": "B", "text": "Line n1 causes compilation error" },
            { "id": "C", "text": "Runtime Exception" },
            { "id": "D", "text": "Prints M" }
          ],
          "correctAnswers": ["B"],
          "explanation": "As per Java 8, default and static methods were added in the interface.\nInterface M defines static method log(), there is no compilation error in interface M.\nAlso the scope of static log() method of M is limited to interface M and it can be invoked by using Interface name only, M.log().\nAbstract class A also defines the static log() method. Abstract class can have 0 or more abstract methods.\nHence, no compilation error in class A as well.\nSuper type reference variable can refer to an instance of Sub type, therefore the statement `M obj1 = new MyClass();` compiles successfully.\nobj1 is of M type, hence `obj1.log();` tries to tag the static method of M but static log() method of M can only be invoked by using M.log();.\nTherefore, Line n1 causes compilation error.\nScope of static log() method of A is not limited to class A only but MyClass also gets A.log() method in its scope.\nHence, Line n2 and Line n3 compile successfully."
        },
        {
          "id": 13,
          "type": "single",
          "questionText": "What is the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int x = 10; //Line n1\n        if (false)\n            System.out.println(x); //Line n2\n        System.out.println(\"HELLO\"); //Line n3\n    }\n}",
          "options": [
            { "id": "A", "text": "HELLO" },
            { "id": "B", "text": "Compilation error (Unreachable code)" },
            { "id": "C", "text": "10\nHELLO" },
            { "id": "D", "text": "No output" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Even though compiler is aware that Line n2 will never execute, but it doesn't tag it as unreachable code.\nReason for this odd behavior is explained in the Java Language specification. `if (false) { x=3; }` does not result in a compile-time error. An optimizing compiler may realize that the statement x=3; will never be executed and may choose to omit the code for that statement from the generated class file.\nLine n2 is not executed but Line n3 executes successfully and prints HELLO on to the console."
        },
        {
          "id": 14,
          "type": "multiple",
          "questionText": "Above code causes compilation error, which modifications, done independently, enable the code to compile and on execution print 200 on to the console? Select 4 options.",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Super {\n    final int NUM = -1; //Line n1\n}\n \nclass Sub extends Super {\n    /*INSERT*/\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Sub obj = new Sub();\n        obj.NUM = 200; //Line n2\n        System.out.println(obj.NUM); //Line n3\n    }\n}",
          "options": [
            { "id": "A", "text": "Remove final modifier from Line n1" },
            { "id": "B", "text": "Replace /*INSERT*/ with short NUM;" },
            { "id": "C", "text": "Replace /*INSERT*/ with int NUM;" },
            { "id": "D", "text": "Replace /*INSERT*/ with Object NUM;" },
            { "id": "E", "text": "Replace /*INSERT*/ with double NUM;" }
          ],
          "correctAnswers": ["A", "B", "C", "D"],
          "explanation": "Variable NUM is declared in Super class and class Sub extends Super, hence NUM can be accessed by using obj.NUM.\nBut as NUM Is final, hence it cannot be reassigned, therefore Line n2 causes compilation error.\nLet's check all the options one by one:\nRemove final modifier from Line n1 => Valid option and in this case output is 200.\nReplace /*INSERT*/ with short NUM; => In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to short type. In this case output is 200.\nReplace /*INSERT*/ with int NUM; => In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to int type. In this case output is 200.\nReplace /*INSERT*/ with Object NUM; => In this case, class Sub hides the variable NUM of Super class and at Line n2, value 200 is boxed to Integer, which is then assigned to obj.NUM. So, obj.NUM refers to an instance of Integer class. Line n3 invokes toString() method of Integer class and hence 200 is printed on to the console.\nReplace /*INSERT*/ with double NUM; => Output in this case will be 200.0 and not 200."
        },
        {
          "id": 15,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        outer: for(int i = 0; i < 3; System.out.print(i)) {\n            i++;\n            inner: for(int j = 0; j < 3; System.out.print(j)) {\n                if(i > ++j) {\n                    break outer;\n                }\n            }\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "1231" },
            { "id": "B", "text": "0121" },
            { "id": "C", "text": "121" },
            { "id": "D", "text": "Infinite loop" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Given code compiles successfully. Let's check the iterations:\n1st iteration of outer: i = 0. i < 3 evaluates to true. i = 1.\n1st iteration of inner: j = 0. j < 3 evaluates to true. Boolean expression `i > ++j` = `1 > 1` evaluates to false. j = 1.\n2nd iteration of inner: `System.out.print(j)` prints 1. j < 3 evaluates to true. `i > ++j` = `1 > 2` evaluates to false. j = 2.\n3rd iteration of inner: `System.out.print(j)` prints 2. j < 3 evaluates to true. `i > ++j` = `1 > 3` evaluates to false. j = 3.\n4th iteration of inner: `System.out.print(j)` prints 3. j < 3 evaluates to false. Control goes out of inner loop.\n2nd iteration of outer: `System.out.print(i)` prints 1. i < 3 evaluates to true. i = 2.\n1st iteration of inner: j = 0. j < 3 evaluates to true. `i > ++j` = `2 > 1` evaluates to true.\nj = 1. `break outer;` takes the control out of the outer for loop.\nProgram terminates successfully after printing 1231 on to the console."
        },
        {
          "id": 16,
          "type": "single",
          "questionText": "_________ modifier is most restrictive and __________ modifier is least restrictive. Which of the following options (in below specified order) can be filled in above blank spaces?",
          "codeSnippet": "",
          "options": [
            { "id": "A", "text": "private, public" },
            { "id": "B", "text": "public, private" },
            { "id": "C", "text": "protected, default" },
            { "id": "D", "text": "default, protected" }
          ],
          "correctAnswers": ["A"],
          "explanation": "'private' is most restrictive, then comes 'default (with no access modifier specified)', after that 'protected' and finally 'public' is least restrictive."
        },
        {
          "id": 17,
          "type": "single",
          "questionText": "What will be the result of compiling and executing above code?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Base {\n    int id = 1000; //Line n1\n\n    Base() {\n        Base(); //Line n2\n    }\n\n    void Base() { //Line n3\n        System.out.println(++id); //Line n4\n    }\n}\n \nclass Derived extends Base {\n    int id = 2000; //Line n5\n\n    Derived() {} //Line n6\n\n    void Base() { //Line n7\n        System.out.println(--id); //Line n8\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base base = new Derived(); //Line n9\n    }\n}",
          "options": [
            { "id": "A", "text": "-1" },
            { "id": "B", "text": "1001" },
            { "id": "C", "text": "1999" },
            { "id": "D", "text": "2001" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Method can have same name as that of the Class. Line n2 invokes the Base() method and not the constructor.\nnew Derived() at Line n9 invokes the constructor of Derived class. Compiler adds super(); as the first statement.\nControl goes to Base class constructor. Instance variable id of Base class is initialized to 1000.\nLine n2 is executed next, Base() method defined in Derived class is executed (Polymorphism).\nLine n8 is executed next, Derived class hides the id variable of Base class and that is why at Line n8, id points to variable created at Line n5.\nThis id variable still stores the value 0 as Base class's constructor has not finishes its execution (Derived class instance variables are initialized after super constructor returns).\nvalue of id is decremented by 1, so id becomes -1 and -1 is printed on to the console."
        },
        {
          "id": 18,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = \"ONE \";\n        System.out.println(text.concat(text.concat(\"ELEVEN \")).trim());\n    }\n}",
          "options": [
            { "id": "A", "text": "ONE ONE ELEVEN" },
            { "id": "B", "text": "ONE ELEVEN" },
            { "id": "C", "text": "ONE" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Given statement: System.out.println(text.concat(text.concat(\"ELEVEN \")).trim()); //'text' refers to \"ONE \"\nSystem.out.println(text.concat(\"ONE ELEVEN \").trim()); //As String is immutable, 'text' still refers to \"ONE \"\nSystem.out.println((\"ONE ONE ELEVEN \").trim());\nSystem.out.println(\"ONE ONE ELEVEN\"); //trim() method removes the trailing space\nONE ONE ELEVEN is printed on to the console."
        },
        {
          "id": 19,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Counter {\n    static int ctr = 0;\n    int count = 0;\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Counter ctr1 = new Counter();\n        Counter ctr2 = new Counter();\n        Counter ctr3 = new Counter();\n\n        for(int i = 1; i <= 5; i++ ) {\n            ctr1.ctr++;\n            ctr1.count++;\n            ctr2.ctr++;\n            ctr2.count++;\n            ctr3.ctr++;\n            ctr3.count++;\n        }\n\n        System.out.println(ctr3.ctr + \":\" + ctr3.count);\n    }\n}",
          "options": [
            { "id": "A", "text": "15:5" },
            { "id": "B", "text": "5:5" },
            { "id": "C", "text": "15:15" },
            { "id": "D", "text": "5:15" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Each instance of the class contains separate copies of instance variable and share one copy of static variable.\nThere are 3 instances of Counter class created. As 'ctr' is a static variable, hence ctr1.ctr, ctr2.ctr and ctr3.ctr refer to the same variable.\nAs 'count' is an instance variable, so there are 3 separate copies.\nOn the completion of for loop: ctr1.count = 5, ctr2.count = 5 and ctr3.count = 5 and Counter.ctr = 15 (incremented 5 times for each of 3 objects = 15 times).\n15:5 is printed on to the console."
        },
        {
          "id": 20,
          "type": "single",
          "questionText": "Which of the following options is correct for compiling Test.java containing classes A, B, C, D?",
          "codeSnippet": "class A { public static void main(String [] args) { System.out.println(\"A\"); } }\nclass B { public static void main(String [] args) { System.out.println(\"B\"); } }\nclass C { public static void main(String [] args) { System.out.println(\"C\"); } }\nclass D { public static void main(String [] args) { System.out.println(\"D\"); } }",
          "options": [
            { "id": "A", "text": "javac Test.java creates A.class, B.class, C.class, D.class" },
            { "id": "B", "text": "javac Test.java creates Test.class" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Test.java is a valid java file. As none of the classes in Test.java file are public, hence file name can use any valid Java identifier.\nExecution of `javac Test.java` creates 4 class files: A.class, B.class, C.class & D.class."
        },
        {
          "id": 21,
          "type": "single",
          "questionText": "Which of the following statements is correct?",
          "codeSnippet": "package com.udayankhattry.oca;\n \ninterface Document {\n    default String getType() {\n        return \"TEXT\";\n    }\n}\n \ninterface WordDocument extends Document {\n    String getType();\n}\n \nclass Word implements WordDocument {}\n \npublic class Test {\n    public static void main(String[] args) {\n        Document doc = new Word(); //Line n1\n        System.out.println(doc.getType()); //Line n2\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error in Word" },
            { "id": "B", "text": "Compilation error in WordDocument" },
            { "id": "C", "text": "Compiles successfully" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "interface WordDocument extends Document and it overrides the default method getType() of Document with an abstract method.\nclass Word implements WordDocument and as WordDocument interface has abstract method getType(), and as class Word doesn't implement the getType() method hence it causes compilation failure."
        },
        {
          "id": 22,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.io.IOException;\n \nclass Super {\n    Super() throws RuntimeException {\n        System.out.print(\"CARPE \");\n    }\n}\n \nclass Sub extends Super {\n    Sub() throws IOException {\n        System.out.print(\"DIEM \");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        new Sub();\n    }\n}",
          "options": [
            { "id": "A", "text": "CARPE DIEM" },
            { "id": "B", "text": "Compilation error" },
            { "id": "C", "text": "Runtime Exception" },
            { "id": "D", "text": "DIEM CARPE" }
          ],
          "correctAnswers": ["A"],
          "explanation": "It is legal for the constructors to have throws clause.\nJava compiler adds super(); as the first statement inside Sub class's constructor. super() invokes Super() which throws RuntimeException (unchecked). Sub() throws IOException (checked). Both are valid declarations.\nThere is no compilation error and output is: CARPE DIEM"
        },
        {
          "id": 23,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void getReport() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            throw null; //Line 10\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            getReport(); //Line 16\n        } catch(SQLException e) {\n            System.out.println(\"REPORT ERROR\");\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "NullPointerException" },
            { "id": "B", "text": "Compilation error" },
            { "id": "C", "text": "REPORT ERROR" },
            { "id": "D", "text": "No output" }
          ],
          "correctAnswers": ["A"],
          "explanation": "`throw null;` compiles successfully as null can be assigned to Exception types.\nHowever, at runtime, throwing null causes a NullPointerException. The code does not catch NPE, so the program terminates abruptly with a stack trace."
        },
        {
          "id": 24,
          "type": "single",
          "questionText": "What will be the result of compiling and executing above code?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Super {\n    public String num = \"10\"; //Line n1\n}\n \nclass Sub extends Super {\n    protected int num = 20; //Line n2\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Super obj = new Sub();\n        System.out.println(obj.num += 2); //Line n3\n    }\n}",
          "options": [
            { "id": "A", "text": "102" },
            { "id": "B", "text": "22" },
            { "id": "C", "text": "12" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Subclass overrides the methods of superclass but it hides the variables of superclass.\n'obj' is of Super type, hence obj.num refers to num variable at Line n1, which is of String type.\nExpression at Line n3: obj.num += 2 => obj.num = obj.num + 2 => obj.num = \"10\" + 2 => obj.num = \"102\".\nobj.num refers to \"102\" and same is printed on to the console."
        },
        {
          "id": 25,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Calculator {\n    int calculate(int i1, int i2) {\n        return i1 + i2;\n    }\n\n    double calculate(byte b1, byte b2) {\n        return b1 % b2;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        byte b = 100;\n        int i = 20;\n        System.out.println(new Calculator().calculate(b, i));\n    }\n}",
          "options": [
            { "id": "A", "text": "120" },
            { "id": "B", "text": "Compilation error" },
            { "id": "C", "text": "Runtime Exception" },
            { "id": "D", "text": "0" }
          ],
          "correctAnswers": ["A"],
          "explanation": "calculate method is correctly overloaded.\n`new Calculator().calculate(b, i)` passes a byte and an int.\nThe method `calculate(byte, byte)` cannot be used because int cannot be implicitly converted to byte.\nThe method `calculate(int, int)` is a match because byte can be implicitly promoted to int.\nHence, `calculate(int, int)` is invoked. 100 + 20 = 120."
        },
        {
          "id": 26,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            play();\n            return;\n        } catch(Exception ex) {\n            System.out.println(ex.getMessage());\n            return;\n        } finally {\n            System.out.println(\"MATCH ABANDONED\");\n        }\n        System.out.println(\"DONE\");\n    }\n \n    static void play() throws Exception {\n        throw new Exception(\"INJURED\");\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "MATCH ABANDONED" },
            { "id": "C", "text": "DONE" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Both try and catch blocks have return; statement, which means either of the return statements will definitely get executed.\nHence, compiler tags `System.out.println(\"DONE\");` as unreachable and this causes compilation error."
        },
        {
          "id": 27,
          "type": "multiple",
          "questionText": "Which of the following statements are correct? Select 2 options.",
          "codeSnippet": "//Buyable.java\npackage com.udayankhattry.oca;\npublic interface Buyable {\n    int salePercentage = 85;\n    public static String salePercentage() {\n        return salePercentage + \"%\";\n    }\n}\n//Book.java\npublic class Book implements Buyable {}\n//Test.java\npublic class Test {\n    public static void main(String[] args) {\n        Buyable [] arr = new Buyable[2];\n        for(Buyable b : arr) {\n            System.out.println(b.salePercentage); //Line n1\n            System.out.println(b.salePercentage()); //Line n2\n        }\n        Book [] books = new Book[2];\n        for(Book b : books) {\n            System.out.println(b.salePercentage); //Line n3\n            System.out.println(b.salePercentage()); //Line n4\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "Line n1 compiles" },
            { "id": "B", "text": "Line n2 compiles" },
            { "id": "C", "text": "Line n3 compiles" },
            { "id": "D", "text": "Line n4 compiles" }
          ],
          "correctAnswers": ["A", "C"],
          "explanation": "Correct and only way to access static method of an Interface is by using the name of the interface, such as Buyable.salePercentage(). Line n2 and Line n4 cause compilation error.\nStatic variables of an interface can be accessed via reference variables. Hence, Line n1 and Line n3 compile successfully."
        },
        {
          "id": 28,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"PANIC\";\n        StringBuilder sb = new StringBuilder(\"THET\");\n        System.out.println(str.replace(\"N\", sb)); //Line n1\n    }\n}",
          "options": [
            { "id": "A", "text": "PATHETIC" },
            { "id": "B", "text": "PANIC" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "String class has `replace(CharSequence target, CharSequence replacement)` method.\nAs StringBuilder implements CharSequence, hence instances of StringBuilder can be passed to replace method.\nLine n1 compiles successfully and on execution replaces \"N\" with \"THET\", and hence Line n1 prints PATHETIC on to the console."
        },
        {
          "id": 29,
          "type": "single",
          "questionText": "What is the result?",
          "codeSnippet": "int i = 10;\nSystem.out.println(i > 3 != false);",
          "options": [
            { "id": "A", "text": "true" },
            { "id": "B", "text": "false" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Given Expression: i > 3 != false\n> has higher precedence over !=, hence given expression can be written as: (i > 3) != false\n(10 > 3) is true. true != false is true.\nHence true is printed on to the console."
        },
        {
          "id": 30,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    static String str = \"KEEP IT \"; //Line n1\n    public static void main(String[] args) {\n        String str = str + \"SIMPLE\"; //Line n2\n        System.out.println(str);\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "KEEP IT SIMPLE" },
            { "id": "C", "text": "nullSIMPLE" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "At Line n2, local variable 'str' shadows the static variable 'str' created at Line n1.\nHence, for the expression `str + \"SIMPLE\"`, Java compiler complains as local variable 'str' is used before it is initialized."
        },
        {
          "id": 31,
          "type": "multiple",
          "questionText": "Which of the following statements are correct regarding above code? Select 3 options.",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    int i1 = 10;\n    static int i2 = 20;\n\n    private void change1(int val) {\n        i1 = ++val; //Line n1\n        i2 = val++; //Line n2\n    }\n\n    private static void change2(int val) {\n        i1 = --val; //Line n3\n        i2 = val--; //Line n4\n    }\n\n    public static void main(String[] args) {\n        change1(5); //Line n5\n        change2(5); //Line n6\n        System.out.println(i1 + i2); //Line n7\n    }\n}",
          "options": [
            { "id": "A", "text": "Line n1 compiles" },
            { "id": "B", "text": "Line n2 compiles" },
            { "id": "C", "text": "Line n3 fails" },
            { "id": "D", "text": "Line n5 fails" },
            { "id": "E", "text": "Line n7 fails" }
          ],
          "correctAnswers": ["C", "D", "E"],
          "explanation": "Instance method can access both instance and static members. Hence, Line n1 and Line n2 compile successfully.\nStatic method can access only static members. Hence, Line n3 [accessing instance variable i1], Line n5 [accessing instance method change1(int)] and Line n7 [accessing instance variable i1] cause compilation error."
        },
        {
          "id": 32,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \ninterface Blogger {\n    default void blog() throws Exception {\n        System.out.println(\"GENERIC\");\n    }\n}\n \nclass TravelBlogger implements Blogger {\n    public void blog() {\n        System.out.println(\"TRAVEL\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Blogger blogger = new TravelBlogger(); //Line n1\n        ((TravelBlogger)blogger).blog(); //Line n2\n    }\n}",
          "options": [
            { "id": "A", "text": "TRAVEL" },
            { "id": "B", "text": "GENERIC" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "TravelBlogger class correctly overrides the default method blog() of Blogger interface. It chooses not to throw any checked exception, which is allowed.\nAt Line n2, blog() method is being invoked on typecasting 'blogger' to TravelBlogger. Since TravelBlogger's blog() does not throw a checked exception, the call doesn't need try-catch handling.\nOutput is TRAVEL."
        },
        {
          "id": 33,
          "type": "single",
          "questionText": "What will be the result of compiling and executing above code?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Base {\n    String msg = \"INHALE\"; //Line n1\n}\n \nclass Derived extends Base {\n    Object msg = \"EXHALE\"; //Line n2\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base obj1 = new Base(); //Line n3\n        Base obj2 = new Derived(); //Line n4\n        Derived obj3 = (Derived) obj2; //Line n5\n        String text = obj1.msg + \"-\" + obj2.msg + \"-\" + obj3.msg; //Line n6\n        System.out.println(text); //Line n7\n    }\n}",
          "options": [
            { "id": "A", "text": "INHALE-INHALE-EXHALE" },
            { "id": "B", "text": "INHALE-EXHALE-EXHALE" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Variables are hidden, not overridden. Access depends on reference type.\nobj1 is Base -> msg is \"INHALE\".\nobj2 is Base -> msg is \"INHALE\".\nobj3 is Derived -> msg is \"EXHALE\".\nResult: \"INHALE-INHALE-EXHALE\"."
        },
        {
          "id": 34,
          "type": "multiple",
          "questionText": "Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print EMMA IS RIDING THE HORSE on to the console? Select 4 options.",
          "codeSnippet": "package com.udayankhattry.oca;\n \ninterface Rideable {\n    void ride(String name);\n}\n \nclass Animal {}\n \nclass Horse extends Animal implements Rideable {\n    public void ride(String name) {\n        System.out.println(name.toUpperCase() + \" IS RIDING THE HORSE\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Animal horse = new Horse();\n        /*INSERT*/\n    }\n}",
          "options": [
            { "id": "A", "text": "((Horse)horse).ride(\"Emma\");" },
            { "id": "B", "text": "((Rideable)horse).ride(\"emma\");" },
            { "id": "C", "text": "((Rideable)(Horse)horse).ride(\"EMMA\");" },
            { "id": "D", "text": "((Horse)(Rideable)horse).ride(\"emma\");" },
            { "id": "E", "text": "horse.ride(\"EMMA\");" }
          ],
          "correctAnswers": ["A", "B", "C", "D"],
          "explanation": "Variable 'horse' is of Animal type. Animal does not have ride() method. It must be cast to Horse or Rideable.\n((Horse)horse).ride(...) works.\n((Rideable)horse).ride(...) works.\n((Rideable)(Horse)horse).ride(...) works.\n((Horse)(Rideable)horse).ride(...) works.\nhorse.ride(...) fails."
        },
        {
          "id": 35,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int elements = 0;\n        Object [] arr = {\"A\", \"E\", \"I\", new Object(), \"O\", \"U\"}; //Line n1\n        for(Object obj : arr) { //Line n2\n            if(obj instanceof String) {\n                continue;\n            } else {\n                break;\n            }\n            elements++; //Line n3\n        }\n        System.out.println(elements); //Line n4\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "0" },
            { "id": "C", "text": "6" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "if-else block uses break; and continue; statements. break; will exit the loop and continue; will take the control to loop start. In both the cases Line n3 (elements++;) will never be executed.\nAs Compiler knows about it, hence it tags Line n3 as unreachable, which causes compilation error."
        },
        {
          "id": 36,
          "type": "single",
          "questionText": "Which of the following statements is true for above code?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Paper {\n    static String getType() { //Line n1\n        return \"GENERIC\";\n    }\n}\n \nclass RuledPaper extends Paper {\n    String getType() { //Line n2\n        return \"RULED\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Paper paper = new RuledPaper(); //Line n3\n        System.out.println(paper.getType()); //Line n4\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error at Line n2" },
            { "id": "B", "text": "GENERIC" },
            { "id": "C", "text": "RULED" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Instance method of subclass cannot override the static method of superclass.\nInstance method at Line n2 tries to override the static method at Line n1 and hence Line n2 causes compilation error."
        },
        {
          "id": 37,
          "type": "single",
          "questionText": "Which of the following statements is correct?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"Game on\"; //Line n1\n        StringBuilder sb = new StringBuilder(str); //Line n2\n\n        System.out.println(str.contentEquals(sb)); //Line n3\n        System.out.println(sb.contentEquals(str)); //Line n4\n        System.out.println(sb.equals(str)); //Line n5\n        System.out.println(str.equals(sb)); //Line n6\n    }\n}",
          "options": [
            { "id": "A", "text": "Line n3 prints true" },
            { "id": "B", "text": "Line n4 compiles" },
            { "id": "C", "text": "Line n5 prints true" },
            { "id": "D", "text": "Line n6 prints true" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Line n3: str.contentEquals(sb) works and returns true.\nLine n4: StringBuilder does not have contentEquals. Compilation error.\nLine n5: sb.equals(str) uses Object.equals (identity comparison), returns false.\nLine n6: str.equals(sb) checks if object is String. sb is not String. Returns false."
        },
        {
          "id": 38,
          "type": "single",
          "questionText": "What will be the result of compiling and executing above code?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Currency {\n    String notation = \"-\"; //Line n1\n\n    String getNotation() { //Line n2\n        return notation;\n    }\n}\n \nclass USDollar extends Currency {\n    String notation = \"$\"; //Line n3\n\n    String getNotation() { //Line n4\n        return notation;\n    }\n}\n \nclass Euro extends Currency {\n    protected String notation = \"\"; //Line n5\n\n    protected String getNotation() { //Line n6\n        return notation;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Currency c1 = new USDollar();\n        System.out.println(c1.notation + \":\" + c1.getNotation());\n\n        Currency c2 = new Euro();\n        System.out.println(c2.notation + \":\" + c2.getNotation());\n    }\n}",
          "options": [
            { "id": "A", "text": "-:$ and -:" },
            { "id": "B", "text": "$:$ and :" },
            { "id": "C", "text": "-:- and -:-" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "c1.notation accesses variable in Currency (base type), so \"-\". c1.getNotation() accesses overridden method in USDollar, so \"$\".\nc2.notation accesses variable in Currency, so \"-\". c2.getNotation() accesses overridden method in Euro, so \"\"."
        },
        {
          "id": 39,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> list;\n        list = new ArrayList<>(); //Line n1\n        list.add(\"A\");\n        list.add(\"E\");\n        list.add(\"I\");\n        list.add(\"O\");\n        list.add(\"U\");\n        list.addAll(list.subList(0, 4)); //Line n2\n        System.out.println(list);\n    }\n}",
          "options": [
            { "id": "A", "text": "[A, E, I, O, U, A, E, I, O]" },
            { "id": "B", "text": "[A, E, I, O, U]" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "list.subList(0, 4) returns [A, E, I, O].\nlist.addAll adds these elements to the end of the list.\nResult: [A, E, I, O, U, A, E, I, O]."
        },
        {
          "id": 40,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\"};\n        String place = \"faraway\";\n        System.out.println(arr[place.indexOf(\"a\", 3)]); //Line n1\n    }\n}",
          "options": [
            { "id": "A", "text": "4th" },
            { "id": "B", "text": "3rd" },
            { "id": "C", "text": "5th" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "place.indexOf(\"a\", 3) searches for \"a\" starting at index 3 in \"faraway\". The first \"a\" after index 2 is at index 3.\nIt returns 3.\narr[3] is \"4th\"."
        },
        {
          "id": 41,
          "type": "single",
          "questionText": "What is the result?",
          "codeSnippet": "public class Test {\n    public static void main(String [] args) {\n        System.out.println(\"String\");\n    }\n\n    public static void main(Integer [] args) {\n        System.out.println(\"Integer\");\n    }\n\n    public static void main(byte [] args) {\n        System.out.println(\"byte\");\n    }\n}\n// Command: java Test 10",
          "options": [
            { "id": "A", "text": "String" },
            { "id": "B", "text": "Integer" },
            { "id": "C", "text": "byte" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "The JVM looks for `public static void main(String[] args)`. The other main methods are just overloads. The command line arguments are passed as String[]. Output is \"String\"."
        },
        {
          "id": 42,
          "type": "single",
          "questionText": "Which of the following statement is correct?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nabstract class Log {\n    abstract long count(); //Line n1\n    abstract Object get(); //Line n2\n}\n \nclass CommunicationLog extends Log {\n    int count() { //Line n3\n        return 100;\n    }\n\n    String get() { //Line n4\n        return \"COM-LOG\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Log log = new CommunicationLog(); //Line n5\n        System.out.print(log.count());\n        System.out.print(log.get());\n    }\n}",
          "options": [
            { "id": "A", "text": "Line n3 causes compilation error" },
            { "id": "B", "text": "Line n4 causes compilation error" },
            { "id": "C", "text": "Compiles successfully" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "count() method at Line n1 returns long but overriding method at Line n3 returns int. Primitive return types must be identical. Line n3 causes error."
        },
        {
          "id": 43,
          "type": "multiple",
          "questionText": "Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print MONEY DOESN'T GROW ON TREES on to the console? Select 2 options.",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Parent {\n    String quote = \"MONEY DOESN'T GROW ON TREES\";\n}\n \nclass Child extends Parent {\n    String quote = \"LIVE LIFE KING SIZE\";\n}\n \nclass GrandChild extends Child {\n    String quote = \"PLAY PLAY PLAY\";\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        GrandChild gc = new GrandChild();\n        System.out.println(/*INSERT*/);\n    }\n}",
          "options": [
            { "id": "A", "text": "((Parent)gc).quote" },
            { "id": "B", "text": "((Parent)(Child)gc).quote" },
            { "id": "C", "text": "(Parent)gc.quote" },
            { "id": "D", "text": "gc.quote" }
          ],
          "correctAnswers": ["A", "B"],
          "explanation": "Instance variables are hidden. To access Parent's variable, cast the reference to Parent.\n((Parent)gc).quote works.\n((Parent)(Child)gc).quote works."
        },
        {
          "id": 44,
          "type": "single",
          "questionText": "What is the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int score = 30; // Line n1\n        char grade = 'F'; // Line n2\n        if (50 <= score < 60) // Line n3\n            grade = 'D';\n        else if (60 <= score < 70) // Line n4\n            grade = 'C';\n        else if (70 <= score < 80) // Line n5\n            grade = 'B';\n        else if (score >= 80)\n            grade = 'A';\n        System.out.println(grade);\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "F" },
            { "id": "C", "text": "D" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Expression `50 <= score < 60` is evaluated as `(50 <= score) < 60`. `50 <= score` returns boolean. `boolean < int` is invalid. Causes compilation error."
        },
        {
          "id": 45,
          "type": "single",
          "questionText": "What is the result?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2020-08-31\");\n        System.out.println(date.plusMonths(-6));\n    }\n}",
          "options": [
            { "id": "A", "text": "2020-02-29" },
            { "id": "B", "text": "2020-02-28" },
            { "id": "C", "text": "Exception" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "2020-08-31 minus 6 months is February 2020. Feb 2020 has 29 days (leap year). The day 31 doesn't exist, so it adjusts to the last valid day: 2020-02-29."
        },
        {
          "id": 46,
          "type": "single",
          "questionText": "Line 14 causes compilation error. Which of the following changes enables to code to print LENGTH SHOULD BE GREATER THAN 0?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void convert(String s)\n    throws IllegalArgumentException, RuntimeException, Exception {\n        if(s.length() == 0) {\n            throw new RuntimeException(\"LENGTH SHOULD BE GREATER THAN 0\");\n        }\n    }\n    public static void main(String [] args) {\n        try {\n            convert(\"\");\n        }\n        catch(IllegalArgumentException | RuntimeException | Exception e) { //Line 14\n            System.out.println(e.getMessage()); //Line 15\n        } //Line 16\n        catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "catch(RuntimeException e)" },
            { "id": "B", "text": "catch(Exception e)" },
            { "id": "C", "text": "Remove IllegalArgumentException" },
            { "id": "D", "text": "Remove RuntimeException" }
          ],
          "correctAnswers": ["A"],
          "explanation": "In multi-catch statement, classes with multi-level hierarchical relationship can't be used.\nException > RuntimeException > IllegalArgumentException.\nReplacing with `catch(RuntimeException e)` solves the error."
        },
        {
          "id": 47,
          "type": "single",
          "questionText": "What is the output?",
          "codeSnippet": "String place = \"MISSS\";\nSystem.out.println(place.replace(\"SS\", \"T\"));",
          "options": [
            { "id": "A", "text": "MITS" },
            { "id": "B", "text": "MIST" },
            { "id": "C", "text": "MITT" },
            { "id": "D", "text": "MISSST" }
          ],
          "correctAnswers": ["A"],
          "explanation": "replace scans from start. Found \"SS\" at index 2. Replaces with \"T\". Result \"MITS\". The remaining \"S\" is not part of another \"SS\"."
        },
        {
          "id": 48,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int num = 10;\n        if(num++ == num++) {\n            System.out.println(\"EQUAL \" + num);\n        } else {\n            System.out.println(\"NOT EQUAL \" + num);\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "NOT EQUAL 12" },
            { "id": "B", "text": "EQUAL 12" },
            { "id": "C", "text": "EQUAL 11" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "num++ (10) == num++ (11). 10 == 11 is false. num becomes 12. Prints NOT EQUAL 12."
        },
        {
          "id": 49,
          "type": "single",
          "questionText": "How many above options can be used to fill above blank (separately and not together) such that there is no compilation error?",
          "codeSnippet": "class M {\n}\n \n________ class N {\n}",
          "options": [
            { "id": "A", "text": "2" },
            { "id": "B", "text": "1" },
            { "id": "C", "text": "3" },
            { "id": "D", "text": "4" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Top-level class N (in M.java) can be default (no modifier), final, or abstract. Cannot be public (file name mismatch), private, or protected.\nOptions: final, abstract. Total 2."
        },
        {
          "id": 50,
          "type": "multiple",
          "questionText": "Which of the following options can replace /*INSERT*/ such that on executing Test class all the list elements are displayed in the output? Select 4 options.",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Predicate;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> words = new ArrayList<>();\n        words.add(\"A\");\n        words.add(\"an\");\n        //... other words\n        words.add(\"whether\");\n\n        processStringArray(words, /*INSERT*/);\n    }\n\n    private static void processStringArray(List<String> list, Predicate<String> predicate) {\n        for(String str : list) {\n            if(predicate.test(str)) {\n                System.out.println(str);\n            }\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "p -> true" },
            { "id": "B", "text": "p -> !!!!true" },
            { "id": "C", "text": "p -> p.length() >= 1" },
            { "id": "D", "text": "(String p) -> p.length() < 100" },
            { "id": "E", "text": "p -> !!false" }
          ],
          "correctAnswers": ["A", "B", "C", "D"],
          "explanation": "p -> true (All)\np -> !!!!true (True, All)\np -> p.length() >= 1 (All are non-empty)\n(String p) -> p.length() < 100 (All fit)\nIncorrect: p -> !!false (False, None)."
        },
        {
          "id": 51,
          "type": "single",
          "questionText": "Does above code compile successfully?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(new RuntimeException()); //Line n1\n        System.out.println(new RuntimeException(\"HELLO\")); //Line n2\n        System.out.println(new RuntimeException(new RuntimeException(\"HELLO\"))); //Line n3\n    }\n}",
          "options": [
            { "id": "A", "text": "Yes" },
            { "id": "B", "text": "No" }
          ],
          "correctAnswers": ["A"],
          "explanation": "All 3 constructors are valid for RuntimeException (no-arg, String message, Throwable cause)."
        },
        {
          "id": 52,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.io.FileNotFoundException;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            System.out.println(args[1].length());\n        } catch (RuntimeException ex) {\n            System.out.println(\"ONE\");\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"TWO\");\n        }\n        System.out.println(\"THREE\");\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "Runtime Exception" },
            { "id": "C", "text": "ONE" },
            { "id": "D", "text": "TWO" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Java does not allow catching a checked exception (FileNotFoundException) if it is not thrown by the try block. System.out.println does not throw FileNotFoundException."
        },
        {
          "id": 53,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        for(int x = 10, y = 11, z = 12; y > x && z > y; y++, z -= 2) {\n            System.out.println(x + y + z);\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "33" },
            { "id": "B", "text": "Compilation error" },
            { "id": "C", "text": "Infinite loop" },
            { "id": "D", "text": "No output" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Loop runs once. Init: x=10, y=11, z=12. Condition: 11>10 && 12>11 (True). Print 10+11+12 = 33. Update: y=12, z=10. Condition: 12>10 && 10>12 (False). Stop."
        },
        {
          "id": 54,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String arr1 [], arr2, arr3 = null; //Line n1\n        arr1 = new String[2];\n        arr1[0] = \"A\";\n        arr1[1] = \"B\";\n        arr2 = arr3 = arr1; //Line n2\n        log(arr2); //Line n3\n    }\n \n    private static void log(String... vals) {\n        for(String s : vals)\n            System.out.print(s);\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "AB" },
            { "id": "C", "text": "A" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "arr1 is String[], arr3 is String. arr3 = arr1 is invalid (assigning array to String variable)."
        },
        {
          "id": 55,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> places = new ArrayList<>();\n        places.add(\"Austin\");\n        places.add(\"Okinawa\");\n        places.add(\"Giza\");\n        places.add(\"Manila\");\n        places.add(\"Batam\");\n        places.add(\"Giza\");\n\n        if(places.remove(\"Giza\"))\n            places.remove(\"Austin\");\n\n        System.out.println(places);\n    }\n}",
          "options": [
            { "id": "A", "text": "[Okinawa, Manila, Batam, Giza]" },
            { "id": "B", "text": "[Austin, Okinawa, Manila, Batam, Giza]" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "places.remove(\"Giza\") removes first Giza and returns true. Then places.remove(\"Austin\") executes. Remaining: [Okinawa, Manila, Batam, Giza]."
        },
        {
          "id": 56,
          "type": "single",
          "questionText": "How many statements are true?",
          "codeSnippet": "Consider below code fragment:\nprivate void emp() {}\nAnd the statements:\n1. Given code compiles successfully if it is used inside the class named 'emp'\n2. Given code compiles successfully if it is used inside the class named 'Emp'\n3. Given code compiles successfully if it is used inside the class named 'employee'\n4. Given code compiles successfully if it is used inside the class named 'Employee'\n5. Given code compiles successfully if it is used inside the class named 'Student'\n6. Given code compiles successfully if it is used inside the class named '_emp_'",
          "options": [
            { "id": "A", "text": "6" },
            { "id": "B", "text": "5" },
            { "id": "C", "text": "4" },
            { "id": "D", "text": "0" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Method name can match class name. It is a valid method declaration in all cases."
        },
        {
          "id": 57,
          "type": "single",
          "questionText": "What is the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        boolean b1 = 0;\n        boolean b2 = 1;\n        System.out.println(b1 + b2);\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "1" },
            { "id": "C", "text": "true" },
            { "id": "D", "text": "false" }
          ],
          "correctAnswers": ["A"],
          "explanation": "int 0/1 cannot be assigned to boolean. + operator not defined for boolean."
        },
        {
          "id": 58,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Base {\n    public void log() throws NullPointerException {\n        System.out.println(\"Base: log()\");\n    }\n}\n \nclass Derived extends Base {\n    public void log() throws RuntimeException {\n        System.out.println(\"Derived: log()\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base obj = new Derived();\n        obj.log();\n    }\n}",
          "options": [
            { "id": "A", "text": "Derived: log()" },
            { "id": "B", "text": "Base: log()" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Overriding method can throw any unchecked exception (RuntimeException). Valid override. Polymorphism prints \"Derived: log()\"."
        },
        {
          "id": 59,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Aeroplane class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic interface Flyable {\n    static int horizontalDegree() { //Line n1\n        return 20;\n    }\n \n    default void fly() {\n        System.out.println(\"Flying at \" + horizontalDegree() + \" degrees.\"); //Line n2\n    }\n \n    void land();\n}\n \npublic class Aeroplane implements Flyable {\n    public void land() {\n        System.out.println(\"Landing at \" + -Flyable.horizontalDegree() + \" degrees.\"); //Line n3\n    }\n \n    public static void main(String[] args) {\n        new Aeroplane().fly();\n        new Aeroplane().land();\n    }\n}",
          "options": [
            { "id": "A", "text": "Flying at 20 degrees.\nLanding at -20 degrees." },
            { "id": "B", "text": "Compilation error" },
            { "id": "C", "text": "Runtime Exception" },
            { "id": "D", "text": "No output" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Default methods can call static interface methods. Implementing class can call interface static methods via Interface Name. Code is valid."
        },
        {
          "id": 60,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    private static void test() throws Exception {\n        throw new Exception();\n    }\n    public static void main(String [] args) {\n        try {\n            test();\n        } finally {\n            System.out.println(\"GAME ON\");\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "GAME ON" },
            { "id": "C", "text": "Runtime Exception" },
            { "id": "D", "text": "No output" }
          ],
          "correctAnswers": ["A"],
          "explanation": "test() throws checked Exception. main calls test() inside try-finally but does not catch the Exception or declare it. Compilation error."
        },
        {
          "id": 61,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n \nclass Base {\n    Base() throws IOException {\n        System.out.print(1);\n    }\n}\n \nclass Derived extends Base {\n    Derived() throws FileNotFoundException {\n        System.out.print(2);\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        new Derived();\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "12" },
            { "id": "C", "text": "21" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Derived constructor implicitly calls super() (Base constructor). Base throws IOException. Derived must handle or declare IOException. FileNotFoundException is a subclass, not superclass, so it's not sufficient to declare FileNotFoundException."
        },
        {
          "id": 62,
          "type": "single",
          "questionText": "Which of the following statements is correct?",
          "codeSnippet": "package com.udayankhattry.oca;\n \ninterface Perishable1 {\n    default int maxDays() {\n        return 1;\n    }\n}\n \ninterface Perishable2 extends Perishable1 {\n    default int maxDays() {\n        return 2;\n    }\n}\n \nclass Milk implements Perishable2, Perishable1 {}\n \npublic class Test {\n    public static void main(String[] args) {\n        Perishable1 obj = new Milk();\n        System.out.println(obj.maxDays());\n    }\n}",
          "options": [
            { "id": "A", "text": "Prints 2" },
            { "id": "B", "text": "Compilation error" },
            { "id": "C", "text": "Runtime Exception" },
            { "id": "D", "text": "Prints 1" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Perishable2 overrides maxDays from Perishable1. Milk implements both. Rule: 'Most specific implementation' wins. Perishable2 is more specific. Prints 2."
        },
        {
          "id": 63,
          "type": "single",
          "questionText": "What will be the result of compiling and executing TestMessage class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass Message {\n    String msg = \"LET IT GO!\";\n    public void print() {\n        System.out.println(msg);\n    }\n}\n \npublic class TestMessage {\n    public static void change(Message m) { //Line n5\n        m.msg = \"NEVER LOOK BACK!\"; //Line n6\n    }\n    public static void main(String[] args) {\n        Message obj = new Message(); //Line n1\n        obj.print(); //Line n2\n        change(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}",
          "options": [
            { "id": "A", "text": "LET IT GO!\nNEVER LOOK BACK!" },
            { "id": "B", "text": "LET IT GO!\nLET IT GO!" },
            { "id": "C", "text": "Compilation error" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Java passes references by value. `change(obj)` passes the reference. `m.msg = ...` modifies the object's field. `obj` sees the change."
        },
        {
          "id": 64,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int ctr = 100;\n        one: for (int i = 0; i < 10; i++) {\n            two: for (int j = 0; j < 7; j++) {\n                three: while (true) {\n                    ctr++;\n                    if (i > j) {\n                        break one;\n                    } else if (i == j) {\n                        break two;\n                    } else {\n                        break three;\n                    }\n                }\n            }\n        }\n        System.out.println(ctr);\n    }\n}",
          "options": [
            { "id": "A", "text": "102" },
            { "id": "B", "text": "100" },
            { "id": "C", "text": "101" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "i=0, j=0. ctr=101. i==j -> break two. i increments to 1.\ni=1, j=0. ctr=102. i>j -> break one. Loop ends.\nPrints 102."
        },
        {
          "id": 65,
          "type": "single",
          "questionText": "What is the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        byte b1 = 10; //Line n1\n        int i1 = b1; //Line n2\n        byte b2 = i1; //Line n3\n        System.out.println(b1 + i1 + b2);\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "20" },
            { "id": "C", "text": "Runtime Exception" },
            { "id": "D", "text": "10" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Line n3: `byte b2 = i1;` causes error. int variable cannot be assigned to byte without cast."
        },
        {
          "id": 66,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            try {\n                System.out.println(1/0);\n            } catch(ArithmeticException e) {\n                System.out.println(\"INNER\");\n            } finally {\n                System.out.println(\"FINALLY 1\");\n            }\n        } catch(ArithmeticException e) {\n            System.out.println(\"OUTER\");\n        } finally {\n            System.out.println(\"FINALLY 2\");\n        }\n    }\n}",
          "options": [
            { "id": "A", "text": "INNER\nFINALLY 1\nFINALLY 2" },
            { "id": "B", "text": "INNER\nFINALLY 1" },
            { "id": "C", "text": "OUTER\nFINALLY 2" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Exception caught in INNER. Inner finally runs. Exception swallowed. Outer catch doesn't run. Outer finally runs."
        },
        {
          "id": 67,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = \"RISE \";\n        text = text + (text = \"ABOVE \");\n        System.out.println(text);\n    }\n}",
          "options": [
            { "id": "A", "text": "RISE ABOVE" },
            { "id": "B", "text": "ABOVE ABOVE" },
            { "id": "C", "text": "RISE RISE" },
            { "id": "D", "text": "Compilation error" }
          ],
          "correctAnswers": ["A"],
          "explanation": "text + ... -> \"RISE \" + ... . (text=\"ABOVE \") returns \"ABOVE \". Result: \"RISE \" + \"ABOVE \" = \"RISE ABOVE \"."
        },
        {
          "id": 68,
          "type": "single",
          "questionText": "Which of the following options replaces /*INSERT*/ such that there is no compilation error?",
          "codeSnippet": "import java.util.*;\nclass A{}\nclass B extends A{}\n \nabstract class Super {\n    abstract List<A> get() throws IndexOutOfBoundsException;\n}\n \nabstract class Sub extends Super {\n    /*INSERT*/\n}",
          "options": [
            { "id": "A", "text": "abstract List<A> get() throws ArrayIndexOutOfBoundsException;" },
            { "id": "B", "text": "abstract List<B> get();" },
            { "id": "C", "text": "abstract ArrayList<A> get() throws Exception;" },
            { "id": "D", "text": "abstract ArrayList<B> get();" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Return type must be List<A> or subtype (ArrayList<A>). List<B> is NOT subtype. Exception must be RuntimeException or IndexOutOfBoundsException subclass. A matches."
        },
        {
          "id": 69,
          "type": "multiple",
          "questionText": "Which 3 options, if used to replace /*INSERT*/, will compile successfully and on execution will print \"All is well\" on to the console? Select 3 options.",
          "codeSnippet": "public class Thought {\n    /*INSERT*/ {\n        System.out.println(\"All is well\");\n    }\n}",
          "options": [
            { "id": "A", "text": "static public void main(String [] args)" },
            { "id": "B", "text": "public static void main(String [] a)" },
            { "id": "C", "text": "public static void main(String... a)" },
            { "id": "D", "text": "public void main(String... args)" },
            { "id": "E", "text": "public static Void main(String [] args)" }
          ],
          "correctAnswers": ["A", "B", "C"],
          "explanation": "Valid main methods: A (order swapped is ok), B (arg name changed ok), C (varargs ok)."
        },
        {
          "id": 70,
          "type": "single",
          "questionText": "Which of the following statements is correct?",
          "codeSnippet": "package com.udayankhattry.oca;\n \ninterface I1 {\n    public static void print(String str) {\n        System.out.println(\"I1:\" + str.toUpperCase());\n    }\n}\n \nclass C1 implements I1 {\n    void print(String str) {\n        System.out.println(\"C1:\" + str.toLowerCase());\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        I1 obj = new C1();\n        obj.print(\"Java\");\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "I1:JAVA" },
            { "id": "C", "text": "C1:java" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "`obj.print(\"Java\")` causes error. Interface static methods must be called via Interface name (I1.print), not reference variable."
        },
        {
          "id": 71,
          "type": "single",
          "questionText": "What will be the result of compiling and executing Test class?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass MyClass {\n    MyClass() {\n        System.out.println(101);\n    }\n}\n \nclass MySubClass extends MyClass {\n    final MySubClass() {\n        System.out.println(202);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(new MySubClass());\n    }\n}",
          "options": [
            { "id": "A", "text": "Compilation error" },
            { "id": "B", "text": "101\n202" },
            { "id": "C", "text": "202" },
            { "id": "D", "text": "Runtime Exception" }
          ],
          "correctAnswers": ["A"],
          "explanation": "Constructors cannot be final."
        },
        {
          "id": 72,
          "type": "single",
          "questionText": "What will be the result of compiling and executing above code?",
          "codeSnippet": "package com.udayankhattry.oca;\n \nclass X {\n    void A() {\n        System.out.print(\"A\");\n    }\n}\n \nclass Y extends X {\n    void A() {\n        System.out.print(\"A-\");\n    }\n    \n    void B() {\n        System.out.print(\"B-\");\n    }\n    \n    void C() {\n        System.out.print(\"C-\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        X obj = new Y(); //Line n1\n        obj.A(); //Line n2\n        obj.B(); //Line n3\n        obj.C(); //Line n4\n    }\n}",
          "options": [
            {
              "id": "A",
              "text": "Compilation error"
            },
            {
              "id": "B",
              "text": "A-B-C-"
            },
            {
              "id": "C",
              "text": "A-"
            },
            {
              "id": "D",
              "text": "Runtime Exception"
            }
          ],
          "correctAnswers": [
            "A"
          ],
          "explanation": "obj is of type X. Class X does not have methods B() and C(). Compilation error."
        }
    ]}
]